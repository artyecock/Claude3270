package com.tn3270.model;

import java.awt.Color;
import java.awt.Dimension;
import java.util.Arrays;
import java.util.Map;

public class ScreenModel {
    
    // Dimensions
    private int rows;
    private int cols;
    private int primaryRows;
    private int primaryCols;
    private int alternateRows;
    private int alternateCols;
    private boolean useAlternateSize = false;

    // Buffers
    private char[] buffer;
    private byte[] attributes;
    private byte[] extendedColors;
    private byte[] highlighting;
    
    // Cursor & State
    private int cursorPos = 0;
    private byte currentColor = 0;
    private byte currentHighlight = 0;
    
    // Appearance settings
    private Color[] colors;
    private Color screenBackground = Color.BLACK;
    private Color defaultForeground = Color.GREEN;
    private Color cursorColor = Color.WHITE;

    public ScreenModel(String modelName, Map<String, Dimension> modelsMap) {
        String model = modelName != null ? modelName.trim() : "3278-2";
        Dimension dim = modelsMap.get(model);
        if (dim == null) {
            model = "3278-2";
            dim = modelsMap.get(model);
        }

        // FIX: Primary is ALWAYS 24x80 in standard negotiation
        primaryRows = 24;
        primaryCols = 80;
        
        // Alternate is the specific model size (e.g. 32x80)
        alternateRows = dim.height;
        alternateCols = dim.width;

        // Default to Primary on startup, or Alternate if you prefer immediate switch
        // Standard flow starts in Primary, then Host sends Erase/Write Alternate
        rows = primaryRows;
        cols = primaryCols;
        useAlternateSize = false;

        initBuffers(10000); // Max size covers Mod 5 (27x132 = 3564)
        initColors();
        clearScreen();
    }
    
    private void initBuffers(int maxSize) {
        buffer = new char[maxSize];
        attributes = new byte[maxSize];
        extendedColors = new byte[maxSize];
        highlighting = new byte[maxSize];
    }
    
    private void initColors() {
        colors = new Color[] { Color.BLACK, Color.BLUE, Color.RED, Color.MAGENTA, Color.GREEN, Color.CYAN, Color.YELLOW, Color.WHITE };
    }

    public void clearScreen() {
        int size = buffer.length;
        for (int i = 0; i < size; i++) {
            buffer[i] = ' ';
            attributes[i] = 0;
            extendedColors[i] = 0;
            highlighting[i] = 0;
        }
        cursorPos = 0;
        currentColor = 0;
        currentHighlight = 0;
    }

    // --- State Helpers ---

    public boolean isFieldStart(int pos) {
        if (pos < 0 || pos >= attributes.length) return false;
        return attributes[pos] != 0;
    }

    public boolean isProtected(int pos) {
        int fieldStart = findFieldStart(pos);
        if (fieldStart < 0) return false;
        return (attributes[fieldStart] & 0x20) != 0;
    }

    public boolean isNonDisplay(int pos) {
        int fieldStart = findFieldStart(pos);
        if (fieldStart < 0) return false;
        return (attributes[fieldStart] & 0x0C) == 0x0C;
    }

    public void setModified(int pos) {
        int fieldStart = findFieldStart(pos);
        if (fieldStart >= 0) {
            attributes[fieldStart] |= 0x01;
        }
    }

    public int findFieldStart(int pos) {
        for (int i = 0; i < buffer.length; i++) {
            int x = (pos - i + buffer.length) % buffer.length;
            if (attributes[x] != 0) return x;
        }
        return -1;
    }

    public int findNextField(int pos) {
        int n = (pos + 1) % buffer.length;
        int count = 0;
        while (!isFieldStart(n) && n != pos && count < buffer.length) {
            n = (n + 1) % buffer.length;
            count++;
        }
        return n;
    }

    public void resetMDT() {
        for (int i = 0; i < attributes.length; i++) {
            attributes[i] &= ~0x01;
        }
    }
    
    // --- Getters & Setters ---
    
    public int getSize() { return buffer.length; }
    
    public char getChar(int i) { return buffer[i]; }
    public void setChar(int i, char c) { buffer[i] = c; }
    
    public byte getAttr(int i) { return attributes[i]; }
    public void setAttr(int i, byte b) { attributes[i] = b; }
    
    public byte getExtendedColor(int i) { return extendedColors[i]; }
    public void setExtendedColor(int i, byte b) { extendedColors[i] = b; }
    
    public byte getHighlight(int i) { return highlighting[i]; }
    public void setHighlight(int i, byte b) { highlighting[i] = b; }

    public int getCursorPos() { return cursorPos; }
    public void setCursorPos(int p) { this.cursorPos = p; }
    
    public byte getCurrentColor() { return currentColor; }
    public void setCurrentColor(byte c) { this.currentColor = c; }
    
    public byte getCurrentHighlight() { return currentHighlight; }
    public void setCurrentHighlight(byte h) { this.currentHighlight = h; }

    public int getRows() { return rows; }
    public int getCols() { return cols; }
    
    // NEW: Accessors for Query Reply
    public int getAlternateRows() { return alternateRows; }
    public int getAlternateCols() { return alternateCols; }
    
    public void setUseAlternateSize(boolean alt) {
        this.useAlternateSize = alt;
        if (alt) {
            rows = alternateRows;
            cols = alternateCols;
        } else {
            rows = primaryRows;
            cols = primaryCols;
        }
    }
    
    public boolean isAlternateSize() { return useAlternateSize; }

    public Color[] getPalette() { return colors; }
    public void setPalette(Color[] c) { this.colors = c; }
    
    public Color getScreenBackground() { return screenBackground; }
    public void setScreenBackground(Color c) { this.screenBackground = c; }
    
    public Color getDefaultForeground() { return defaultForeground; }
    public void setDefaultForeground(Color c) { this.defaultForeground = c; }
    
    public Color getCursorColor() { return cursorColor; }
    public void setCursorColor(Color c) { this.cursorColor = c; }
}
