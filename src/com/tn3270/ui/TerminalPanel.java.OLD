package com.tn3270.ui;

import com.tn3270.model.ScreenModel;
import com.tn3270.TN3270Session; 

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TerminalPanel extends JPanel {
    private final ScreenModel model;
    private Font terminalFont;
    private int charWidth;
    private int charHeight;
    private int charAscent;
    private boolean isUpdatingSize = false;
    
    // Cursor Rendering style
    public enum CursorStyle { BLOCK, UNDERSCORE, I_BEAM }
    private CursorStyle cursorStyle = CursorStyle.BLOCK;
    
    public TerminalPanel(ScreenModel model) {
        this.model = model;
        // Default font if setFont hasn't been called by super constructor yet
        if (terminalFont == null) {
            terminalFont = new Font("Monospaced", Font.PLAIN, 14);
        }

        setFocusable(true);
        setFocusTraversalKeysEnabled(false);
        setDoubleBuffered(true);
        setBackground(model.getScreenBackground());

        addMouseWheelListener(e -> {
            Container parent = getParent();
            while (parent != null) {
                if (parent instanceof JScrollPane) {
                    JScrollPane sp = (JScrollPane) parent;
                    sp.dispatchEvent(SwingUtilities.convertMouseEvent(this, e, sp));
                    break;
                }
                parent = parent.getParent();
            }
        });
        
        updateSize();
    }

    public void setCursorStyle(CursorStyle style) {
        this.cursorStyle = style;
        repaint();
    }

    public void updateSize() {
        // FIX: Check if model is null (happens during super() constructor execution)
        if (model == null) return;
        if (isUpdatingSize) return;
        
        isUpdatingSize = true;

        try {
            FontMetrics fm;
            Graphics g = getGraphics();
            
            // Ensure terminalFont is not null
            Font fontToUse = (terminalFont != null) ? terminalFont : new Font("Monospaced", Font.PLAIN, 14);

            if (g != null) {
                fm = g.getFontMetrics(fontToUse);
                g.dispose();
            } else {
                fm = this.getFontMetrics(fontToUse);
            }

            if (fm != null) {
                this.charWidth = fm.charWidth('M');
                this.charHeight = fm.getHeight();
                this.charAscent = fm.getAscent();
            } else {
                // Fallback if not displayable yet
                this.charWidth = 9; 
                this.charHeight = 16;
                this.charAscent = 12;
            }

            int w = (model.getCols() * this.charWidth) + 24;
            int h = (model.getRows() * this.charHeight) + 24;

            setPreferredSize(new Dimension(w, h));

            Container parent = getParent();
            if (parent instanceof JViewport && parent.getParent() instanceof JScrollPane) {
                JScrollPane sp = (JScrollPane) parent.getParent();
                sp.getVerticalScrollBar().setUnitIncrement(this.charHeight);
                sp.getHorizontalScrollBar().setUnitIncrement(this.charWidth);
            }

            revalidate();
            repaint();
        } finally {
            isUpdatingSize = false;
        }
    }

    @Override
    public void setFont(Font f) {
        super.setFont(f);
        this.terminalFont = f;
        // FIX: Only update size if model is initialized
        if (model != null) {
            updateSize();
        }
    }
    
    public Font getTerminalFont() { return terminalFont; }
    public int getCharWidth() { return charWidth; }
    public int getCharHeight() { return charHeight; }

@Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        if (model == null) return; 

        // FIX: Enable High-Quality Text Rendering
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        
        // Sync background color
        setBackground(model.getScreenBackground());
        g.setFont(terminalFont);

        boolean blinkVisible = (System.currentTimeMillis() / 500) % 2 == 0;
        
        int cols = model.getCols();
        int rows = model.getRows();

        int gridWidth = cols * this.charWidth;
        int gridHeight = rows * this.charHeight;

        int marginLeft = Math.max(5, (getWidth() - gridWidth) / 2);
        int marginTop  = Math.max(5, (getHeight() - gridHeight) / 2);

        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int pos = row * cols + col;
                char c = model.getChar(pos);

                if (model.isNonDisplay(pos) && !model.isFieldStart(pos)) continue;
                
                if (model.getAttr(pos) != 0) c = ' ';
                else if (c == '\0') c = ' ';

                Color fg = model.getDefaultForeground();
                Color bg = model.getScreenBackground();
                boolean reverseVideo = false;
                boolean blink = false;
                boolean underscore = false;

                byte highlight = model.getHighlight(pos);
                if (highlight == 0 && model.getAttr(pos) == 0) {
                    int fieldStart = model.findFieldStart(pos);
                    if (fieldStart >= 0) highlight = model.getHighlight(fieldStart);
                }

                if (model.getAttr(pos) == 0) {
                    if (highlight == (byte) 0xF2) reverseVideo = true;
                    else if (highlight == (byte) 0xF1) blink = true;
                    else if (highlight == (byte) 0xF4) underscore = true;
                }

                byte extCol = model.getExtendedColor(pos);
                Color[] palette = model.getPalette();
                
                if (extCol > 0 && extCol < palette.length) {
                    fg = palette[extCol];
                } else {
                    int fieldStart = model.findFieldStart(pos);
                    if (fieldStart >= 0) {
                        byte fsCol = model.getExtendedColor(fieldStart);
                        if (fsCol > 0 && fsCol < palette.length) {
                            fg = palette[fsCol];
                        } else {
                            byte attr = model.getAttr(fieldStart);
                            boolean isProtected = (attr & 0x20) != 0;
                            boolean isIntensified = (attr & 0x08) != 0;
                            if ((attr & 0x0C) == 0x0C) fg = bg;
                            else if (isProtected) fg = isIntensified ? Color.WHITE : Color.CYAN;
                            else fg = isIntensified ? Color.WHITE : Color.GREEN;
                        }
                    }
                }

                int cellTop = marginTop + (row * this.charHeight);
                int x = marginLeft + (col * this.charWidth);
                int y = cellTop + this.charAscent; 

                if (reverseVideo) {
                    Color temp = fg; fg = bg; bg = temp;
                }

                if (!bg.equals(model.getScreenBackground())) {
                    g.setColor(bg);
                    g.fillRect(x, cellTop, this.charWidth, this.charHeight);
                }

                if (blink && !blinkVisible) continue;

                g.setColor(fg);
                g.drawString(String.valueOf(c), x, y);

                if (underscore) {
                    g.drawLine(x, y + 2, x + this.charWidth, y + 2);
                }
            }
        }

        // Draw Cursor
        int cPos = model.getCursorPos();
        int row = cPos / cols;
        int col = cPos % cols;
        int x = marginLeft + col * this.charWidth;
        int y = marginTop + row * this.charHeight;

        g.setColor(model.getCursorColor());

        switch (cursorStyle) {
            case BLOCK:
                g.fillRect(x, y, this.charWidth, this.charHeight);
                g.setXORMode(model.getScreenBackground());
                break;
            case UNDERSCORE:
                g.fillRect(x, y + this.charHeight - 2, this.charWidth, 2);
                break;
            case I_BEAM:
                g.fillRect(x, y, 2, this.charHeight);
                break;
        }
        g.setPaintMode();
    }
}
