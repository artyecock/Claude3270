package com.tn3270.ui;

import com.tn3270.model.ScreenModel;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;

public class TerminalPanel extends JPanel {

    private final ScreenModel screenModel;
    private Font terminalFont;
    private int charWidth;
    private int charHeight;
    private int charAscent;
    private boolean isUpdatingSize = false;
    
    // Selection State
    private int selectionStart = -1;
    private int selectionEnd = -1;
    private boolean selecting = false;

    public enum CursorStyle { BLOCK, UNDERSCORE, I_BEAM }
    private CursorStyle cursorStyle = CursorStyle.BLOCK;

    public TerminalPanel(ScreenModel model) {
        this.screenModel = model;
        this.terminalFont = new Font("Monospaced", Font.PLAIN, 16);
        
        setBackground(Color.BLACK);
        setForeground(Color.GREEN);
        setDoubleBuffered(true);
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);

        // Calculate initial size
        updateSize();
        
        // Mouse Listeners for Selection
        addMouseListener(new MouseAdapter() {
            @Override public void mousePressed(MouseEvent e) {
                requestFocusInWindow();
                if (SwingUtilities.isLeftMouseButton(e)) {
                    int pos = screenPositionFromMouse(e.getX(), e.getY());
                    if (pos >= 0) {
                        selecting = true;
                        selectionStart = pos;
                        selectionEnd = pos;
                        repaint();
                    }
                }
            }
            @Override public void mouseReleased(MouseEvent e) {
                selecting = false;
            }
        });
        
        addMouseMotionListener(new MouseMotionAdapter() {
            @Override public void mouseDragged(MouseEvent e) {
                if (selecting) {
                    int pos = screenPositionFromMouse(e.getX(), e.getY());
                    if (pos >= 0) {
                        selectionEnd = pos;
                        repaint();
                    }
                }
            }
        });
    }

    public void updateSize() {
        if (isUpdatingSize) return;
        
        // FIX: Check if model is initialized. 
        // Swing calls setFont() inside the super() constructor, 
        // before screenModel is assigned.
        if (screenModel == null) return;
        
        isUpdatingSize = true;
        try {
            // Ensure we use the correct font
            Font f = (terminalFont != null) ? terminalFont : getFont();
            if (f == null) return;

            FontMetrics fm = getFontMetrics(f);
            this.charWidth = fm.charWidth('M');
            this.charHeight = fm.getHeight();
            this.charAscent = fm.getAscent();

            int cols = screenModel.getCols();
            int rows = screenModel.getRows();
            
            // Add padding
            int w = (cols * charWidth) + 20;
            int h = (rows * charHeight) + 20;
            setPreferredSize(new Dimension(w, h));
            revalidate();
            repaint();
        } finally {
            isUpdatingSize = false;
        }
    }

    @Override
    public void setFont(Font f) {
        super.setFont(f);
        this.terminalFont = f;
        updateSize();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        // Safety check for early rendering calls
        if (screenModel == null) return;
        
        // Anti-aliasing for text
        if (g instanceof Graphics2D) {
            ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        }

        g.setFont(terminalFont);

        int cols = screenModel.getCols();
        int rows = screenModel.getRows();
        char[] buffer = screenModel.getBuffer();
        byte[] attr = screenModel.getAttributes();
        byte[] extColors = screenModel.getExtendedColors();
        byte[] highlight = screenModel.getHighlight();
        
        // Use palette from model
        Color[] palette = screenModel.getPalette();

        // Calculate Centering
        int gridWidth = cols * charWidth;
        int gridHeight = rows * charHeight;
        int marginLeft = Math.max(10, (getWidth() - gridWidth) / 2);
        int marginTop = Math.max(10, (getHeight() - gridHeight) / 2);

        boolean blinkVisible = (System.currentTimeMillis() / 500) % 2 == 0;

        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int pos = row * cols + col;
                if (pos >= buffer.length) break;

                char c = buffer[pos];
                
                // Handle Field Attributes (display as blank)
                if (screenModel.isFieldStart(pos)) c = ' ';
                if (c == '\0') c = ' ';

                // Defaults
                Color fg = getForeground(); // Default Green (or whatever was set)
                Color bg = getBackground(); // Default Black
                boolean reverse = false;
                boolean underscore = false;

                // 1. Extended Color Logic
                if (extColors[pos] > 0 && extColors[pos] < palette.length) {
                    fg = palette[extColors[pos]];
                } 
                else {
                    int fieldStart = screenModel.findFieldStart(pos);
                    if (fieldStart >= 0) {
                        byte fieldColor = extColors[fieldStart];
                        if (fieldColor > 0 && fieldColor < palette.length) {
                            fg = palette[fieldColor];
                        } else {
                            byte a = attr[fieldStart];
                            boolean high = (a & 0x08) != 0;
                            boolean prot = (a & 0x20) != 0;
                            if (prot && high) fg = palette[7]; // White
                            else if (prot)    fg = palette[5]; // Turquoise
                            else if (high)    fg = palette[2]; // Red
                            else              fg = palette[4]; // Green
                        }
                    }
                }

                // 2. Highlighting
                byte hl = highlight[pos];
                if (hl == 0) {
                    int fs = screenModel.findFieldStart(pos);
                    if (fs >= 0) hl = highlight[fs];
                }
                if (hl == 0xF1) { if (!blinkVisible) continue; } // Blink
                if (hl == 0xF2) reverse = true;
                if (hl == 0xF4) underscore = true;

                // 3. Selection Highlighting
                if (isPosSelected(pos)) {
                    fg = Color.WHITE;
                    bg = new Color(0, 120, 215); // Selection Blue
                    reverse = false; 
                }

                // 4. Render
                int x = marginLeft + (col * charWidth);
                int y = marginTop + (row * charHeight); // Top of cell

                if (reverse) {
                    Color tmp = fg; fg = bg; bg = tmp;
                }

                if (!bg.equals(getBackground())) {
                    g.setColor(bg);
                    g.fillRect(x, y, charWidth, charHeight);
                }

                g.setColor(fg);
                // Draw text at baseline
                g.drawString(String.valueOf(c), x, y + charAscent);

                if (underscore) {
                    g.drawLine(x, y + charAscent + 2, x + charWidth, y + charAscent + 2);
                }
            }
        }

        // Draw Cursor
        if (!screenModel.isKeyboardLocked() && hasFocus()) {
            int cPos = screenModel.getCursorPos();
            if (cPos >= 0 && cPos < buffer.length) {
                int cRow = cPos / cols;
                int cCol = cPos % cols;
                int cx = marginLeft + (cCol * charWidth);
                int cy = marginTop + (cRow * charHeight);

                g.setColor(screenModel.getCursorColor());
                
                if (cursorStyle == CursorStyle.BLOCK) {
                    g.setXORMode(getBackground());
                    g.fillRect(cx, cy, charWidth, charHeight);
                    g.setPaintMode();
                } else if (cursorStyle == CursorStyle.UNDERSCORE) {
                    g.fillRect(cx, cy + charHeight - 2, charWidth, 2);
                } else {
                    g.fillRect(cx, cy, 2, charHeight);
                }
            }
        }
    }
    
    private boolean isPosSelected(int pos) {
        if (selectionStart < 0 || selectionEnd < 0) return false;
        int s = Math.min(selectionStart, selectionEnd);
        int e = Math.max(selectionStart, selectionEnd);
        return pos >= s && pos <= e;
    }

    private int screenPositionFromMouse(int x, int y) {
        // Fix for potential NPE in mouse handling before init
        if (screenModel == null) return -1;
        
        int cols = screenModel.getCols();
        int rows = screenModel.getRows();
        int gridWidth = cols * charWidth;
        int gridHeight = rows * charHeight;
        int marginLeft = Math.max(10, (getWidth() - gridWidth) / 2);
        int marginTop = Math.max(10, (getHeight() - gridHeight) / 2);

        int col = (x - marginLeft) / charWidth;
        int row = (y - marginTop) / charHeight;

        if (col >= 0 && col < cols && row >= 0 && row < rows) {
            return row * cols + col;
        }
        return -1;
    }

    public void setCursorStyle(CursorStyle style) { this.cursorStyle = style; repaint(); }
    public Font getTerminalFont() { return terminalFont; }
    
    // Selection Helpers
    public void clearSelection() { selectionStart = -1; selectionEnd = -1; repaint(); }
    public void selectAll() { selectionStart = 0; selectionEnd = screenModel.getSize() - 1; repaint(); }
    public String getSelectedText() {
        if (selectionStart < 0 || selectionEnd < 0) return "";
        int s = Math.min(selectionStart, selectionEnd);
        int e = Math.max(selectionStart, selectionEnd);
        StringBuilder sb = new StringBuilder();
        int cols = screenModel.getCols();
        for (int i = s; i <= e; i++) {
            char c = screenModel.getChar(i);
            sb.append(c == '\0' ? ' ' : c);
            if ((i + 1) % cols == 0) sb.append('\n');
        }
        return sb.toString().trim();
    }
    public boolean hasSelection() { return selectionStart >= 0 && selectionEnd >= 0; }
}
