package com.tn3270.ui;

import com.tn3270.model.ScreenModel;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;

public class TerminalPanel extends JPanel implements Scrollable { // Implement Scrollable

    private final ScreenModel screenModel;
    private Font terminalFont;
    private int charWidth;
    private int charHeight;
    private int charAscent;
    private boolean isUpdatingSize = false;
    
    // Selection State
    private int selectionStart = -1;
    private int selectionEnd = -1;
    private boolean selecting = false;

    public enum CursorStyle { BLOCK, UNDERSCORE, I_BEAM }
    private CursorStyle cursorStyle = CursorStyle.BLOCK;

    public TerminalPanel(ScreenModel model) {
        this.screenModel = model;
        
        // Default Font Logic
        int fontSize = 14;
        int cols = model.getCols();
        if (cols >= 160) fontSize = 9;
        else if (cols >= 132) fontSize = 11;
        
        this.terminalFont = new Font("Monospaced", Font.PLAIN, fontSize);
        
        setBackground(Color.BLACK);
        setForeground(Color.GREEN);
        setDoubleBuffered(true);
        setFocusable(true);
        
        updateSize();
        
        addMouseListener(new MouseAdapter() {
            @Override public void mousePressed(MouseEvent e) {
                requestFocusInWindow();
                if (SwingUtilities.isLeftMouseButton(e)) {
                    int pos = screenPositionFromMouse(e.getX(), e.getY());
                    if (pos >= 0) {
                        selecting = true;
                        selectionStart = pos;
                        selectionEnd = pos;
                        repaint();
                    }
                }
            }
            @Override public void mouseReleased(MouseEvent e) { selecting = false; }
        });
        
        addMouseMotionListener(new MouseMotionAdapter() {
            @Override public void mouseDragged(MouseEvent e) {
                if (selecting) {
                    int pos = screenPositionFromMouse(e.getX(), e.getY());
                    if (pos >= 0) { selectionEnd = pos; repaint(); }
                }
            }
        });
    }

    // --- SCROLLABLE INTERFACE (The Fix for Filling the Viewport) ---
    @Override public Dimension getPreferredScrollableViewportSize() { return getPreferredSize(); }
    @Override public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) { return charHeight; }
    @Override public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) { return charHeight * 10; }
    
    // This forces the Panel to act like a background layer filling the scroll pane
    // This moves the "Black Banding" responsibility from the ScrollPane to this Panel,
    // where we can handle it intelligently.
    @Override 
    public boolean getScrollableTracksViewportWidth() { 
        return getParent() instanceof JViewport && getParent().getWidth() > getPreferredSize().width; 
    }
    
    @Override 
    public boolean getScrollableTracksViewportHeight() { 
        return getParent() instanceof JViewport && getParent().getHeight() > getPreferredSize().height; 
    }

    public void fitToSize(int availableWidth, int availableHeight) {
        if (availableWidth <= 0 || availableHeight <= 0) return;
        
        int targetW = availableWidth; // Use full width (scale logic handles margins)
        int targetH = availableHeight;
        int bestSize = 6;
        
        // Expanded range to support 4K monitors (up to 72pt)
        for (int s = 72; s >= 6; s--) {
            Font testFont = new Font("Monospaced", Font.PLAIN, s);
            FontMetrics fm = getFontMetrics(testFont);
            int totalW = fm.charWidth('M') * screenModel.getCols();
            int totalH = fm.getHeight() * screenModel.getRows();
            
            if (totalW <= targetW && totalH <= targetH) {
                bestSize = s;
                break;
            }
        }
        setFont(new Font("Monospaced", Font.PLAIN, bestSize));
    }
/*
    public void updateSize() {
        if (isUpdatingSize || screenModel == null) return;
        isUpdatingSize = true;
        try {
            Font f = (terminalFont != null) ? terminalFont : getFont();
            if (f == null) return;
            FontMetrics fm = getFontMetrics(f);
            this.charWidth = fm.charWidth('M');
            this.charHeight = fm.getHeight();
            this.charAscent = fm.getAscent();
            int cols = screenModel.getCols();
            int rows = screenModel.getRows();
            // Exact sizing ensures getPreferredSize reflects the font accurately
            setPreferredSize(new Dimension(cols * charWidth, rows * charHeight));
            revalidate();
            repaint();
        } finally {
            isUpdatingSize = false;
        }
    }
  */  
    public void updateSize() {
        if (isUpdatingSize || screenModel == null) return;
        isUpdatingSize = true;
        try {
            Font f = (terminalFont != null) ? terminalFont : getFont();
            if (f == null) return;
            FontMetrics fm = getFontMetrics(f);
            this.charWidth = fm.charWidth('M');
            this.charHeight = fm.getHeight();
            this.charAscent = fm.getAscent();
            
            int cols = screenModel.getCols();
            int rows = screenModel.getRows();
            
            // STRICT calculation: Exact pixel dimensions required by the grid
            int w = cols * charWidth;
            int h = rows * charHeight;
            
            setPreferredSize(new Dimension(w, h));
            
            // Important: Invalidate so parent containers know size changed
            revalidate(); 
            repaint();
        } finally {
            isUpdatingSize = false;
        }
    }

    @Override
    public void setFont(Font f) {
        super.setFont(f);
        this.terminalFont = f;
        updateSize();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (screenModel == null) return;
        
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

        int cols = screenModel.getCols();
        int rows = screenModel.getRows();
        int gridWidth = cols * charWidth;
        int gridHeight = rows * charHeight;
        
        double scaleX = 1.0;
        double scaleY = 1.0;
        int marginLeft = 0;
        int marginTop = 0;

        // --- SMART STRETCH LOGIC ---
        // Only stretch if the discrepancy is small (e.g. < 2 characters of leftover space).
        // This implies "Auto-Fit" was attempted but integer math left a gap (Black Band).
        // If the gap is huge, the user likely chose a manual small font -> Don't stretch, just center.
        
        int w = getWidth();
        int h = getHeight();
        
        boolean closeEnoughWidth = Math.abs(w - gridWidth) < (charWidth * 2);
        boolean closeEnoughHeight = Math.abs(h - gridHeight) < (charHeight * 2);

        if (gridWidth > 0 && gridHeight > 0 && closeEnoughWidth && closeEnoughHeight) {
            // Apply Stretch to remove bands
            scaleX = (double) w / (double) gridWidth;
            scaleY = (double) h / (double) gridHeight;
        } else {
            // Manual Mode: Center the grid
            marginLeft = Math.max(0, (w - gridWidth) / 2);
            marginTop = Math.max(0, (h - gridHeight) / 2);
        }

        java.awt.geom.AffineTransform oldTransform = g2d.getTransform();
        if (scaleX != 1.0 || scaleY != 1.0) {
            g2d.scale(scaleX, scaleY);
        }

        g2d.setFont(terminalFont);

        char[] buffer = screenModel.getBuffer();
        byte[] attr = screenModel.getAttributes();
        byte[] extColors = screenModel.getExtendedColors();
        byte[] highlight = screenModel.getHighlight();
        Color[] palette = screenModel.getPalette();
        
        boolean blinkVisible = (System.currentTimeMillis() / 500) % 2 == 0;

        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int pos = row * cols + col;
                if (pos >= buffer.length) break;

                char c = buffer[pos];
                if (screenModel.isFieldStart(pos)) c = ' ';
                if (c == '\0') c = ' ';

                Color fg = getForeground();
                Color bg = getBackground();
                boolean reverse = false;
                boolean underscore = false;
                boolean isHidden = false;

                int fieldStart = screenModel.findFieldStart(pos);
                byte a = (fieldStart >= 0) ? attr[fieldStart] : 0;
                
                if ((a & 0x0C) == 0x0C) { isHidden = true; c = ' '; }

                if (!isHidden) {
                    if (extColors[pos] > 0 && extColors[pos] < palette.length) {
                        fg = palette[extColors[pos]];
                    } else if (fieldStart >= 0) {
                        byte fieldColor = extColors[fieldStart];
                        if (fieldColor > 0 && fieldColor < palette.length) fg = palette[fieldColor];
                        else {
                            boolean high = (a & 0x08) != 0;
                            boolean prot = (a & 0x20) != 0;
                            if (prot && high) fg = palette[7];
                            else if (prot)    fg = palette[5];
                            else if (high)    fg = palette[2];
                            else              fg = palette[4];
                        }
                    }
                    byte hl = highlight[pos];
                    if (hl == 0 && fieldStart >= 0) hl = highlight[fieldStart];
                    if (hl == 0xF1 && !blinkVisible) c = ' ';
                    if (hl == 0xF2) reverse = true;
                    if (hl == 0xF4) underscore = true;
                }

                if (isPosSelected(pos)) {
                    fg = Color.WHITE;
                    bg = new Color(0, 120, 215);
                    reverse = false;
                }

                int x = marginLeft + (col * charWidth);
                int y = marginTop + (row * charHeight);

                if (reverse) { Color tmp = fg; fg = bg; bg = tmp; }

                if (!bg.equals(getBackground())) {
                    g2d.setColor(bg);
                    g2d.fillRect(x, y, charWidth, charHeight);
                }

                g2d.setColor(fg);
                g2d.drawString(String.valueOf(c), x, y + charAscent);

                if (underscore && !isHidden) {
                    g2d.drawLine(x, y + charAscent + 2, x + charWidth, y + charAscent + 2);
                }
            }
        }
        
        // Cursor
        if (!screenModel.isKeyboardLocked() && hasFocus()) {
            int cPos = screenModel.getCursorPos();
            if (cPos >= 0 && cPos < buffer.length) {
                int cRow = cPos / cols;
                int cCol = cPos % cols;
                int cx = marginLeft + (cCol * charWidth);
                int cy = marginTop + (cRow * charHeight);

                g2d.setColor(screenModel.getCursorColor());
                if (cursorStyle == CursorStyle.BLOCK) {
                    g2d.setXORMode(getBackground());
                    g2d.fillRect(cx, cy, charWidth, charHeight);
                    g2d.setPaintMode();
                } else if (cursorStyle == CursorStyle.UNDERSCORE) {
                    g2d.fillRect(cx, cy + charHeight - 2, charWidth, 2);
                } else {
                    g2d.fillRect(cx, cy, 2, charHeight);
                }
            }
        }
        
        g2d.setTransform(oldTransform);
    }
    
    private boolean isPosSelected(int pos) {
        if (selectionStart < 0 || selectionEnd < 0) return false;
        int s = Math.min(selectionStart, selectionEnd);
        int e = Math.max(selectionStart, selectionEnd);
        return pos >= s && pos <= e;
    }
    
    // Updated Mouse Logic to handle Smart Stretch or Center
    private int screenPositionFromMouse(int x, int y) {
        if (screenModel == null) return -1;
        int cols = screenModel.getCols();
        int rows = screenModel.getRows();
        int gridWidth = cols * charWidth;
        int gridHeight = rows * charHeight;
        if (gridWidth == 0 || gridHeight == 0) return -1;

        int w = getWidth();
        int h = getHeight();
        
        // Replicate logic from paintComponent
        boolean closeEnoughWidth = Math.abs(w - gridWidth) < (charWidth * 2);
        boolean closeEnoughHeight = Math.abs(h - gridHeight) < (charHeight * 2);
        
        double scaleX = 1.0, scaleY = 1.0;
        int marginLeft = 0, marginTop = 0;

        if (closeEnoughWidth && closeEnoughHeight) {
            scaleX = (double) w / (double) gridWidth;
            scaleY = (double) h / (double) gridHeight;
        } else {
            marginLeft = Math.max(0, (w - gridWidth) / 2);
            marginTop = Math.max(0, (h - gridHeight) / 2);
        }

        // Adjust mouse coords
        int logicalX = (int) ((x / scaleX) - marginLeft);
        int logicalY = (int) ((y / scaleY) - marginTop);

        int col = logicalX / charWidth;
        int row = logicalY / charHeight;

        if (col >= 0 && col < cols && row >= 0 && row < rows) {
            return row * cols + col;
        }
        return -1;
    }
    
    // ... rest of class getters/setters ...
    public void setCursorStyle(CursorStyle style) { this.cursorStyle = style; repaint(); }
    public Font getTerminalFont() { return terminalFont; }
    public void clearSelection() { selectionStart = -1; selectionEnd = -1; repaint(); }
    public void selectAll() { selectionStart = 0; selectionEnd = screenModel.getSize() - 1; repaint(); }
    public String getSelectedText() {
        if (selectionStart < 0 || selectionEnd < 0) return "";
        int s = Math.min(selectionStart, selectionEnd);
        int e = Math.max(selectionStart, selectionEnd);
        StringBuilder sb = new StringBuilder();
        int cols = screenModel.getCols();
        for (int i = s; i <= e; i++) {
            char c = screenModel.getChar(i);
            sb.append(c == '\0' ? ' ' : c);
            if ((i + 1) % cols == 0) sb.append('\n');
        }
        return sb.toString().trim();
    }
    public boolean hasSelection() { return selectionStart >= 0 && selectionEnd >= 0; }
}