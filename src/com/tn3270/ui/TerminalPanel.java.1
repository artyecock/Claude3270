package com.tn3270.ui;

import com.tn3270.model.ScreenModel;
import com.tn3270.ai.AIManager; // Needed for Right-Click menu
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TerminalPanel extends JPanel {
    private final ScreenModel model;
    private Font terminalFont;
    private int charWidth;
    private int charHeight;
    private int charAscent;
    private boolean isUpdatingSize = false;
    
    // Selection State (Moved from Session)
    private int selectionStart = -1;
    private int selectionEnd = -1;
    private boolean selecting = false;
    private Point dragStart;
    
    public enum CursorStyle { BLOCK, UNDERSCORE, I_BEAM }
    private CursorStyle cursorStyle = CursorStyle.BLOCK;
    
    public TerminalPanel(ScreenModel model) {
        this.model = model;
        this.terminalFont = new Font(Font.MONOSPACED, Font.PLAIN, 14);

        setFocusable(true);
        setFocusTraversalKeysEnabled(false);
        setDoubleBuffered(true);
        setBackground(model.getScreenBackground());

        // Mouse Scrolling
        addMouseWheelListener(e -> {
            Container parent = getParent();
            while (parent != null) {
                if (parent instanceof JScrollPane) {
                    JScrollPane sp = (JScrollPane) parent;
                    sp.dispatchEvent(SwingUtilities.convertMouseEvent(this, e, sp));
                    break;
                }
                parent = parent.getParent();
            }
        });
        
        // Mouse Selection & Clicks
        addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent e) {
                requestFocusInWindow();
                if (e.isPopupTrigger() || SwingUtilities.isRightMouseButton(e)) {
                    doContextPopup(e);
                    return;
                }
                handleMousePress(e);
            }
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger() || SwingUtilities.isRightMouseButton(e)) {
                    doContextPopup(e);
                    return;
                }
                handleMouseRelease(e);
            }
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) selectWord(e);
                else if (e.getClickCount() == 3) selectLine(e);
            }
        });

        addMouseMotionListener(new MouseMotionAdapter() {
            public void mouseDragged(MouseEvent e) { handleMouseDrag(e); }
        });
        
        updateSize();
    }
    
    private void doContextPopup(MouseEvent e) {
        String text = getSelectedText();
        if (!text.isEmpty()) {
             // Find frame for dialog
             Window win = SwingUtilities.getWindowAncestor(this);
             if (win instanceof Frame) {
                 AIManager.getInstance().showChatDialog((Frame)win, text);
             }
        }
    }

    // --- Selection Logic (Copied from Monolith) ---

    private void handleMousePress(MouseEvent e) {
        int pos = screenPositionFromMouse(e.getX(), e.getY());
        if (pos >= 0 && pos < model.getSize()) {
            selecting = true;
            selectionStart = pos;
            selectionEnd = pos;
            dragStart = e.getPoint();
            repaint();
        }
    }

    private void handleMouseDrag(MouseEvent e) {
        if (selecting) {
            int pos = screenPositionFromMouse(e.getX(), e.getY());
            if (pos >= 0 && pos < model.getSize()) {
                selectionEnd = pos;
                repaint();
            }
        }
    }

    private void handleMouseRelease(MouseEvent e) {
        if (selecting) {
            selecting = false;
            if (selectionStart > selectionEnd) {
                int temp = selectionStart;
                selectionStart = selectionEnd;
                selectionEnd = temp;
            }
        }
    }

    private void selectWord(MouseEvent e) {
        int pos = screenPositionFromMouse(e.getX(), e.getY());
        if (pos >= 0 && pos < model.getSize()) {
            int start = pos;
            int end = pos;
            while (start > 0 && isWordChar(model.getChar(start - 1))) start--;
            while (end < model.getSize() - 1 && isWordChar(model.getChar(end + 1))) end++;
            selectionStart = start;
            selectionEnd = end;
            repaint();
        }
    }

    private void selectLine(MouseEvent e) {
        int pos = screenPositionFromMouse(e.getX(), e.getY());
        if (pos >= 0 && pos < model.getSize()) {
            int cols = model.getCols();
            int row = pos / cols;
            selectionStart = row * cols;
            selectionEnd = (row + 1) * cols - 1;
            repaint();
        }
    }

    private boolean isWordChar(char c) {
        return Character.isLetterOrDigit(c) || c == '_' || c == '-' || c == '.';
    }

    private int screenPositionFromMouse(int x, int y) {
        int cols = model.getCols();
        int rows = model.getRows();
        
        // Calculate same margins as paintComponent
        int gridWidth = cols * this.charWidth;
        int gridHeight = rows * this.charHeight;
        int marginLeft = Math.max(5, (getWidth() - gridWidth) / 2);
        int marginTop  = Math.max(5, (getHeight() - gridHeight) / 2);

        int col = (x - marginLeft) / this.charWidth;
        int row = (y - marginTop) / this.charHeight;

        if (col < 0) col = 0; if (col >= cols) col = cols - 1;
        if (row < 0) row = 0; if (row >= rows) row = rows - 1;

        return row * cols + col;
    }
    
    // --- Public Selection API ---
    
    public void selectAll() {
        selectionStart = 0;
        selectionEnd = model.getSize() - 1;
        repaint();
    }
    
    public void clearSelection() {
        selectionStart = -1;
        selectionEnd = -1;
        repaint();
    }
    
    public boolean hasSelection() {
        return selectionStart >= 0 && selectionEnd >= 0;
    }
    
    public String getSelectedText() {
        if (selectionStart < 0 || selectionEnd < 0) return "";
        int start = Math.min(selectionStart, selectionEnd);
        int end = Math.max(selectionStart, selectionEnd);
        int cols = model.getCols();
        StringBuilder sb = new StringBuilder();
        for (int i = start; i <= end; i++) {
            char c = model.getChar(i);
            sb.append(c == '\0' ? ' ' : c);
            if ((i + 1) % cols == 0 && i != end) sb.append('\n');
        }
        // Cleanup trailing spaces
        String raw = sb.toString();
        StringBuilder clean = new StringBuilder();
        for (String line : raw.split("\n")) {
            clean.append(line.replaceAll("\\s+$", "")).append("\n");
        }
        return clean.toString().trim();
    }

    public void setCursorStyle(CursorStyle style) {
        this.cursorStyle = style;
        repaint();
    }

    public void updateSize() {
        if (model == null || isUpdatingSize) return;
        isUpdatingSize = true;
        try {
            FontMetrics fm;
            Graphics g = getGraphics();
            Font fontToUse = (terminalFont != null) ? terminalFont : new Font(Font.MONOSPACED, Font.PLAIN, 14);
            if (g != null) { fm = g.getFontMetrics(fontToUse); g.dispose(); } 
            else { fm = this.getFontMetrics(fontToUse); }

            if (fm != null) {
                this.charWidth = fm.charWidth('M');
                this.charHeight = fm.getHeight();
                this.charAscent = fm.getAscent();
            } else {
                this.charWidth = 9; this.charHeight = 16; this.charAscent = 12;
            }

            int w = (model.getCols() * this.charWidth) + 24;
            int h = (model.getRows() * this.charHeight) + 24;
            setPreferredSize(new Dimension(w, h));

            Container parent = getParent();
            if (parent instanceof JViewport && parent.getParent() instanceof JScrollPane) {
                JScrollPane sp = (JScrollPane) parent.getParent();
                sp.getVerticalScrollBar().setUnitIncrement(this.charHeight);
                sp.getHorizontalScrollBar().setUnitIncrement(this.charWidth);
            }
            revalidate();
            repaint();
            
            Window win = SwingUtilities.getWindowAncestor(this);
            if (win != null && win.isDisplayable()) {
                if (win instanceof Frame && (((Frame)win).getExtendedState() & Frame.MAXIMIZED_BOTH) == 0) {
                    win.pack();
                }
            }
        } finally { isUpdatingSize = false; }
    }

    @Override public void setFont(Font f) {
        super.setFont(f);
        this.terminalFont = f;
        if (model != null) updateSize();
    }
    
    public Font getTerminalFont() { return terminalFont; }
    public int getCharWidth() { return charWidth; }
    public int getCharHeight() { return charHeight; }

    @Override protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (model == null) return;

        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        
        setBackground(model.getScreenBackground());
        g2.setFont(terminalFont);

        boolean blinkVisible = (System.currentTimeMillis() / 500) % 2 == 0;
        int cols = model.getCols();
        int rows = model.getRows();
        int marginLeft = Math.max(5, (getWidth() - (cols * this.charWidth)) / 2);
        int marginTop  = Math.max(5, (getHeight() - (rows * this.charHeight)) / 2);

        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int pos = row * cols + col;
                char c = model.getChar(pos);

                if (model.isNonDisplay(pos) && !model.isFieldStart(pos)) continue;
                if (model.getAttr(pos) != 0) c = ' '; else if (c == '\0') c = ' ';

                Color fg = model.getDefaultForeground();
                Color bg = model.getScreenBackground();
                boolean reverseVideo = false; boolean blink = false; boolean underscore = false;

                // Fix: Check local selection variables
                boolean isSelected = (selectionStart >= 0 && selectionEnd >= 0 && 
                                      pos >= Math.min(selectionStart, selectionEnd) && 
                                      pos <= Math.max(selectionStart, selectionEnd));

                byte highlight = model.getHighlight(pos);
                if (highlight == 0 && model.getAttr(pos) == 0) {
                    int fieldStart = model.findFieldStart(pos);
                    if (fieldStart >= 0) highlight = model.getHighlight(fieldStart);
                }
                if (model.getAttr(pos) == 0) {
                    if (highlight == (byte) 0xF2) reverseVideo = true;
                    else if (highlight == (byte) 0xF1) blink = true;
                    else if (highlight == (byte) 0xF4) underscore = true;
                }

                byte extCol = model.getExtendedColor(pos);
                Color[] palette = model.getPalette();
                if (extCol > 0 && extCol < palette.length) fg = palette[extCol];
                else {
                    int fieldStart = model.findFieldStart(pos);
                    if (fieldStart >= 0) {
                        byte fsCol = model.getExtendedColor(fieldStart);
                        if (fsCol > 0 && fsCol < palette.length) fg = palette[fsCol];
                        else {
                            byte attr = model.getAttr(fieldStart);
                            boolean isProt = (attr & 0x20) != 0;
                            boolean isInt = (attr & 0x08) != 0;
                            if ((attr & 0x0C) == 0x0C) fg = bg;
                            else if (isProt) fg = isInt ? Color.WHITE : Color.CYAN;
                            else fg = isInt ? Color.WHITE : Color.GREEN;
                        }
                    }
                }

                int x = marginLeft + (col * this.charWidth);
                int y = marginTop + (row * this.charHeight) + this.charAscent;
                int rectY = marginTop + (row * this.charHeight);

                if (isSelected) { Color temp = fg; fg = Color.WHITE; bg = new Color(0, 120, 215); }
                else if (reverseVideo) { Color temp = fg; fg = bg; bg = temp; }

                if (!bg.equals(model.getScreenBackground())) {
                    g2.setColor(bg);
                    g2.fillRect(x, rectY, this.charWidth, this.charHeight);
                }
                if (blink && !blinkVisible) continue;

                g2.setColor(fg);
                g2.drawString(String.valueOf(c), x, y);
                if (underscore) g2.drawLine(x, y + 2, x + this.charWidth, y + 2);
            }
        }

        int cPos = model.getCursorPos();
        int row = cPos / cols; int col = cPos % cols;
        int x = marginLeft + col * this.charWidth;
        int y = marginTop + row * this.charHeight;
        g2.setColor(model.getCursorColor());
        switch (cursorStyle) {
            case BLOCK: g2.fillRect(x, y, this.charWidth, this.charHeight); g2.setXORMode(model.getScreenBackground()); break;
            case UNDERSCORE: g2.fillRect(x, y + this.charHeight - 2, this.charWidth, 2); break;
            case I_BEAM: g2.fillRect(x, y, 2, this.charHeight); break;
        }
        g2.setPaintMode();
    }
}
