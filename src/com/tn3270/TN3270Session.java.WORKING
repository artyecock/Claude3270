package com.tn3270;

import com.tn3270.ai.AIManager;
import com.tn3270.model.ScreenModel;
import com.tn3270.ui.StatusBar;
import com.tn3270.ui.TerminalPanel;
import com.tn3270.ui.dialogs.KeyboardSettingsDialog;

import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.List;
import java.util.function.Consumer;
import javax.net.SocketFactory;
import javax.net.ssl.*;
import javax.swing.*;
import javax.swing.Timer;
import javax.swing.border.*;

// Static Imports for Constants and Tables
import static com.tn3270.constants.TelnetConstants.*;
import static com.tn3270.constants.ProtocolConstants.*;
import static com.tn3270.util.EBCDIC.*;

public class TN3270Session extends JPanel implements KeyListener {

    // =======================================================================
    // 1. CONSTANTS & CONFIG
    // =======================================================================
    
    // Terminal models (Configuration)
    private static final Map<String, Dimension> MODELS = new HashMap<>();
    static {
        MODELS.put("3278-2", new Dimension(80, 24));
        MODELS.put("3278-3", new Dimension(80, 32));
        MODELS.put("3278-4", new Dimension(80, 43));
        MODELS.put("3278-5", new Dimension(132, 27));
        MODELS.put("3279-2", new Dimension(80, 24)); 
        MODELS.put("3279-3", new Dimension(80, 32)); 
    }

    // Telnet State Machine
    private static final int STATE_DATA = 0;
    private static final int STATE_IAC = 1;
    private static final int STATE_SB = 2;
    private static final int STATE_WILL = 3;
    private static final int STATE_WONT = 4;
    private static final int STATE_DO = 5;
    private static final int STATE_DONT = 6;

    // File Transfer Enums
    private enum FileTransferState { IDLE, OPEN_SENT, TRANSFER_IN_PROGRESS, CLOSE_SENT, ERROR }
    private enum FileTransferDirection { UPLOAD, DOWNLOAD }
    private enum HostType { TSO, CMS }
    private enum ReplyMode { FIELD, EXTENDED_FIELD, CHARACTER }

    private HostType hostType = HostType.CMS;

    // Color Schemes
    private static final Map<String, ColorScheme> COLOR_SCHEMES = new HashMap<>();
    public static class ColorScheme {
        Color background; Color defaultFg; Color cursor; Color[] colors;
        ColorScheme(Color bg, Color defaultFg, Color cursor, Color[] colors) {
            this.background = bg; this.defaultFg = defaultFg; this.cursor = cursor; this.colors = colors;
        }
    }
    static {
        COLOR_SCHEMES.put("Green on Black (Classic)", new ColorScheme(Color.BLACK, Color.GREEN, Color.WHITE, new Color[] { Color.BLACK, Color.BLUE, Color.RED, Color.MAGENTA, Color.GREEN, Color.CYAN, Color.YELLOW, Color.WHITE }));
        COLOR_SCHEMES.put("White on Black", new ColorScheme(Color.BLACK, Color.WHITE, new Color(255, 255, 0), new Color[] { Color.BLACK, new Color(100, 149, 237), new Color(255, 99, 71), new Color(255, 105, 180), new Color(144, 238, 144), new Color(64, 224, 208), new Color(255, 255, 0), Color.WHITE }));
        COLOR_SCHEMES.put("Amber on Black", new ColorScheme(Color.BLACK, new Color(255, 176, 0), new Color(255, 200, 50), new Color[] { Color.BLACK, new Color(180, 130, 0), new Color(255, 100, 0), new Color(255, 140, 0), new Color(255, 176, 0), new Color(255, 200, 50), new Color(255, 220, 100), new Color(255, 230, 150) }));
        COLOR_SCHEMES.put("Green on Dark Green", new ColorScheme(new Color(0, 40, 0), new Color(51, 255, 51), new Color(102, 255, 102), new Color[] { new Color(0, 40, 0), new Color(0, 128, 128), new Color(0, 200, 0), new Color(102, 255, 102), new Color(51, 255, 51), new Color(153, 255, 153), new Color(204, 255, 204), new Color(230, 255, 230) }));
        COLOR_SCHEMES.put("IBM 3270 Blue", new ColorScheme(new Color(0, 0, 64), new Color(0, 255, 0), Color.WHITE, new Color[] { new Color(0, 0, 64), new Color(85, 170, 255), new Color(255, 85, 85), new Color(255, 85, 255), new Color(0, 255, 0), new Color(85, 255, 255), new Color(255, 255, 85), Color.WHITE }));
        COLOR_SCHEMES.put("Solarized Dark", new ColorScheme(new Color(0, 43, 54), new Color(131, 148, 150), new Color(147, 161, 161), new Color[] { new Color(0, 43, 54), new Color(38, 139, 210), new Color(220, 50, 47), new Color(211, 54, 130), new Color(133, 153, 0), new Color(42, 161, 152), new Color(181, 137, 0), new Color(238, 232, 213) }));
    }

    // =======================================================================
    // 2. INSTANCE VARIABLES
    // =======================================================================

    // MVC Components
    private ScreenModel screenModel;    // DATA
    public TerminalPanel terminalPanel; // VIEW
    private StatusBar statusBar;        // VIEW
    private Timer blinkTimer;
    private Frame parentFrame;

    // Connection
    private Socket socket;
    private InputStream input;
    private OutputStream output;
    private volatile boolean connected = false;
    private Thread readerThread;
    private boolean useTLS = false;
    private String requestedLuName = "";
    private String currentHost = "";
    private int currentPort = 23;
    private String modelName = "3279-3";

    // Input State
    public boolean insertMode = false;
    public boolean keyboardLocked = false;
    private byte lastAID = AID_ENTER;
    
    // TN3270E State
    private boolean tn3270eMode = false;
    private boolean tn3270eNegotiationComplete = false;
    private boolean tn3270eAttempted = false;
    private boolean tn3270eFailed = false;
    private int replyModeFlags = 0;
    private boolean queryReplySent = false;
    private ReplyMode currentReplyMode = ReplyMode.FIELD;

    // File Transfer State
    private FileTransferState ftState = FileTransferState.IDLE;
    private FileTransferDirection ftDirection = FileTransferDirection.DOWNLOAD;
    private int blockSequence = 0;
    private InputStream uploadStream;
    private OutputStream downloadStream;
    private File currentFile;
    private String currentFilename = null;
    private boolean ftIsText = true;
    private boolean ftIsMessage = false;
    private boolean ftHadSuccessfulTransfer = false;
    private boolean pendingCR = false;

    // UI Dialog Variables
    private JDialog progressDialog;
    private JProgressBar transferProgressBar;
    private JLabel progressLabel, transferStatusLabel;
    private JButton cancelTransferButton;

    // Visual Settings
    private boolean enableSound = true;
    private boolean autoAdvance = true;

    public enum CursorStyle {
        BLOCK("Solid Box"), UNDERSCORE("Underscore"), I_BEAM("Vertical Line");

        private final String label;
        CursorStyle(String label) { this.label = label; }
        @Override public String toString() { return label; }
    }
    
    private CursorStyle cursorStyle = CursorStyle.BLOCK;

    // Selection
    private int selectionStart = -1;
    private int selectionEnd = -1;
    private boolean selecting = false;
    private Point dragStart;

    // Key Mapping
    private Map<Integer, KeyMapping> keyMap = new HashMap<>();
    private Map<Character, Character> inputCharMap = new HashMap<>();
    private static final String KEYMAP_FILE = System.getProperty("user.home") + File.separator + ".tn3270keymap";

    public static class KeyMapping implements Serializable {
        private static final long serialVersionUID = 1L;
        public char character; public Byte aid; public String description;
        public KeyMapping(char c, String d) { this.character = c; this.description = d; }
        public KeyMapping(byte a, String d) { this.aid = a; this.description = d; }
    }

    // =======================================================================
    // 3. CONSTRUCTOR & INITIALIZATION
    // =======================================================================

    public TN3270Session(String modelName) {
        this(modelName, null);
    }

    public TN3270Session(String modelName, Frame parent) {
        super(new BorderLayout());
        this.parentFrame = parent;
        this.modelName = (modelName != null) ? modelName.trim() : "3278-2";

        // Initialize Model
        this.screenModel = new ScreenModel(this.modelName, MODELS);

        // Initialize View
        this.terminalPanel = new TerminalPanel(screenModel);
        
        JScrollPane scrollPane = new JScrollPane(terminalPanel);
        scrollPane.setBorder(null);
        scrollPane.getViewport().setBackground(Color.BLACK);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        
        add(scrollPane, BorderLayout.CENTER);

        // Initialize StatusBar
        this.statusBar = new StatusBar();
        add(statusBar, BorderLayout.SOUTH);

        // Setup Timers & Input
        blinkTimer = new Timer(500, e -> terminalPanel.repaint());
        blinkTimer.start();

        initializeKeyMappings();
        
        setFocusable(true);
        addKeyListener(this);
        terminalPanel.addKeyListener(this);
        
        addHierarchyListener(e -> {
            if ((e.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) != 0 && isDisplayable()) {
                SwingUtilities.invokeLater(terminalPanel::updateSize);
            }
        });
    }

    // --- Accessors ---
    public Frame getParentFrame() { 
        if (parentFrame != null) return parentFrame;
        Window w = SwingUtilities.getWindowAncestor(this);
        return (w instanceof Frame) ? (Frame) w : null;
    }

    public void setUseTLS(boolean t) { useTLS = t; }
    public void setRequestedLuName(String l) { requestedLuName = l; }
    public boolean isConnected() { return connected; }
    public Map<Integer, KeyMapping> getKeyMap() { return keyMap; }
    public Map<Character, Character> getInputCharMap() { return inputCharMap; }
    
    @Override public boolean requestFocusInWindow() {
        if (terminalPanel != null) return terminalPanel.requestFocusInWindow();
        return super.requestFocusInWindow();
    }

    private void initializeKeyMappings() {
        keyMap.put(KeyEvent.VK_BACK_QUOTE, new KeyMapping('¬', "Not"));
        inputCharMap.put('¦', '|');
        loadKeyMappings();
    }

    @SuppressWarnings("unchecked")
    public void loadKeyMappings() {
        if (!new File(KEYMAP_FILE).exists()) return;
        try (ObjectInputStream i = new ObjectInputStream(new FileInputStream(KEYMAP_FILE))) {
            Map<Integer, KeyMapping> m = (Map<Integer, KeyMapping>) i.readObject();
            keyMap.clear(); keyMap.putAll(m);
        } catch (Exception e) {}
    }

    public void saveKeyMappings() {
        try (ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(KEYMAP_FILE))) {
            o.writeObject(new HashMap<>(keyMap));
        } catch (Exception e) {}
    }

// =======================================================================
    // 4. NETWORKING
    // =======================================================================

    private SSLSocketFactory createTrustAllSSLSocketFactory() {
        try {
            TrustManager[] t = new TrustManager[] { new X509TrustManager() {
                public void checkClientTrusted(java.security.cert.X509Certificate[] c, String s) {}
                public void checkServerTrusted(java.security.cert.X509Certificate[] c, String s) {}
                public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }
            }};
            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, t, new java.security.SecureRandom());
            return sc.getSocketFactory();
        } catch (Exception e) {
            return (SSLSocketFactory) SSLSocketFactory.getDefault();
        }
    }

    public void connect(String h, int p) {
        this.currentHost = h;
        this.currentPort = p;
        new Thread(() -> {
            try {
                if (useTLS) {
                    SocketFactory f = createTrustAllSSLSocketFactory();
                    socket = f.createSocket(h, p);
                    if (socket instanceof SSLSocket) {
                        ((SSLSocket) socket).setEnabledProtocols(new String[] { "TLSv1.2", "TLSv1.3" });
                        ((SSLSocket) socket).startHandshake();
                    }
                    socket.setSoTimeout(0);
                    SwingUtilities.invokeLater(() -> statusBar.setStatus("TLS: " + h));
                } else {
                    socket = new Socket();
                    socket.connect(new InetSocketAddress(h, p), 5000);
                    socket.setSoTimeout(0);
                    SwingUtilities.invokeLater(() -> statusBar.setStatus("Conn: " + h));
                }
                
                if (socket.isConnected()) {
                    String ip = socket.getInetAddress().getHostAddress();
                    SwingUtilities.invokeLater(() -> statusBar.setIP(ip));
                }
                
                input = socket.getInputStream();
                output = socket.getOutputStream();
                connected = true;
                
                screenModel.clearScreen();
                
                readerThread = new Thread(this::readLoop);
                readerThread.start();
                
            } catch (Exception e) {
                try { if (socket != null) socket.close(); } catch (IOException x) {}
                connected = false;
                SwingUtilities.invokeLater(() -> {
                    statusBar.setStatus("Failed");
                    showMessageDialog("Connect Error: " + e.getMessage(), "Error", true);
                });
            }
        }).start();
    }

    public void disconnect() {
        connected = false;
        try { if (socket != null) socket.close(); } catch (Exception e) {}
        statusBar.setStatus("Disconnected");
        statusBar.setIP("");
        terminalPanel.repaint();
    }

    public void reconnect() {
        if (currentHost != null && !currentHost.isEmpty()) {
            disconnect();
            try { Thread.sleep(500); } catch (Exception e) {}
            connect(currentHost, currentPort);
        }
    }

    private void readLoop() {
        byte[] buf = new byte[8192];
        ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
        ByteArrayOutputStream subnegBuffer = new ByteArrayOutputStream();
        int ts = STATE_DATA; 

        try {
            while (connected) {
                int n = input.read(buf);
                if (n <= 0) break;
                for (int i = 0; i < n; i++) {
                    byte b = buf[i];
                    switch (ts) {
                        case STATE_DATA:
                            if (b == IAC) ts = STATE_IAC; else dataStream.write(b); break;
                        case STATE_IAC:
                            if (b == IAC) { dataStream.write((byte)0xFF); ts = STATE_DATA; }
                            else if (b == SB) { ts = STATE_SB; subnegBuffer.reset(); }
                            else if (b == WILL) ts = STATE_WILL;
                            else if (b == WONT) ts = STATE_WONT;
                            else if (b == DO) ts = STATE_DO;
                            else if (b == DONT) ts = STATE_DONT;
                            else if (b == (byte)0xEF) { // EOR
                                if(dataStream.size()>0) { process3270Data(dataStream.toByteArray()); dataStream.reset(); }
                                ts = STATE_DATA;
                            } else ts = STATE_DATA;
                            break;
                        case STATE_WILL: handleTelnet(WILL, b); ts = STATE_DATA; break;
                        case STATE_WONT: handleTelnet(WONT, b); ts = STATE_DATA; break;
                        case STATE_DO: handleTelnet(DO, b); ts = STATE_DATA; break;
                        case STATE_DONT: handleTelnet(DONT, b); ts = STATE_DATA; break;
                        case STATE_SB:
                            if (b == SE) {
                                byte[] sn = subnegBuffer.toByteArray();
                                if (sn.length>0 && sn[sn.length-1]==IAC) { handleSubneg(Arrays.copyOf(sn, sn.length-1)); ts=STATE_DATA; }
                                else subnegBuffer.write(b);
                            } else if (b == IAC) subnegBuffer.write(b); else subnegBuffer.write(b);
                            break;
                    }
                }
            }
        } catch (Exception e) { if(connected) statusBar.setStatus("Connection lost."); }
        disconnect();
    }

    private void handleTelnet(byte cmd, byte opt) throws IOException {
        if (cmd == DO && (opt == OPT_TERMINAL_TYPE || opt == OPT_BINARY || opt == OPT_EOR)) sendTelnet(WILL, opt);
        else if (cmd == DO && opt == OPT_TN3270E) {
            if (!tn3270eAttempted) { tn3270eAttempted = true; sendTelnet(WILL, opt); } 
            else sendTelnet(WONT, opt);
        } else if (cmd == WILL && opt == OPT_TN3270E) {
            if (!tn3270eAttempted) { tn3270eAttempted = true; sendTelnet(DO, opt); }
            else sendTelnet(DONT, opt);
        } else if (cmd == WILL) sendTelnet(DO, opt);
        else if (cmd == WONT) sendTelnet(DONT, opt);
        else if (cmd == DONT) sendTelnet(WONT, opt);
    }

private void handleSubnegNew(byte[] d) throws IOException {
        if (d.length < 2) return;
        
        // Option 24: TERMINAL-TYPE (Standard Telnet)
        if (d[0] == OPT_TERMINAL_TYPE && d[1] == 1) { // 1 = SEND
            ByteArrayOutputStream b = new ByteArrayOutputStream();
            b.write(IAC); b.write(SB); b.write(OPT_TERMINAL_TYPE); b.write(0); // 0 = IS
            
            // FIX: Only send "-E" if we are in TN3270E mode or attempting it.
            // For standard Telnet, send simple model string (e.g. "IBM-3279-3")
            // to ensure the host recognizes the model size immediately.
            String typeStr = "IBM-" + modelName;
            if (tn3270eMode) typeStr += "-E"; 
            
            b.write(typeStr.getBytes());
            b.write(IAC); b.write(SE);
            output.write(b.toByteArray()); output.flush();
        } 
        // Option 40: TN3270E
        else if (d[0] == OPT_TN3270E) {
            int op = d[1] & 0xFF;
            if (op == TN3270E_OP_SEND && d[2] == TN3270E_OP_DEVICE_TYPE) {
                ByteArrayOutputStream b = new ByteArrayOutputStream();
                b.write(IAC); b.write(SB); b.write(OPT_TN3270E);
                b.write(TN3270E_OP_DEVICE_TYPE); b.write(TN3270E_OP_REQUEST);
                
                // TN3270E always expects the extended string
                b.write(("IBM-" + modelName + "-E").getBytes());
                
                if (!requestedLuName.isEmpty()) {
                    b.write(TN3270E_OP_CONNECT); b.write(requestedLuName.getBytes());
                }
                b.write(IAC); b.write(SE);
                output.write(b.toByteArray()); output.flush();
            } else if (op == TN3270E_OP_DEVICE_TYPE && d[2] == TN3270E_OP_IS) {
                tn3270eMode = true;
                ByteArrayOutputStream b = new ByteArrayOutputStream();
                b.write(IAC); b.write(SB); b.write(OPT_TN3270E);
                b.write(TN3270E_OP_FUNCTIONS); b.write(TN3270E_OP_REQUEST);
                b.write(0x00); b.write(0x01); b.write(0x02); b.write(0x03);
                b.write(IAC); b.write(SE);
                output.write(b.toByteArray()); output.flush();
            } else if (op == TN3270E_OP_FUNCTIONS && d[2] == TN3270E_OP_IS) {
                sendQueryResponse();
            }
        }
    }

    private void handleSubneg(byte[] d) throws IOException {
        if (d.length < 2) return;
        if (d[0] == OPT_TERMINAL_TYPE && d[1] == 1) {
            ByteArrayOutputStream b = new ByteArrayOutputStream();
            b.write(IAC); b.write(SB); b.write(OPT_TERMINAL_TYPE); b.write(0);
            b.write(("IBM-" + modelName + "-E").getBytes());
            b.write(IAC); b.write(SE);
            output.write(b.toByteArray()); output.flush();
        } else if (d[0] == OPT_TN3270E) {
            int op = d[1] & 0xFF;
            if (op == TN3270E_OP_SEND && d[2] == TN3270E_OP_DEVICE_TYPE) {
                ByteArrayOutputStream b = new ByteArrayOutputStream();
                b.write(IAC); b.write(SB); b.write(OPT_TN3270E);
                b.write(TN3270E_OP_DEVICE_TYPE); b.write(TN3270E_OP_REQUEST);
                b.write(("IBM-" + modelName + "-E").getBytes());
                if (!requestedLuName.isEmpty()) {
                    b.write(TN3270E_OP_CONNECT); b.write(requestedLuName.getBytes());
                }
                b.write(IAC); b.write(SE);
                output.write(b.toByteArray()); output.flush();
            } else if (op == TN3270E_OP_DEVICE_TYPE && d[2] == TN3270E_OP_IS) {
                tn3270eMode = true;
                ByteArrayOutputStream b = new ByteArrayOutputStream();
                b.write(IAC); b.write(SB); b.write(OPT_TN3270E);
                b.write(TN3270E_OP_FUNCTIONS); b.write(TN3270E_OP_REQUEST);
                b.write(0x00); b.write(0x01); b.write(0x02); b.write(0x03);
                b.write(IAC); b.write(SE);
                output.write(b.toByteArray()); output.flush();
            } else if (op == TN3270E_OP_FUNCTIONS && d[2] == TN3270E_OP_IS)
                sendQueryResponse();
        }
    }

    private void sendTelnet(byte c, byte o) throws IOException {
        output.write(new byte[] { IAC, c, o });
        output.flush();
    }

// =======================================================================
    // 5. 3270 PROTOCOL (SCREEN MODEL INTEGRATION)
    // =======================================================================

    private void process3270Data(byte[] data) {
        if (data.length < 1) return;
        int off = 0;
        if (tn3270eMode && data.length >= 5 && data[0] == TN3270E_DT_3270_DATA) off = 5;
        if (off >= data.length) return;

        byte cmd = data[off++];
        
        if (cmd == CMD_ERASE_WRITE_05 || cmd == CMD_ERASE_WRITE_F5 || cmd == CMD_ERASE_WRITE_ALTERNATE_7E)
            screenModel.clearScreen();
        
        if (cmd == CMD_WRITE_01 || cmd == CMD_WRITE_F1 || cmd == CMD_ERASE_WRITE_05 || cmd == CMD_ERASE_WRITE_F5 || cmd == CMD_ERASE_WRITE_ALTERNATE_0D || cmd == CMD_ERASE_WRITE_ALTERNATE_7E) {
            
            if (cmd == CMD_ERASE_WRITE_ALTERNATE_0D || cmd == CMD_ERASE_WRITE_ALTERNATE_7E) {
                if (!screenModel.isAlternateSize()) {
                    screenModel.setUseAlternateSize(true);
                    terminalPanel.updateSize();
                }
            } else if (cmd == CMD_ERASE_WRITE_05 || cmd == CMD_ERASE_WRITE_F5) {
                if (screenModel.isAlternateSize()) {
                    screenModel.setUseAlternateSize(false);
                    terminalPanel.updateSize();
                }
            }

            if (off < data.length) {
                byte wcc = data[off++];
                if ((wcc & WCC_RESET) != 0) { keyboardLocked = false; replyModeFlags = 0; }
                if ((wcc & WCC_RESET_MDT) != 0) screenModel.resetMDT();
                if ((wcc & WCC_ALARM) != 0 && enableSound) Toolkit.getDefaultToolkit().beep();
                processOrders(data, off);
            }
            keyboardLocked = false;
        }
        else if (cmd == CMD_READ_MODIFIED_F6 || cmd == CMD_READ_MODIFIED_06) sendAID(lastAID);
        else if (cmd == CMD_READ_BUFFER_02 || cmd == CMD_READ_BUFFER_F2) sendReadBuffer();
        else if (cmd == CMD_WSF_11 || cmd == CMD_WSF_F3) processWSF(data, off);
        else if (cmd == CMD_ERASE_ALL_UNPROTECTED_0F || cmd == CMD_ERASE_ALL_UNPROTECTED_6F) eraseAllUnprotected();

        terminalPanel.repaint();
        updateStatusBar();
    }

    private void processOrders(byte[] data, int offset) {
        int p = 0, i = offset;
        int[] idx = { 0 };
        char c;
        int bufLen = screenModel.getSize();
        
        while (i < data.length) {
            byte b = data[i++];
            if (b == ORDER_SF) {
                if (i < data.length) {
                    screenModel.setAttr(p, data[i++]); 
                    screenModel.setChar(p, ' ');
                    screenModel.setExtendedColor(p, (byte)0); 
                    screenModel.setHighlight(p, (byte)0);
                    screenModel.setCurrentColor((byte)0);
                    screenModel.setCurrentHighlight((byte)0);
                    p = (p + 1) % bufLen;
                }
            } else if (b == ORDER_SFE) {
                if (i < data.length) {
                    int count = data[i++] & 0xFF;
                    byte a = 0, col = 0, hl = 0;
                    screenModel.setCurrentColor((byte)0);
                    screenModel.setCurrentHighlight((byte)0);
                    for (int k = 0; k < count; k++) {
                        if (i + 1 >= data.length) break;
                        byte t = data[i++], v = data[i++];
                        if (t == ATTR_FIELD || t == 0xC0) a = v;
                        else if (t == ATTR_FOREGROUND) col = v;
                        else if (t == ATTR_HIGHLIGHTING) hl = v;
                    }
                    screenModel.setChar(p, ' ');
                    screenModel.setAttr(p, a);
                    screenModel.setExtendedColor(p, col);
                    screenModel.setHighlight(p, hl);
                    p = (p + 1) % bufLen;
                }
            } else if (b == ORDER_SBA) {
                if (i + 1 < data.length) {
                    p = decode3270Address(data[i], data[i + 1]); i += 2;
                }
            } else if (b == ORDER_IC) {
                screenModel.setCursorPos(p);
                if (screenModel.isFieldStart(p)) screenModel.setCursorPos((p + 1) % bufLen);
            } else if (b == ORDER_RA) {
                if (i + 2 < data.length) {
                    int end = decode3270Address(data[i], data[i + 1]);
                    idx[0] = i + 2;
                    c = fetchDisplayChar(data, idx);
                    i = idx[0];
                    while (p != end) {
                        screenModel.setChar(p, c);
                        screenModel.setAttr(p, (byte)0); 
                        screenModel.setExtendedColor(p, screenModel.getCurrentColor());
                        screenModel.setHighlight(p, screenModel.getCurrentHighlight());
                        p = (p + 1) % bufLen;
                    }
                }
            } else if (b == ORDER_EUA) {
                if (i + 1 < data.length) {
                    int end = decode3270Address(data[i], data[i + 1]);
                    i += 2;
                    while (p != end) {
                        if (!screenModel.isProtected(p) && !screenModel.isFieldStart(p)) {
                            screenModel.setChar(p, '\0');
                            screenModel.setExtendedColor(p, (byte)0);
                            screenModel.setHighlight(p, (byte)0);
                        }
                        p = (p + 1) % bufLen;
                    }
                }
            } else if (b == ORDER_GE) {
                idx[0] = i - 1;
                c = fetchDisplayChar(data, idx);
                i = idx[0];
                screenModel.setChar(p, c);
                screenModel.setAttr(p, (byte)0);
                screenModel.setExtendedColor(p, screenModel.getCurrentColor());
                screenModel.setHighlight(p, screenModel.getCurrentHighlight());
                p = (p + 1) % bufLen;
            } else if (b == ORDER_PT) {
                int r = screenModel.getRows(), cl = screenModel.getCols();
                for (int k = 0; k < r * cl; k++) {
                    if (screenModel.isFieldStart(p) && !screenModel.isProtected(p)) { 
                        p = (p + 1) % bufLen; break; 
                    }
                    p = (p + 1) % bufLen;
                }
            } else if (b == ORDER_SA) {
                if (i + 1 < data.length) {
                    byte t = data[i++], v = data[i++];
                    if (t == ATTR_FOREGROUND) screenModel.setCurrentColor(v);
                    else if (t == ATTR_HIGHLIGHTING) screenModel.setCurrentHighlight(v);
                    else if (t == 0x00) { screenModel.setCurrentColor((byte)0); screenModel.setCurrentHighlight((byte)0); }
                }
            } else {
                c = EBCDIC_TO_ASCII[b & 0xFF];
                screenModel.setChar(p, c);
                screenModel.setAttr(p, (byte)0);
                screenModel.setExtendedColor(p, screenModel.getCurrentColor());
                screenModel.setHighlight(p, screenModel.getCurrentHighlight());
                p = (p + 1) % bufLen;
            }
        }
    }

// =======================================================================
    // 6. PROTOCOL HELPERS & WSF
    // =======================================================================

    private void sendReadBuffer() {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            baos.write(lastAID); 
            int cPos = screenModel.getCursorPos();
            baos.write(encode3270Address(cPos)[0]);
            baos.write(encode3270Address(cPos)[1]);

            int size = screenModel.getSize();
            for (int i = 0; i < size; i++) {
                if (screenModel.isFieldStart(i)) {
                    baos.write(ORDER_SF);
                    baos.write(screenModel.getAttr(i));
                } else {
                    char c = screenModel.getChar(i);
                    if (c == '\0') {
                        baos.write(0x00);
                    } else if (c < 256 && ASCII_TO_EBCDIC[c] != 0) {
                        baos.write(ASCII_TO_EBCDIC[c]);
                    } else {
                        baos.write(0x40);
                    }
                }
            }
            sendData(baos.toByteArray());
            keyboardLocked = true;
            updateStatusBar();
        } catch (IOException e) { e.printStackTrace(); }
    }

    public void sendAID(byte aid) {
        lastAID = aid;
        int cPos = screenModel.getCursorPos();
        keyboardLocked = true;
        updateStatusBar();
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            baos.write(aid);
            baos.write(encode3270Address(cPos)[0]);
            baos.write(encode3270Address(cPos)[1]);

            if (aid == AID_CLEAR) resetReplyModeToDefault();

            if (aid == AID_ENTER || (aid >= AID_PF1 && aid <= AID_PF24) || aid == AID_PA1 || aid == AID_PA2 || aid == AID_PA3 || aid == AID_CLEAR) {
                if (aid == AID_ENTER || (aid >= AID_PF1 && aid <= AID_PF24)) {
                    int screenSize = screenModel.getSize();
                    for (int i = 0; i < screenSize; i++) {
                        if (screenModel.isFieldStart(i) && (screenModel.getAttr(i) & 0x01) != 0) {
                            int fieldStart = i;
                            int end = screenModel.findNextField(i);
                            int dataStart = fieldStart + 1;
                            while (dataStart < end && screenModel.getChar(dataStart) == '\0') dataStart++;
                            int dataEnd = end - 1;
                            while (dataEnd > fieldStart && (screenModel.getChar(dataEnd) == '\0' || screenModel.getChar(dataEnd) == ' ')) dataEnd--;

                            if (dataStart <= dataEnd) {
                                baos.write(ORDER_SBA);
                                byte[] addr = encode3270Address(dataStart);
                                baos.write(addr[0]); baos.write(addr[1]);
                                for (int j = dataStart; j <= dataEnd; j++) {
                                    if (!screenModel.isFieldStart(j)) {
                                        char c = screenModel.getChar(j);
                                        if (c != '\0') {
                                            if (c < 256 && ASCII_TO_EBCDIC[c] != 0) baos.write(ASCII_TO_EBCDIC[c]);
                                            else baos.write(0x40);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            sendData(baos.toByteArray());
        } catch (IOException e) { e.printStackTrace(); }
        terminalPanel.repaint();
    }

    private void eraseAllUnprotected() {
        int size = screenModel.getSize();
        for (int i = 0; i < size; i++) {
            if (screenModel.isFieldStart(i)) {
                screenModel.setAttr(i, (byte)(screenModel.getAttr(i) & ~0x01));
            } else if (!screenModel.isProtected(i)) {
                screenModel.setChar(i, '\0');
                screenModel.setExtendedColor(i, (byte)0);
                screenModel.setHighlight(i, (byte)0);
            }
        }
        keyboardLocked = false;
        terminalPanel.repaint();
        updateStatusBar();
    }

    private void processWSF(byte[] data, int offset) {
        int i = offset;
        while (i + 2 < data.length) {
            int length = ((data[i] & 0xFF) << 8) | (data[i + 1] & 0xFF);
            if (length < 3 || i + length > data.length) break;
            byte sfid = data[i + 2];
            if (sfid == 0x01) {
                if (i + 4 < data.length) sendQueryResponse();
            } else if (sfid == SFID_DATA_CHAIN) {
                handleDataChain(data, i, length);
            } else if (sfid == SF_ID_SET_REPLY_MODE) {
                handleSetReplyModeSF(data, i, length);
            }
            i += length;
        }
    }

    private void handleSetReplyModeSF(byte[] sfBuf, int offset, int len) {
        if (sfBuf == null || len <= 0 || offset < 0 || offset + len > sfBuf.length) return;
        int p = offset;
        int end = offset + len;
        int flags = 0;
        while (p + 1 < end) {
            int slen = sfBuf[p+1] & 0xFF;
            if (p + slen > end) break;
            for (int i = 0; i < Math.min(4, slen); i++) flags = (flags << 8) | (sfBuf[p + i] & 0xFF);
            p += slen;
        }
        this.replyModeFlags = flags;
        if ((flags & 0x02) != 0) currentReplyMode = ReplyMode.CHARACTER;
        else if ((flags & 0x01) != 0) currentReplyMode = ReplyMode.EXTENDED_FIELD;
        else currentReplyMode = ReplyMode.FIELD;
    }

    private void resetReplyModeToDefault() {
        currentReplyMode = ReplyMode.FIELD;
        replyModeFlags = 0;
    }

private void sendQueryResponse() {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();

            // FIX: Always report the ALTERNATE (Maximum) capability to the host.
            // This tells the host: "I am currently in 24x80, but I CAN do 32x80 if you ask."
            int reportRows = screenModel.getAlternateRows();
            int reportCols = screenModel.getAlternateCols();
            //int reportBufsize = reportRows * reportCols; // 2560

			System.out.println("Query Reply: reporting " + reportCols + "x" + reportRows);

			if (tn3270eMode) {
				// TN3270E Header: [DataType] [Request] [Response] [Seq] [Seq]
				// DataType 0x00 = 3270 Data
				baos.write(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00 });
			}

			baos.write(0x88); // WSF Structured Field Response AID

			// ===== QUERY REPLY (SUMMARY) =====
			baos.write(0x00); // Length MSB
			baos.write(0x18); // Length LSB (24 bytes)
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x80); // Summary
			baos.write((byte) 0x81); // Usable Area
			baos.write((byte) 0x84); // Device Characteristics (Alphanumeric Partitions)
			baos.write((byte) 0x85); // Character Sets
			baos.write((byte) 0x86); // Color
			baos.write((byte) 0x87); // Highlight
			baos.write((byte) 0x88); // Reply Modes
			baos.write((byte) 0x8C); // Format Presentation (Field Outlining)
			baos.write((byte) 0x8F); // OEM Auxiliary Device (optional)
			baos.write((byte) 0x95); // Distributed Data Management (DDM)
			baos.write((byte) 0x99); // Storage Pools (Auxiliary device (AUXDA))
			baos.write((byte) 0x9D); // Segment (optional) (Anomally Implementation)
			baos.write((byte) 0xA6); // Implicit Partition
			baos.write((byte) 0xA8); // Distributed Data Management (Transparency)
			baos.write((byte) 0xAB); // Product Defined (optional) (Cooperative Processing Requestor (CPR))
			baos.write((byte) 0xB0); // Begin/End of File (Segment)
			baos.write((byte) 0xB1); // Data Chaining (Procedure)
			baos.write((byte) 0xB2); // Destination/Origin (Line Type)
			baos.write((byte) 0xB3); // Object Control (Port)
			baos.write((byte) 0xB4); // Object Picture (Graphic Color)
			baos.write((byte) 0xB6); // Save/Restore Format (Graphic Symbol Sets)

			// ===== QUERY REPLY (USABLE AREA) =====
			// PCOMM: Data='0017 8181 01000050002000000100600001006016220A00'x
			// 0017 8181 01 0000 5000 2000 00 0A 02 E5 00 02 00 6F 09 0C 0A 00
			// 88 00 0e 81 80 80 81 84 85 86 87 88 95 a1 a6
			// 00 17 81 81 01 00 00 50 00 2b 01 00 0a 02 e5 00 02 00 6f 09 0c 0d 70
			// 00 08 81 84 00 0d 70 00
			// 00 1b 81 85 82 00 09 0c 00 00 00 00 07 00 10 00 02 b9 00 25 01 00 f1 03 c3 01
			// 36
			// 00 26 81 86 00 10 00 f4 f1 f1 f2 f2 f3 f3 f4 f4 f5 f5 f6 f6 f7
			// f7 f8 f8 f9 f9 fa fa fb fb fc fc fd fd fe fe ff ff ff ff
			// 00 0f 81 87 05 00 f0 f1 f1 f2 f2 f4 f4 f8 f8
			// 00 07 81 88 00 01 02
			// 00 0c 81 95 00 00 40 00 40 00 01 01
			// 00 12 81 a1 00 00 00 00 00 00 00 00 06 a7 f3 f2 f7 f0
			// 00 11 81 a6 00 00 0b 01 00 00 50 00 18 00 50 00 2b
			//
			// For 3279-3: 80x32
			// ll ll 81 81 01 00 00 00 00 00 01 00 D3 03 20 00 9E 02 58 07 0C 0780
			// 00 17 81 81 01 00 0050 0020 00 00 02 00 89 00 02 00 85 09 10 0A00
			// ===== QUERY REPLY (USABLE AREA) =====
			// 00 17 81 81 01 00 0050 002b 00 00 02 00 89 00 02 00 85 09 10 0a00
			baos.write(0x00); // Length MSB
			baos.write(0x17); // Length LSB (23 bytes)
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x81); // Usable Area QRID
			baos.write(0x01); // 12/14-bit addressing
			// baos.write(0x00); // Flags1
			baos.write(0x00); // Flags2
			baos.write((byte) ((reportCols >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportCols & 0xFF)); // 0x50 (80)
			baos.write((byte) ((reportRows >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportRows & 0xFF)); // 0x20 (32)
			baos.write(0x00); // Units
			baos.write(0x00); // Xr MSB
			baos.write(0x02); // Xr LSB
			baos.write(0x00); // Yr MSB
			baos.write((byte) 0x89); // Yr LSB
			baos.write(0x00); // AW MSB
			baos.write(0x02); // AW LSB
			baos.write(0x00); // AH MSB
			baos.write(0x85); // AH LSB
			// baos.write((byte)((reportBufsize >> 8) & 0xFF)); // 0x0A (2560>>8=10)
			// baos.write((byte)(reportBufsize & 0xFF)); // 0x00 (2560&0xFF=0)
			baos.write(0x09); // Xm MSB
			baos.write(0x10); // Xm LSB
			baos.write(0x0A); // Ym MSB (CHANGED from 0x0D)
			baos.write(0x00); // Ym LSB (CHANGED from 0x70)

			/*
			 * // Device characteristics baos.write((byte) 0x00); baos.write((byte) 0x1B);
			 * baos.write((byte) 0x81); baos.write((byte) 0x40); baos.write((byte) 0x00);
			 * baos.write((byte) 0x00); baos.write((byte) 0x00); baos.write((byte) 0x00);
			 * baos.write((byte) 0x00); baos.write((byte) 0x00); baos.write((byte) 0x00);
			 * baos.write((byte) 0x00); baos.write((byte) 0x00); baos.write((byte) 0x18);
			 * baos.write((byte) 0x00); baos.write((byte)(reportCols & 0xFF)); // Width MSB
			 * (0x50 = 80) baos.write((byte)((reportCols >> 8) & 0xFF)); // Width LSB (0x00)
			 * baos.write((byte) 0x2B); baos.write((byte) 0x00); baos.write((byte) 0x84);
			 * baos.write((byte) 0x07); baos.write((byte) 0x80); baos.write((byte) 0x81);
			 * baos.write((byte) 0x00); baos.write((byte) 0x02); baos.write((byte) 0x00);
			 * baos.write((byte) 0x00);
			 */
			// Alphanumeric partitions
			// Data='0008 8184 001E0004'x
			// ===== QUERY REPLY (DEVICE CHARACTERISTICS 0x84) =====
			// PCOMM: Data='0008 8184 001E0004'x
			baos.write(0x00);
			baos.write(0x08); // Length = 8 bytes
			baos.write(0x81); // Query Reply
			baos.write(0x84); // Device Characteristics QRID

			// baos.write(0x00); // Byte 4: Device type/features
			// baos.write(0x0D); // Byte 5: Model (0x0D = Model 4, 0x70 for others)
			// baos.write(0x70); // Byte 6: Extended features
			// baos.write(0x00); // Byte 7: Reserved
			baos.write(0x01);
			baos.write(0xE0);    // 2=0x02, 3=0x03, 4=0x0D, 5=0x05
			baos.write(0x00);
			baos.write(0x04);

			// Data='001B 8185 82001622000000000700000002B900250100F103C30136'x
			// 00 1b 81 85 82 00 09 0c 00 00 00 00 07 00 10 00 02 b9 00 25 01 00 f1 03 c3 01
			// 36
			// 00 13 81 85 B0 00 09 10 40 00 00 00 03 00 00 00 01 00 F1
			// ===== QUERY REPLY (CHARACTER SET) =====
			// PCOMM: Data='001B 8185 82 00 16 22 00 00 00 00 07 00 00 00 02 B9 00 25 01 00 F1 03 C3 01 36'x
			/*
			baos.write(0x00);
			baos.write(0x13);
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x85); // Character Sets
			baos.write((byte) 0xB0); // Flags: CGCSGID, Multiple LCIDs
			baos.write(0x00); // SDW
			baos.write(0x09); // SDH
			baos.write(0x10); // Form: 0x10 = 40 characters
			baos.write(0x40); // DL
			baos.write(0x00); // DL MSB
			baos.write(0x00); // DL LSB
			baos.write(0x00); // Descriptor length
			baos.write(0x03); // Number of char sets
			baos.write(0x00); // Reserved
			baos.write(0x00); // Reserved
			baos.write(0x00); // Reserved
			baos.write(0x01); // Reserved
			baos.write(0x00); // Reserved
			baos.write((byte) 0xF1); // APL character set
			*/
			/*
			baos.write(0x00);
			baos.write(0x1B);
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x85); // Character Sets
			baos.write((byte) 0x82); // Flags: CGCSGID, Multiple LCIDs
			baos.write(0x00); // SDW
			baos.write(0x16); // SDH
			baos.write(0x22); // Form: 0x10 = 40 characters
			baos.write(0x00); // DL
			baos.write(0x00); // DL MSB
			baos.write(0x00); // DL LSB
			baos.write(0x00); // Descriptor length
			baos.write(0x07); // Number of char sets
			baos.write(0x00); // Reserved
			baos.write(0x00); // Reserved
			baos.write(0x00); // Reserved
			baos.write(0x02); // Reserved
			baos.write(0xB9); // Reserved
			baos.write(0x00);
			baos.write(0x25);
			baos.write(0x01);
			baos.write(0x00);
			baos.write(0xF1);
			baos.write(0x03);
			baos.write(0xC3);
			baos.write(0x01);
			baos.write(0x36);
			*/
			
			// ===== QUERY REPLY (CHARACTER SET) =====
            // Matched to PCOMM dump: 00 1B 81 85 82 00 09 0C ... F1 ...
			/*
            baos.write(0x00); baos.write(0x1B); // Length 27
            baos.write(0x81); baos.write(0x85); // ID
            baos.write(0x82); // Flags (PCOMM uses 0x82, we were using 0xB0)
            baos.write(0x00); // SDW
            baos.write(0x09); // SDH
            baos.write(0x0C); // Form (PCOMM uses 0x0C)
            baos.write(0x00); // DL MSB
            baos.write(0x00); // DL LSB
            
            // Descriptor Data (Matches PCOMM exactly)
            baos.write(0x00); baos.write(0x00); 
            baos.write(0x07); 
            baos.write(0x00); baos.write(0x10); 
            baos.write(0x00); baos.write(0x02); 
            baos.write(0xB9); 
            baos.write(0x00); baos.write(0x25); 
            baos.write(0x01); 
            baos.write(0x00); 
            baos.write(0xF1); // APL/GE Set ID
            baos.write(0x03); 
            baos.write(0xC3); 
            baos.write(0x01); 
            baos.write(0x36);
            */

			// Data='0016 8186 000800F4F1F1F2F2F3F3F4F4F5F5F6F6F7F7'x
			// Data='0016 8186 001000F4F1F1F2F2F3F3F4F4F5F5F6F6F7F7'x
			// 00 26 81 86 00 10 00 f4 f1 f1 f2 f2 f3 f3 f4 f4 f5 f5 f6 f6 f7
			// f7 f8 f8 f9 f9 fa fa fb fb fc fc fd fd fe fe ff ff ff ff
			// ===== QUERY REPLY (COLOR) =====
			baos.write(0x00);
			baos.write(0x16); // 22 bytes
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x86); // Color
			baos.write(0x00); // Flags
			baos.write(0x08); // 8 colors
			baos.write(0x00); // Default color
			baos.write((byte) 0xF4); // Green
			baos.write((byte) 0xF1); // Blue
			baos.write((byte) 0xF1); // Blue
			baos.write((byte) 0xF2); // Red
			baos.write((byte) 0xF2); // Red
			baos.write((byte) 0xF3); // Pink
			baos.write((byte) 0xF3); // Pink
			baos.write((byte) 0xF4); // Green
			baos.write((byte) 0xF4); // Green
			baos.write((byte) 0xF5); // Turquoise
			baos.write((byte) 0xF5); // Turquoise
			baos.write((byte) 0xF6); // Yellow
			baos.write((byte) 0xF6); // Yellow
			baos.write((byte) 0xF7); // White
			baos.write((byte) 0xF7); // White
			/*
			 * baos.write((byte) 0xF8); // Black baos.write((byte) 0xF8); baos.write((byte)
			 * 0xF9); // Deep Blue baos.write((byte) 0xF9); baos.write((byte) 0xFA); //
			 * Orange baos.write((byte) 0xFA); baos.write((byte) 0xFB); // Purple
			 * baos.write((byte) 0xFB); baos.write((byte) 0xFC); // Pale Green
			 * baos.write((byte) 0xFC); baos.write((byte) 0xFD); // Pale Turquoise
			 * baos.write((byte) 0xFD); baos.write((byte) 0xFE); // Grey baos.write((byte)
			 * 0xFE); baos.write((byte) 0xFF); // White baos.write((byte) 0xFF);
			 * baos.write((byte) 0xFF); baos.write((byte) 0xFF);
			 */
			// Data='000D 8187 0400F0F1F1F2F2F4F4'x
			// 00 0f 81 87 05 00 f0 f1 f1 f2 f2 f4 f4 f8 f8
			// ===== QUERY REPLY (HIGHLIGHTING) =====
			baos.write(0x00);
			baos.write(0x0D); // 13 bytes
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x87); // Highlighting
			baos.write(0x04); // 4 pairs
			baos.write(0x00); // Default
			baos.write((byte) 0xF0); // Normal
			baos.write((byte) 0xF1); // Blink
			baos.write((byte) 0xF1); // ?
			baos.write((byte) 0xF2); // Reverse
			baos.write((byte) 0xF2); // ?
			baos.write((byte) 0xF4); // Underscore
			baos.write((byte) 0xF4); // ?

			// 00 07 81 88 00 01 02
			// ===== QUERY REPLY (REPLY MODES) =====
			baos.write(0x00);
			baos.write(0x07); // 7 bytes
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x88); // Reply Modes
			baos.write(0x00); // Field mode
			baos.write(0x01); // Extended field mode
			baos.write(0x02); // ?

			// ===== QUERY REPLY (FORMAT PRESENTATION 0x8C) =====
			baos.write(0x00);
			baos.write(0x07); // Length = 7 bytes
			baos.write(0x81); // Query Reply
			baos.write(0x8C); // Format Presentation QRID
			baos.write(0x00); // Reserved
			baos.write(0x00); // Supports Format Presentation (was 0x01)
			baos.write(0x00); // Reserved

			// 00 0c 81 95 00 00 40 00 40 00 01 01
			// ===== QUERY REPLY (DDM) =====
			// PCOMM: Data='000C 8195 0000 09C4 09C4 0101'x
			baos.write(0x00);
			baos.write(0x0C); // 12 bytes (your format)
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x95); // DDM
			baos.write(0x00); // Flags
			baos.write(0x00); // ?
			baos.write(0x09); // LIMIN
			baos.write(0xC4); // ?
			baos.write(0x09); // LIMOUT
			baos.write(0xC4); // ?
			baos.write(0x01); // ?
			baos.write(0x01); // ?

			// ===== QUERY REPLY (STORAGE POOLS 0x99) =====
			baos.write(0x00);
			baos.write(0x06); // Length = 6 bytes
			baos.write(0x81); // Query Reply
			baos.write(0x99); // Storage Pools QRID
			baos.write(0x00); // Reserved
			baos.write(0x00); // Reserved

			// Data='0011 81A6 00000B01000050001800500020'x
			// 00 11 81 A6 00 00 0B 01 00 0050 0018 0050 0020'
			// ===== IMPLICIT PARTITION ======
			baos.write(0x00);
			baos.write(0x11);
			baos.write((byte) 0x81);
			baos.write((byte) 0xA6);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x0B);
			baos.write(0x01);
			baos.write(0x00);
			baos.write((byte) ((reportCols >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportCols & 0xFF)); // 0x50
			baos.write(0x00);
			baos.write(0x18); // 24 rows
			baos.write((byte) ((reportCols >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportCols & 0xFF)); // 0x50
			baos.write((byte) ((reportRows >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportRows & 0xFF)); // 0x20 (32 rows alternate)

			// OEM Auxiliary Device
			// 001A 81 8F 00 00 CL8'tn3270' CL8'ClaudeAI' 04 01 00 AE
			baos.write(0x00);
			baos.write(0x1A);
			baos.write(0x81);
			baos.write(0x8F);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0xA3); // 1
			baos.write(0x95); // 2
			baos.write(0xF3); // 3
			baos.write(0xF2); // 4
			baos.write(0xF7); // 5
			baos.write(0xF0); // 6
			baos.write(0x40); // 7
			baos.write(0x40); // 8
			baos.write(0xC3); // 1
			baos.write(0x93); // 2
			baos.write(0x81); // 3
			baos.write(0xA4); // 4
			baos.write(0x84); // 5
			baos.write(0x85); // 6
			baos.write(0xC1); // 7
			baos.write(0xC9); // 8
			baos.write(0x04);
			baos.write(0x01);
			baos.write(0x00);
			baos.write(0xAE);

			// Anomally Implementation
			// 0019 81 9D 00 01 0E 00 0E 00 0F 00 00 CL12'Claude/AI'
			baos.write(0x00);
			baos.write(0x19);
			baos.write(0x81);
			baos.write(0x9D);
			baos.write(0x00); // Reserved, must be 0
			baos.write(0x01); // Anomaly reference number
			baos.write(0x0E); // Max inbound
			baos.write(0x00);
			baos.write(0x0E); // Max outbound
			baos.write(0x00);
			baos.write(0x0F); // Length of data
			baos.write(0x00);
			baos.write(0xAE);
			baos.write(0xC3); // 1
			baos.write(0x93); // 2
			baos.write(0x81); // 3
			baos.write(0xA4); // 4
			baos.write(0x84); // 5
			baos.write(0x85); // 6
			baos.write(0x61); // 7
			baos.write(0xC1); // 8
			baos.write(0xC9); // 9
			baos.write(0x40); // 10
			baos.write(0x40); // 11
			baos.write(0x40); // 12
			// baos.write(0x40); // 13
			// baos.write(0x40); // 14

			// Transparency
			// Data='0009 81A8 0200F0FFFF'x
			// ===== QUERY REPLY (DDM 0xA8) =====
			baos.write(0x00);
			baos.write(0x09); // Length = 6 bytes
			baos.write(0x81); // Query Reply
			baos.write(0xA8); // DDM QRID
			// baos.write(0x00); // Flags
			// baos.write(0x01); // DDM subset identifier
			baos.write(0x02);
			baos.write(0x00);
			baos.write(0xF0);
			baos.write(0xFF);
			baos.write(0xFF);

			// Cooperative Processing Requestor
			// 0011 81 AB 00 00 00 00 00 00 02 00 00 04 01 00 01
			baos.write(0x00);
			baos.write(0x11);
			baos.write(0x81);
			baos.write(0xAB);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x02);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x04);
			baos.write(0x01);
			baos.write(0x00);
			baos.write(0x01);
			/*
			 * // ===== QUERY REPLY (0xB0 - Begin/End of File) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB0); // Begin/End of File QRID
			 * 
			 * // ===== QUERY REPLY (0xB1 - Data Chaining) ===== baos.write(0x00);
			 * baos.write(0x06); // Length = 6 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB1); // Data Chaining QRID baos.write(0x00); // Maximum number
			 * of requests baos.write(0x00); // Reserved
			 * 
			 * // ===== QUERY REPLY (0xB2 - Destination/Origin) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB2); // Destination/Origin QRID
			 * 
			 * // ===== QUERY REPLY (0xB3 - Object Control) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB3); // Object Control QRID
			 * 
			 * // ===== QUERY REPLY (0xB4 - Object Picture) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB4); // Object Picture QRID
			 * 
			 * // ===== QUERY REPLY (0xB6 - Save/Restore Format) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB6); // Save/Restore Format QRID
			 */
			byte[] response = baos.toByteArray();

			// DEBUG OUTPUT
			System.out.println("=== COMPLETE QUERY RESPONSE ===");
			for (int i = 0; i < response.length; i++) {
				System.out.print(String.format("%02X", response[i]));
				if ((i + 1) % 16 == 0)
					System.out.println();
			}
			System.out.println();
			System.out.println("Total: " + response.length + " bytes");

			// output.write(response);
			// output.write(IAC);
			// output.write((byte) 0xEF);
			// output.flush();

			// here
			ByteArrayOutputStream escapedStream = new ByteArrayOutputStream();

			// 1. Write Header (If TN3270E mode, header is NOT escaped,
			// but it contains 0x00s so it's safe.
			// However, usually header is part of the payload logic.
			// Let's assume Header is already in 'response' or written before.)
			// Wait, your code writes Header to 'baos', so it IS in 'response'.
			// TN3270E Header (00 00 00 00 00) doesn't need escaping.

			// 2. Scan buffer for 0xFF and double it
			for (byte b : response) {
				escapedStream.write(b);
				if (b == (byte) 0xFF) {
					escapedStream.write((byte) 0xFF); // Double IAC
				}
			}

			// 3. Append IAC EOR (EndOfRecord) to mark packet end
			escapedStream.write(IAC);
			escapedStream.write((byte) 0xEF);

			// 4. Send
			output.write(escapedStream.toByteArray());
			output.flush();

			System.out.println("Query response sent");

		} catch (IOException e) {
			e.printStackTrace();
		}
            /*
            System.out.println("Query Reply: Reporting capabilities as " + reportCols + "x" + reportRows);

            if (tn3270eMode) {
                baos.write(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00 });
            }

            baos.write(0x88); // WSF Structured Field Response AID

            // Summary
            baos.write(0x00); baos.write(0x18); baos.write(0x81); baos.write(0x80);
            baos.write(0x81); baos.write(0x84); baos.write(0x85); baos.write(0x86);
            baos.write(0x87); baos.write(0x88); baos.write(0x8C); baos.write(0x8F);
            baos.write(0x95); baos.write(0x99); baos.write(0x9D); baos.write(0xA6);
            baos.write(0xA8); baos.write(0xAB); baos.write(0xB0); baos.write(0xB1);
            baos.write(0xB2); baos.write(0xB3); baos.write(0xB4); baos.write(0xB6);

            // Usable Area
            baos.write(0x00); baos.write(0x17); baos.write(0x81); baos.write(0x81);
            baos.write(0x01); baos.write(0x00);
            baos.write((byte) ((reportCols >> 8) & 0xFF));
            baos.write((byte) (reportCols & 0xFF));
            baos.write((byte) ((reportRows >> 8) & 0xFF));
            baos.write((byte) (reportRows & 0xFF));
            baos.write(0x00); baos.write(0x00); baos.write(0x02);
            baos.write(0x00); baos.write(0x89);
            baos.write(0x00); baos.write(0x02);
            baos.write(0x00); baos.write(0x85);
            baos.write(0x09); baos.write(0x10); baos.write(0x0A); baos.write(0x00);

            // Device Characteristics
            baos.write(0x00); baos.write(0x08); baos.write(0x81); baos.write(0x84);
            baos.write(0x01); baos.write(0xE0); baos.write(0x00); baos.write(0x04);

            // Color
            baos.write(0x00); baos.write(0x16); baos.write(0x81); baos.write(0x86);
            baos.write(0x00); baos.write(0x08); baos.write(0x00);
            baos.write(0xF4); baos.write(0xF1); baos.write(0xF1); baos.write(0xF2);
            baos.write(0xF2); baos.write(0xF3); baos.write(0xF3); baos.write(0xF4);
            baos.write(0xF4); baos.write(0xF5); baos.write(0xF5); baos.write(0xF6);
            baos.write(0xF6); baos.write(0xF7); baos.write(0xF7);

            // Highlight
            baos.write(0x00); baos.write(0x0D); baos.write(0x81); baos.write(0x87);
            baos.write(0x04); baos.write(0x00);
            baos.write(0xF0); baos.write(0xF1); baos.write(0xF1); baos.write(0xF2);
            baos.write(0xF2); baos.write(0xF4); baos.write(0xF4);

            // Reply Modes
            baos.write(0x00); baos.write(0x07); baos.write(0x81); baos.write(0x88);
            baos.write(0x00); baos.write(0x01); baos.write(0x02);

            // Format Presentation
            baos.write(0x00); baos.write(0x07); baos.write(0x81); baos.write(0x8C);
            baos.write(0x00); baos.write(0x00); baos.write(0x00);

            // DDM
            baos.write(0x00); baos.write(0x0C); baos.write(0x81); baos.write(0x95);
            baos.write(0x00); baos.write(0x00); baos.write(0x09); baos.write(0xC4);
            baos.write(0x09); baos.write(0xC4); baos.write(0x01); baos.write(0x01);

            // Storage Pools
            baos.write(0x00); baos.write(0x06); baos.write(0x81); baos.write(0x99);
            baos.write(0x00); baos.write(0x00);

            // Implicit Partition
            baos.write(0x00); baos.write(0x11); baos.write(0x81); baos.write(0xA6);
            baos.write(0x00); baos.write(0x00); baos.write(0x0B); baos.write(0x01);
            baos.write(0x00);
            baos.write((byte) ((reportCols >> 8) & 0xFF));
            baos.write((byte) (reportCols & 0xFF));
            baos.write(0x00);
            baos.write(0x18); // 24 rows (Primary)
            baos.write((byte) ((reportCols >> 8) & 0xFF));
            baos.write((byte) (reportCols & 0xFF));
            baos.write((byte) ((reportRows >> 8) & 0xFF)); // Alternate Rows
            baos.write((byte) (reportRows & 0xFF));

            // OEM
            baos.write(0x00); baos.write(0x1A); baos.write(0x81); baos.write(0x8F);
            baos.write(0x00); baos.write(0x00);
            baos.write(0xA3); baos.write(0x95); baos.write(0xF3); baos.write(0xF2);
            baos.write(0xF7); baos.write(0xF0); baos.write(0x40); baos.write(0x40);
            baos.write(0xC3); baos.write(0x93); baos.write(0x81); baos.write(0xA4);
            baos.write(0x84); baos.write(0x85); baos.write(0xC1); baos.write(0xC9);
            baos.write(0x04); baos.write(0x01); baos.write(0x00); baos.write(0xAE);

            // Anomally
            baos.write(0x00); baos.write(0x19); baos.write(0x81); baos.write(0x9D);
            baos.write(0x00); baos.write(0x01); baos.write(0x0E); baos.write(0x00);
            baos.write(0x0E); baos.write(0x00); baos.write(0x0F); baos.write(0x00);
            baos.write(0xAE); baos.write(0xC3); baos.write(0x93); baos.write(0x81);
            baos.write(0xA4); baos.write(0x84); baos.write(0x85); baos.write(0x61);
            baos.write(0xC1); baos.write(0xC9); baos.write(0x40); baos.write(0x40);
            baos.write(0x40);

            // DDM Transparency
            baos.write(0x00); baos.write(0x09); baos.write(0x81); baos.write(0xA8);
            baos.write(0x02); baos.write(0x00); baos.write(0xF0); baos.write(0xFF);
            baos.write(0xFF);

            // CPR
            baos.write(0x00); baos.write(0x11); baos.write(0x81); baos.write(0xAB);
            baos.write(0x00); baos.write(0x00); baos.write(0x00); baos.write(0x00);
            baos.write(0x00); baos.write(0x00); baos.write(0x02); baos.write(0x00);
            baos.write(0x00); baos.write(0x04); baos.write(0x01); baos.write(0x00);
            baos.write(0x01);

            sendStructuredFieldResponse(baos.toByteArray());

        } catch (IOException e) {
            e.printStackTrace();
        }
        */
    }

    private void sendStructuredFieldResponse(byte[] sfData) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(AID_STRUCTURED_FIELD);
        baos.write(sfData);
        sendData(baos.toByteArray());
    }

    private void sendData(byte[] data) throws IOException {
        ByteArrayOutputStream fullPacket = new ByteArrayOutputStream();
        if (tn3270eMode) {
            fullPacket.write(TN3270E_DT_3270_DATA);
            fullPacket.write(0); fullPacket.write(0); fullPacket.write(0); fullPacket.write(0);
        }
        for (byte b : data) {
            fullPacket.write(b);
            if (b == (byte) 0xFF) fullPacket.write((byte) 0xFF);
        }
        fullPacket.write(IAC);
        fullPacket.write((byte) 0xEF);
        output.write(fullPacket.toByteArray());
        output.flush();
    }
    
    // --- Data Helpers ---
    private int decode3270Address(byte b1, byte b2) {
        int i = ((b1 & 0xFF) << 8) | (b2 & 0xFF);
        if ((b1 & 0xC0) != 0) i = ((b1 & 0x3F) << 6) | (b2 & 0x3F);
        return i % screenModel.getSize();
    }

    private byte[] encode3270Address(int a) {
        a &= 0x3FFF;
        if (a >= 0x1000) return new byte[] { (byte) (a >> 8), (byte) a };
        return new byte[] { ADDRESS_TABLE[(a >> 6) & 0x3F], ADDRESS_TABLE[a & 0x3F] };
    }

    private char fetchDisplayChar(byte[] data, int[] idxRef) {
        int i = idxRef[0];
        if (!safeConsume(data, i, 1)) return ' ';
        byte b = data[i];
        if (b == ORDER_GE) {
            if (!safeConsume(data, i + 1, 1)) { idxRef[0] = i + 1; return ' '; }
            byte op = data[i + 1];
            idxRef[0] = i + 2;
            return EBCDIC_TO_APL[op & 0xFF];
        } else {
            idxRef[0] = i + 1;
            return EBCDIC_TO_ASCII[b & 0xFF];
        }
    }

    private boolean safeConsume(byte[] d, int i, int n) {
        return i + n <= d.length;
    }

    // =======================================================================
    // 7. FILE TRANSFER (IND$FILE)
    // =======================================================================

    private void handleDataChain(byte[] data, int offset, int length) {
        if (offset + 3 >= data.length) return;
        byte op = data[offset + 3];
        switch (op) {
        case DC_OPEN: handleDCOpen(data, offset, length); break;
        case DC_CLOSE: handleDCClose(data, offset, length); break;
        case DC_SET_CURSOR: handleDCSetCursor(data, offset, length); break;
        case DC_GET: handleDCGet(data, offset, length); break;
        case DC_INSERT: handleDCInsert(data, offset, length); break;
        }
    }

    private void handleDCOpen(byte[] data, int offset, int length) {
        String filename = "";
        for (int i = offset; i < offset + length - 3; i++) {
            if (data[i] == 0x46 && data[i + 1] == 0x54 && data[i + 2] == 0x3A) {
                StringBuilder sb = new StringBuilder();
                for (int j = i; j < offset + length; j++) {
                    byte b = data[j];
                    if (b == 0x00 || b == (byte) 0xFF) break;
                    sb.append((char) (b & 0xFF));
                }
                filename = sb.toString().trim();
                break;
            }
        }
        currentFilename = filename;

        if (filename != null && filename.contains("FT:MSG")) {
            ftIsMessage = true;
            blockSequence = 0;
            sendDCOpenResponse(true, 0);
            return;
        }

        ftIsMessage = false;
        boolean hostWillGet = (offset + 14 < data.length) && (data[offset + 14] == 0x01);

        try {
            if (currentFile == null) {
                closeProgressDialog();
                showMessageDialog("No file specified", "Transfer Error", true);
                sendDCOpenResponse(false, 0x1B00);
                return;
            }
            if (hostWillGet) { // Upload
                if (!currentFile.exists()) {
                    closeProgressDialog();
                    showMessageDialog("File not found", "Error", true);
                    sendDCOpenResponse(false, 0x1B00);
                    return;
                }
                uploadStream = new BufferedInputStream(new FileInputStream(currentFile));
                pendingCR = false;
                updateProgressDialog("Sending data...", currentFile.length() + " bytes");
            } else { // Download
                downloadStream = new FileOutputStream(currentFile);
                updateProgressDialog("Receiving data...", "Block 0");
            }
            ftState = FileTransferState.TRANSFER_IN_PROGRESS;
            blockSequence = 0;
            sendDCOpenResponse(true, 0);
        } catch (IOException e) {
            closeProgressDialog();
            showMessageDialog("File error: " + e.getMessage(), "Error", true);
            sendDCOpenResponse(false, 0x2000);
        }
    }

    private void handleDCClose(byte[] data, int offset, int length) {
        try {
            if (downloadStream != null) { downloadStream.close(); downloadStream = null; }
            if (uploadStream != null) { uploadStream.close(); uploadStream = null; }
        } catch (IOException e) {
            closeProgressDialog();
            sendDCCloseResponse(false, 0x7100);
            return;
        }
        ftIsMessage = false;
        blockSequence = 0;
        sendDCCloseResponse(true, 0);
    }

    private void handleDCSetCursor(byte[] data, int offset, int length) {
        int payloadOffset = offset + 4;
        if (payloadOffset < data.length && data[payloadOffset] == ORDER_SBA) {
            if (payloadOffset + 2 < data.length) {
                int newPos = decode3270Address(data[payloadOffset + 1], data[payloadOffset + 2]);
                if (newPos >= 0 && newPos < screenModel.getSize()) {
                    screenModel.setCursorPos(newPos);
                    terminalPanel.repaint();
                    updateStatusBar();
                }
            }
        }
    }

    private void handleDCGet(byte[] data, int offset, int length) {
        if (uploadStream == null) { sendDCGetResponse(false, 0x2200, null, 0); return; }
        try {
            ByteArrayOutputStream blockBuffer = new ByteArrayOutputStream(2048);
            ByteArrayOutputStream lineBuffer = new ByteArrayOutputStream();
            int ch; boolean eof = false;

            while (blockBuffer.size() < 1900) {
                lineBuffer.reset();
                if (uploadStream.markSupported()) uploadStream.mark(4096);
                while ((ch = uploadStream.read()) != -1) {
                    if (ch == '\n') break;
                    else if (ch == '\r') {
                        if (uploadStream.markSupported()) {
                            uploadStream.mark(1);
                            if (uploadStream.read() != '\n') uploadStream.reset();
                        }
                        break;
                    } else lineBuffer.write(ch);
                }
                if (ch == -1 && lineBuffer.size() == 0) { eof = true; break; }
                if (ftIsText) { lineBuffer.write(0x0D); lineBuffer.write(0x0A); }
                if (blockBuffer.size() + lineBuffer.size() > 2000) {
                    if (uploadStream.markSupported()) uploadStream.reset();
                    break;
                } else blockBuffer.write(lineBuffer.toByteArray());
                if (ch == -1) { eof = true; break; }
            }
            byte[] dataToSend = blockBuffer.toByteArray();
            if (dataToSend.length > 0) {
                blockSequence++;
                sendDCGetResponse(true, 0, dataToSend, dataToSend.length);
                updateProgressDialog("Uploading block " + blockSequence, dataToSend.length + " bytes");
            } else if (eof) {
                uploadStream.close(); uploadStream = null;
                sendDCGetResponse(false, 0x2200, null, 0);
            }
        } catch (IOException e) {
            sendDCGetResponse(false, 0x2000, null, 0);
            closeProgressDialog();
            showMessageDialog("Upload error", "Error", true);
        }
    }

    private void handleDCInsert(byte[] data, int offset, int length) {
        if (ftIsMessage) {
            if (blockSequence > 0) { blockSequence++; sendDCInsertResponse(true, 0); return; }
            int markerOffset = offset + 7;
            if (markerOffset + 2 >= data.length || data[markerOffset] != 0x61) { sendDCInsertResponse(true, 0); return; }
            int dataLen = ((data[markerOffset + 1] & 0xFF) << 8) | (data[markerOffset + 2] & 0xFF) - 5;
            if (dataLen > 0 && markerOffset + 3 + dataLen <= data.length) {
                String message = new String(data, markerOffset + 3, dataLen);
                blockSequence++;
                sendDCInsertResponse(true, 0);
                closeProgressDialog();
                boolean isError = message.contains("Error") || message.contains("TRANS13");
                showMessageDialog(message, isError ? "Transfer Error" : "Transfer Status", isError);
                ftState = FileTransferState.IDLE;
            }
            return;
        }
        if (downloadStream == null) { sendDCInsertResponse(false, 0x4700); return; }
        int markerOffset = offset + 7;
        if (markerOffset >= offset + length || data[markerOffset] != 0x61) return; 

        try {
            int dataLen = ((data[markerOffset + 1] & 0xFF) << 8) | (data[markerOffset + 2] & 0xFF) - 5;
            if (dataLen > 0) {
                byte[] fileData = new byte[dataLen];
                System.arraycopy(data, markerOffset + 3, fileData, 0, dataLen);
                if (ftIsText) {
                    ByteArrayOutputStream clean = new ByteArrayOutputStream();
                    for (int i = 0; i < dataLen; i++) {
                        byte b = fileData[i];
                        if (pendingCR) { pendingCR = false; if (b == 0x0A) continue; }
                        if (b == 0x0D) { if (i == dataLen - 1) pendingCR = true; clean.write('\n'); }
                        else if (b == 0x0A) clean.write('\n');
                        else if (b != 0x1A) clean.write(b);
                    }
                    downloadStream.write(clean.toByteArray());
                } else downloadStream.write(fileData);
                blockSequence++;
                sendDCInsertResponse(true, 0);
                updateProgressDialog("Downloading block " + blockSequence, dataLen + " bytes");
            } else sendDCInsertResponse(true, 0);
        } catch (IOException e) {
            closeProgressDialog();
            sendDCInsertResponse(false, 0x4700);
        }
    }

public void showFileTransferDialog(boolean isDownload) {
        if (!connected) {
            JOptionPane.showMessageDialog(getParentFrame(), "Not connected to host.", "Connection Required", JOptionPane.WARNING_MESSAGE);
            return;
        }
        JDialog dialog = new JDialog(getParentFrame(), isDownload ? "Download from Host" : "Upload to Host", true);
        dialog.setLayout(new BorderLayout());
        JPanel mainPanel = new JPanel(new GridBagLayout());
        mainPanel.setBorder(new EmptyBorder(15, 15, 15, 15));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5); gbc.fill = GridBagConstraints.HORIZONTAL; gbc.anchor = GridBagConstraints.WEST;

        gbc.gridx = 0; gbc.gridy = 0;
        mainPanel.add(new JLabel("Host System:"), gbc);
        gbc.gridx = 1; gbc.gridwidth = 2;
        JComboBox<String> hostTypeBox = new JComboBox<>(new String[] { "TSO (z/OS)", "CMS (z/VM)" });
        hostTypeBox.setSelectedIndex(hostType == HostType.TSO ? 0 : 1);
        mainPanel.add(hostTypeBox, gbc);

        gbc.gridx = 0; gbc.gridy = 1; gbc.gridwidth = 1;
        mainPanel.add(new JLabel("Local File:"), gbc);
        gbc.gridx = 1;
        JTextField localFileField = new JTextField(30);
        mainPanel.add(localFileField, gbc);
        gbc.gridx = 2;
        JButton browseBtn = new JButton("Browse...");
        mainPanel.add(browseBtn, gbc);

        gbc.gridx = 0; gbc.gridy = 2;
        JLabel datasetLabel = new JLabel("Host Dataset:");
        mainPanel.add(datasetLabel, gbc);
        gbc.gridx = 1; gbc.gridwidth = 2;
        JTextField hostDatasetField = new JTextField(30);
        hostDatasetField.setText(hostType == HostType.TSO ? "USER.TEST.DATA" : "TEST DATA A");
        mainPanel.add(hostDatasetField, gbc);

        gbc.gridx = 0; gbc.gridy = 3; gbc.gridwidth = 1;
        mainPanel.add(new JLabel("Transfer Mode:"), gbc);
        gbc.gridx = 1; gbc.gridwidth = 2;
        JComboBox<String> modeBox = new JComboBox<>(new String[] { "ASCII (Text)", "BINARY" });
        mainPanel.add(modeBox, gbc);

        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 3;
        JPanel optionsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        JCheckBox crlfCheck = new JCheckBox("CRLF (Text Mode)", true);
        JCheckBox appendCheck = new JCheckBox("Append", false);
        optionsPanel.add(crlfCheck); optionsPanel.add(Box.createHorizontalStrut(15)); optionsPanel.add(appendCheck);
        mainPanel.add(optionsPanel, gbc);

        gbc.gridy = 5;
        JPanel allocPanel = new JPanel(new GridBagLayout());
        allocPanel.setBorder(BorderFactory.createTitledBorder("Host Allocation / Format Parameters"));
        GridBagConstraints agbc = new GridBagConstraints();
        agbc.insets = new Insets(2, 5, 2, 5); agbc.fill = GridBagConstraints.HORIZONTAL;
        agbc.gridx = 0; agbc.gridy = 0;
        allocPanel.add(new JLabel("RECFM:"), agbc);
        agbc.gridx = 1; 
        JComboBox<String> recfmBox = new JComboBox<>(new String[] { "V", "F", "U", "" });
        allocPanel.add(recfmBox, agbc);
        agbc.gridx = 2; 
        allocPanel.add(new JLabel("LRECL:"), agbc);
        agbc.gridx = 3; 
        JTextField lreclField = new JTextField("", 5);
        allocPanel.add(lreclField, agbc);
        agbc.gridx = 0; agbc.gridy = 1; 
        allocPanel.add(new JLabel("BLKSIZE:"), agbc);
        agbc.gridx = 1;
        JTextField blksizeField = new JTextField("", 6);
        allocPanel.add(blksizeField, agbc);
        agbc.gridx = 2; 
        JLabel spaceLabel = new JLabel("SPACE:");
        allocPanel.add(spaceLabel, agbc);
        agbc.gridx = 3; 
        JTextField spaceField = new JTextField("", 8);
        allocPanel.add(spaceField, agbc);
        mainPanel.add(allocPanel, gbc);

        dialog.add(mainPanel, BorderLayout.CENTER);
        JPanel btnPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton transferBtn = new JButton(isDownload ? "Download" : "Upload");
        JButton cancelBtn = new JButton("Cancel");
        btnPanel.add(cancelBtn); btnPanel.add(transferBtn);
        dialog.add(btnPanel, BorderLayout.SOUTH);

        hostTypeBox.addActionListener(e -> {
            boolean tso = (hostTypeBox.getSelectedIndex() == 0);
            datasetLabel.setText(tso ? "Host Dataset:" : "Host File:");
            spaceLabel.setVisible(tso); spaceField.setVisible(tso);
        });
        browseBtn.addActionListener(e -> {
            JFileChooser fc = new JFileChooser();
            if(isDownload ? fc.showSaveDialog(dialog)==JFileChooser.APPROVE_OPTION : fc.showOpenDialog(dialog)==JFileChooser.APPROVE_OPTION)
                localFileField.setText(fc.getSelectedFile().getAbsolutePath());
        });
        transferBtn.addActionListener(e -> {
            boolean ascii = (modeBox.getSelectedIndex() == 0);
            String lrecl = lreclField.getText().trim();
            if (!isDownload && lrecl.isEmpty() && !ascii) lrecl = "255";
            hostType = hostTypeBox.getSelectedIndex() == 0 ? HostType.TSO : HostType.CMS;
            String cmd = buildIndFileCommand(isDownload, hostType == HostType.TSO, hostDatasetField.getText().trim(), ascii, crlfCheck.isSelected(), appendCheck.isSelected(), (String)recfmBox.getSelectedItem(), lrecl, blksizeField.getText().trim(), spaceField.getText().trim());
            dialog.dispose();
            initiateFileTransfer(localFileField.getText().trim(), cmd, isDownload);
        });
        cancelBtn.addActionListener(e -> dialog.dispose());
        dialog.pack(); dialog.setLocationRelativeTo(getParentFrame()); dialog.setVisible(true);
    }

    public String buildIndFileCommand(boolean isDownload, boolean isTSO, String hostDataset, boolean isAscii,
            boolean useCrlf, boolean append, String recfm, String lrecl, String blksize, String space) {
        StringBuilder cmd = new StringBuilder();
        cmd.append("IND$FILE ");
        cmd.append(isDownload ? "GET " : "PUT ");
        cmd.append(hostDataset);
        if (!isTSO) {
            StringBuilder params = new StringBuilder();
            if (isAscii) params.append(" ASCII");
            if (useCrlf && isAscii) params.append(" CRLF");
            if (append) params.append(" APPEND");
            if (!isDownload && !recfm.isEmpty()) { params.append(" RECFM ").append(recfm); if (!lrecl.isEmpty()) params.append(" LRECL ").append(lrecl); }
            if (params.length() > 0) cmd.append(" (").append(params.toString().trim()).append(")");
        } else {
            if (isAscii) cmd.append(" ASCII");
            if (useCrlf && isAscii) cmd.append(" CRLF");
            if (append) cmd.append(" APPEND");
            if (!isDownload) {
                if (!recfm.isEmpty()) cmd.append(" RECFM(").append(recfm).append(")");
                if (!lrecl.isEmpty()) cmd.append(" LRECL(").append(lrecl).append(")");
                if (!blksize.isEmpty()) cmd.append(" BLKSIZE(").append(blksize).append(")");
                if (!space.isEmpty()) cmd.append(" SPACE(").append(space).append(")");
            } else {
                if (isAscii && !recfm.isEmpty()) cmd.append(" RECFM(").append(recfm).append(")");
            }
        }
        return cmd.toString();
    }

    public void initiateFileTransfer(String localFilePath, String command, boolean isDownload) {
        try {
            currentFile = new File(localFilePath);
            ftDirection = isDownload ? FileTransferDirection.DOWNLOAD : FileTransferDirection.UPLOAD;
            ftIsText = command.toUpperCase().contains("ASCII");
            ftIsMessage = false;
            
            showProgressDialog(isDownload ? "Downloading..." : "Uploading...");
            updateProgressDialog("Sending command...", currentFile.getName());
            
            int homePos = -1;
            int size = screenModel.getSize();
            for (int i = 0; i < size; i++) {
                if (screenModel.isFieldStart(i)) {
                    if ((screenModel.getAttr(i) & 0x20) == 0) { homePos = i + 1; break; }
                }
            }
            if (homePos != -1) screenModel.setCursorPos(homePos % size);
            else tabToNextField();
            
            eraseToEndOfField();
            int cPos = screenModel.getCursorPos();
            for (char c : command.toCharArray()) {
                if (!screenModel.isProtected(cPos)) {
                    screenModel.setChar(cPos, c);
                    screenModel.setModified(cPos);
                    cPos = (cPos + 1) % size;
                    screenModel.setCursorPos(cPos);
                }
            }
            terminalPanel.repaint();
            sendAID(AID_ENTER);
        } catch (Exception e) {
            statusBar.setStatus("Transfer Error: " + e.getMessage());
            closeProgressDialog();
        }
    }

    private void sendDCOpenResponse(boolean success, int errorCode) { sendResp(DC_OPEN, success, errorCode); }
    private void sendDCCloseResponse(boolean success, int errorCode) { sendResp(DC_CLOSE, success, errorCode); }
    private void sendDCInsertResponse(boolean success, int errorCode) { sendResp(DC_INSERT, success, errorCode); }

    private void sendDCGetResponse(boolean success, int errorCode, byte[] data, int dataLen) {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            if (success) {
                int totalLen = 2 + 1 + 1 + 1 + 1 + 1 + 4 + 1 + 1 + 1 + 2 + dataLen;
                baos.write((totalLen >> 8) & 0xFF); baos.write(totalLen & 0xFF);
                baos.write(SFID_DATA_CHAIN); baos.write(DC_GET); baos.write(0x05); baos.write(0x63); baos.write(0x06);
                baos.write((blockSequence >> 24) & 0xFF); baos.write((blockSequence >> 16) & 0xFF);
                baos.write((blockSequence >> 8) & 0xFF); baos.write(blockSequence & 0xFF);
                baos.write(0xC0); baos.write(0x80); baos.write(0x61);
                int dl = dataLen + 5;
                baos.write((dl >> 8) & 0xFF); baos.write(dl & 0xFF);
                baos.write(data, 0, dataLen);
            } else {
                baos.write(0x00); baos.write(0x09);
                baos.write(SFID_DATA_CHAIN); baos.write(DC_GET);
                baos.write(RESP_NEGATIVE); baos.write(0x69); baos.write(0x04);
                baos.write((errorCode >> 8) & 0xFF); baos.write(errorCode & 0xFF);
            }
            sendStructuredFieldResponse(baos.toByteArray());
        } catch (IOException e) {}
    }

    private void sendResp(byte op, boolean success, int errorCode) {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            if (success) {
                baos.write(0x00); baos.write(op == DC_INSERT ? 0x0B : 0x05);
                baos.write(SFID_DATA_CHAIN); baos.write(op); baos.write(RESP_POSITIVE);
                if (op == DC_INSERT) {
                    baos.write(0x05); baos.write(0x63); baos.write(0x06);
                    baos.write((blockSequence >> 24) & 0xFF); baos.write((blockSequence >> 16) & 0xFF);
                    baos.write((blockSequence >> 8) & 0xFF); baos.write(blockSequence & 0xFF);
                }
            } else {
                baos.write(0x00); baos.write(0x09);
                baos.write(SFID_DATA_CHAIN); baos.write(op);
                baos.write(RESP_NEGATIVE); baos.write(0x69); baos.write(0x04);
                baos.write((errorCode >> 8) & 0xFF); baos.write(errorCode & 0xFF);
            }
            sendStructuredFieldResponse(baos.toByteArray());
        } catch (IOException e) {}
    }

// =======================================================================
    // 7. INPUT HANDLING
    // =======================================================================

    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();
        if (keyCode == KeyEvent.VK_CONTROL || keyCode == KeyEvent.VK_META || 
            keyCode == KeyEvent.VK_ALT || keyCode == KeyEvent.VK_SHIFT) return;
        
        boolean isModifier = e.isControlDown() || e.isMetaDown();

        if (isModifier) {
            if (e.getKeyCode() == KeyEvent.VK_C) { copySelection(); return; }
            if (e.getKeyCode() == KeyEvent.VK_V) { pasteFromClipboard(); return; }
            if (e.getKeyCode() == KeyEvent.VK_A) { selectAll(); return; }
            if (e.getKeyCode() == KeyEvent.VK_EQUALS) { changeFontSize(2); return; }
            if (e.getKeyCode() == KeyEvent.VK_MINUS) { changeFontSize(-2); return; }
        }

        if (selectionStart >= 0) clearSelection();

        switch (keyCode) {
            case KeyEvent.VK_LEFT: moveCursor(-1); return;
            case KeyEvent.VK_RIGHT: moveCursor(1); return;
            case KeyEvent.VK_UP: moveCursor(-screenModel.getCols()); return;
            case KeyEvent.VK_DOWN: moveCursor(screenModel.getCols()); return;
            case KeyEvent.VK_HOME: screenModel.setCursorPos(0); terminalPanel.repaint(); updateStatusBar(); return;
        }

        if (keyboardLocked || !connected) {
            if (enableSound) Toolkit.getDefaultToolkit().beep();
            return;
        }

        KeyMapping mapping = keyMap.get(keyCode);
        if (mapping != null) {
            if (mapping.aid != null) {
                if ("EraseEOF".equals(mapping.description)) eraseToEndOfField();
                else sendAID(mapping.aid);
                return;
            }
        }

        if (keyCode >= KeyEvent.VK_F1 && keyCode <= KeyEvent.VK_F12) {
            byte aid;
            switch(keyCode) {
                case KeyEvent.VK_F1: aid = AID_PF1; break;
                case KeyEvent.VK_F2: aid = AID_PF2; break;
                // ... (Logic implies sequential mapping)
                default: aid = (byte)(AID_PF1 + (keyCode - KeyEvent.VK_F1));
            }
            sendAID(aid);
            return;
        }

        switch (keyCode) {
            case KeyEvent.VK_ESCAPE: screenModel.clearScreen(); sendAID(AID_CLEAR); return;
            case KeyEvent.VK_ENTER: 
                if (selectionStart >= 0) {
                    String txt = getSelectedText();
                    if (!txt.isEmpty()) { AIManager.getInstance().showChatDialog(getParentFrame(), txt); clearSelection(); return; }
                }
                sendAID(AID_ENTER); return;
            case KeyEvent.VK_INSERT: toggleInsertMode(); return;
            case KeyEvent.VK_TAB: if (e.isShiftDown()) tabToPreviousField(); else tabToNextField(); return;
            case KeyEvent.VK_BACK_SPACE:
                int cPos = screenModel.getCursorPos();
                if (!screenModel.isProtected(cPos)) {
                    moveCursor(-1);
                    cPos = screenModel.getCursorPos();
                    if (!screenModel.isProtected(cPos)) {
                        screenModel.setChar(cPos, ' ');
                        screenModel.setModified(cPos);
                        terminalPanel.repaint();
                    }
                }
                return;
        }
    }

    public void keyTyped(KeyEvent e) {
        if (keyboardLocked || !connected) return;
        char c = e.getKeyChar();
        KeyMapping mapping = keyMap.get(e.getKeyCode());
        if (mapping != null && mapping.aid == null) c = mapping.character;
        c = inputCharMap.getOrDefault(c, c);
        if (c < 32 || c > 126) return;

        int cPos = screenModel.getCursorPos();
        if (!screenModel.isProtected(cPos)) {
            if (insertMode) {
                int fieldStart = screenModel.findFieldStart(cPos);
                int end = screenModel.findNextField(fieldStart);
                int last = end - 1;
                if (screenModel.isFieldStart(last)) last--;
                char lc = screenModel.getChar(last);
                if (lc != '\0' && lc != ' ') { if (enableSound) Toolkit.getDefaultToolkit().beep(); return; }
                for (int i = last; i > cPos; i--) {
                    if (!screenModel.isFieldStart(i) && !screenModel.isFieldStart(i-1))
                        screenModel.setChar(i, screenModel.getChar(i-1));
                }
            }
            screenModel.setChar(cPos, c);
            screenModel.setModified(cPos);
            moveCursor(1);
            if (autoAdvance && screenModel.isFieldStart(screenModel.getCursorPos())) tabToNextField();
            terminalPanel.repaint();
        } else if (enableSound) Toolkit.getDefaultToolkit().beep();
    }

    public void keyReleased(KeyEvent e) {}

    // --- Helpers ---
    private void moveCursor(int delta) {
        int sz = screenModel.getSize();
        screenModel.setCursorPos((screenModel.getCursorPos() + delta + sz) % sz);
        terminalPanel.repaint(); updateStatusBar();
    }
    public void tabToNextField() {
        int start = screenModel.getCursorPos();
        int p = start; int sz = screenModel.getSize();
        do {
            p = (p + 1) % sz;
            if (screenModel.isFieldStart(p) && (screenModel.getAttr(p) & 0x20) == 0) {
                screenModel.setCursorPos((p + 1) % sz);
                terminalPanel.repaint(); updateStatusBar(); return;
            }
        } while (p != start);
        screenModel.setCursorPos(start); terminalPanel.repaint(); updateStatusBar();
    }
    public void tabToPreviousField() {
        int start = screenModel.getCursorPos();
        int p = start; int sz = screenModel.getSize();
        do {
            p = (p - 1 + sz) % sz;
            if (screenModel.isFieldStart(p) && (screenModel.getAttr(p) & 0x20) == 0) {
                screenModel.setCursorPos((p + 1) % sz);
                terminalPanel.repaint(); updateStatusBar(); return;
            }
        } while (p != start);
        screenModel.setCursorPos(start); terminalPanel.repaint(); updateStatusBar();
    }
    public void eraseToEndOfField() {
        int p = screenModel.getCursorPos();
        if (screenModel.isProtected(p)) return;
        int end = screenModel.findNextField(p);
        int sz = screenModel.getSize();
        for (int i = p; i != end && !screenModel.isFieldStart(i); i = (i+1)%sz) screenModel.setChar(i, '\0');
        screenModel.setModified(p); terminalPanel.repaint(); updateStatusBar();
    }

// =======================================================================
    // 8. CLIPBOARD & SELECTION
    // =======================================================================

    public void copySelection() {
        String txt = getSelectedText();
        if (txt.isEmpty()) return;
        try {
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(txt), null);
            statusBar.setStatus("Copied to clipboard");
            clearSelection();
        } catch (Exception e) {}
    }

    public void pasteFromClipboard() {
        try {
            String text = (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);
            if (text == null) return;
            for (char c : text.toCharArray()) {
                if (c == '\n') { tabToNextField(); continue; }
                if (c < 32) continue;
                int p = screenModel.getCursorPos();
                if (!screenModel.isProtected(p)) {
                    screenModel.setChar(p, c); screenModel.setModified(p);
                    moveCursor(1);
                } else tabToNextField();
            }
            terminalPanel.repaint();
        } catch (Exception e) {}
    }

    public void selectAll() {
        selectionStart = 0;
        selectionEnd = screenModel.getSize() - 1;
        terminalPanel.repaint();
    }

    public String getSelectedText() {
        if (selectionStart < 0) return "";
        int start = Math.min(selectionStart, selectionEnd);
        int end = Math.max(selectionStart, selectionEnd);
        int cols = screenModel.getCols();
        StringBuilder sb = new StringBuilder();
        for (int i = start; i <= end; i++) {
            char c = screenModel.getChar(i);
            sb.append(c == '\0' ? ' ' : c);
            if ((i + 1) % cols == 0 && i != end) sb.append('\n');
        }
        return sb.toString();
    }

    private void clearSelection() {
        selectionStart = -1; selectionEnd = -1;
        terminalPanel.repaint();
    }

// =======================================================================
    // 9. PROGRESS DIALOGS
    // =======================================================================

    private void showProgressDialog(String title) {
        if (progressDialog != null) progressDialog.dispose();
        progressDialog = new JDialog(getParentFrame(), title, false);
        progressDialog.setLayout(new BorderLayout());
        JPanel p = new JPanel(new GridLayout(0, 1));
        p.setBorder(new EmptyBorder(10, 10, 10, 10));
        progressLabel = new JLabel("Initializing...");
        transferProgressBar = new JProgressBar(); transferProgressBar.setIndeterminate(true);
        transferStatusLabel = new JLabel("");
        cancelTransferButton = new JButton("Cancel");
        cancelTransferButton.addActionListener(e -> {
            ftState = FileTransferState.IDLE;
            closeProgressDialog();
        });
        p.add(progressLabel); p.add(transferProgressBar); p.add(transferStatusLabel); p.add(cancelTransferButton);
        progressDialog.add(p);
        progressDialog.pack(); progressDialog.setLocationRelativeTo(getParentFrame()); progressDialog.setVisible(true);
    }

    private void updateProgressDialog(String msg, String status) {
        SwingUtilities.invokeLater(() -> {
            if (progressLabel != null) progressLabel.setText(msg);
            if (transferStatusLabel != null) transferStatusLabel.setText(status);
        });
    }

    private void closeProgressDialog() {
        SwingUtilities.invokeLater(() -> {
            if (progressDialog != null) progressDialog.dispose();
        });
    }
    
    private void showMessageDialog(String msg, String title, boolean isError) {
        JOptionPane.showMessageDialog(getParentFrame(), msg, title, isError ? JOptionPane.ERROR_MESSAGE : JOptionPane.INFORMATION_MESSAGE);
    }
    
    private void updateStatusBar() {
        if (statusBar != null) statusBar.updatePosition(screenModel.getRows(), screenModel.getCols(), screenModel.getCursorPos());
    }

    // --- AI Bridge ---
    public void showAIChatDialog(Frame owner, String text) {
        AIManager.getInstance().showChatDialog(owner, text);
    }
// =======================================================================
    // 11. VISUAL HELPERS & UI DIALOGS
    // =======================================================================

    private void changeFontSize(int delta) {
        if (terminalPanel == null) return;

        int currentSize = terminalPanel.getTerminalFont().getSize();
        int newSize = currentSize + delta;

        if (newSize < 6) newSize = 6;
        if (newSize > 72) newSize = 72;

        if (newSize != currentSize) {
            terminalPanel.setFont(new Font("Monospaced", Font.PLAIN, newSize));
            statusBar.setStatus("Font size set to " + newSize + "pt");
        }
    }

    public void applyColorScheme(String schemeName) {
        ColorScheme scheme = COLOR_SCHEMES.get(schemeName);
        if (scheme == null) return;

        screenModel.setScreenBackground(scheme.background);
        screenModel.setDefaultForeground(scheme.defaultFg);
        screenModel.setCursorColor(scheme.cursor);
        screenModel.setPalette(scheme.colors);

        terminalPanel.setBackground(scheme.background);
        terminalPanel.repaint();
        statusBar.setStatus("Color scheme: " + schemeName);
    }

    public void toggleInsertMode() {
        insertMode = !insertMode;
        if (insertMode) {
            terminalPanel.setCursorStyle(TerminalPanel.CursorStyle.UNDERSCORE);
            statusBar.setStatus("Insert Mode");
        } else {
            terminalPanel.setCursorStyle(TerminalPanel.CursorStyle.BLOCK);
            statusBar.setStatus("Overwrite Mode");
        }
        terminalPanel.repaint();
    }

    // --- UI Dialog Launchers ---

    public void showFontSizeDialog() {
        JDialog dialog = new JDialog(getParentFrame(), "Terminal Font Size", true);
        dialog.setLayout(new BorderLayout(10, 10));

        JPanel mainPanel = new JPanel(new BorderLayout(10, 10));
        mainPanel.setBorder(new EmptyBorder(15, 15, 15, 15));

        JPanel controls = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel lbl = new JLabel("Size (pt):");

        int currentSize = terminalPanel.getTerminalFont().getSize();
        JSpinner spinner = new JSpinner(new SpinnerNumberModel(currentSize, 6, 72, 1));
        JSlider slider = new JSlider(6, 48, currentSize);

        spinner.addChangeListener(e -> slider.setValue((Integer) spinner.getValue()));
        slider.addChangeListener(e -> spinner.setValue(slider.getValue()));

        controls.add(lbl);
        controls.add(spinner);
        controls.add(slider);

        JTextArea preview = new JTextArea("  Local VM  \n  READY...  ");
        preview.setFont(terminalPanel.getTerminalFont());
        preview.setBackground(screenModel.getScreenBackground());
        preview.setForeground(screenModel.getDefaultForeground());
        preview.setEditable(false);
        preview.setBorder(new LineBorder(Color.GRAY));

        slider.addChangeListener(e -> {
            int s = slider.getValue();
            preview.setFont(new Font("Monospaced", Font.PLAIN, s));
        });

        mainPanel.add(controls, BorderLayout.NORTH);
        mainPanel.add(new JScrollPane(preview), BorderLayout.CENTER);

        JPanel btnPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton ok = new JButton("Apply");
        JButton cancel = new JButton("Cancel");

        ok.addActionListener(e -> {
            int newSize = (Integer) spinner.getValue();
            int delta = newSize - terminalPanel.getTerminalFont().getSize();
            changeFontSize(delta);
            dialog.dispose();
        });
        cancel.addActionListener(e -> dialog.dispose());

        btnPanel.add(cancel);
        btnPanel.add(ok);

        dialog.add(mainPanel, BorderLayout.CENTER);
        dialog.add(btnPanel, BorderLayout.SOUTH);

        dialog.pack();
        dialog.setSize(400, 300);
        dialog.setLocationRelativeTo(getParentFrame());
        dialog.setVisible(true);
    }

    public void showColorSchemeDialog() {
        JDialog dialog = new JDialog(getParentFrame(), "Color Settings", true);
        dialog.setLayout(new BorderLayout());

        JPanel mainPanel = new JPanel(new GridBagLayout());
        mainPanel.setBorder(new EmptyBorder(20, 20, 20, 20));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);

        gbc.gridx = 0; gbc.gridy = 0; gbc.gridwidth = 2;
        mainPanel.add(new JLabel("Load Preset Scheme:"), gbc);

        gbc.gridy = 1;
        JComboBox<String> schemeBox = new JComboBox<>();
        schemeBox.addItem("Green on Black (Classic)");
        schemeBox.addItem("White on Black");
        schemeBox.addItem("Amber on Black");
        schemeBox.addItem("Green on Dark Green");
        schemeBox.addItem("IBM 3270 Blue");
        schemeBox.addItem("Solarized Dark");

        JButton applyPreset = new JButton("Apply");
        applyPreset.addActionListener(e -> {
            applyColorScheme((String) schemeBox.getSelectedItem());
            dialog.dispose();
        });

        JPanel presetPanel = new JPanel(new BorderLayout(5, 0));
        presetPanel.add(schemeBox, BorderLayout.CENTER);
        presetPanel.add(applyPreset, BorderLayout.EAST);
        mainPanel.add(presetPanel, gbc);

        gbc.gridy = 2;
        mainPanel.add(new JSeparator(), gbc);

        gbc.gridy = 3;
        mainPanel.add(new JLabel("Customize Current Colors:"), gbc);

        gbc.gridy = 4; gbc.gridwidth = 1;
        JButton btnBg = new JButton("Background...");
        btnBg.addActionListener(e -> {
            Color newC = JColorChooser.showDialog(dialog, "Screen Background", screenModel.getScreenBackground());
            if (newC != null) {
                screenModel.setScreenBackground(newC);
                terminalPanel.setBackground(newC);
                terminalPanel.repaint();
            }
        });
        mainPanel.add(btnBg, gbc);

        gbc.gridx = 1;
        JButton btnFg = new JButton("Default Text...");
        btnFg.addActionListener(e -> {
            Color newC = JColorChooser.showDialog(dialog, "Default Text", screenModel.getDefaultForeground());
            if (newC != null) {
                screenModel.setDefaultForeground(newC);
                terminalPanel.repaint();
            }
        });
        mainPanel.add(btnFg, gbc);

        gbc.gridx = 0; gbc.gridy = 5;
        JButton btnCur = new JButton("Cursor Color...");
        btnCur.addActionListener(e -> {
            Color newC = JColorChooser.showDialog(dialog, "Cursor Color", screenModel.getCursorColor());
            if (newC != null) {
                screenModel.setCursorColor(newC);
                terminalPanel.repaint();
            }
        });
        mainPanel.add(btnCur, gbc);

        dialog.add(mainPanel, BorderLayout.CENTER);
        dialog.pack();
        dialog.setLocationRelativeTo(getParentFrame());
        dialog.setVisible(true);
    }
    
    public void showKeyboardMappingDialog() {
        // Instantiate the external dialog class
        new com.tn3270.ui.dialogs.KeyboardSettingsDialog(getParentFrame(), this).setVisible(true);
    }

    public void showTerminalSettingsDialog() {
         JDialog dialog = new JDialog(getParentFrame(), "Terminal Settings", true);
        dialog.setLayout(new BorderLayout());
        JPanel p = new JPanel(new GridLayout(0, 2, 10, 10));
        p.setBorder(new EmptyBorder(10,10,10,10));
        
        p.add(new JLabel("Cursor Style:"));
        JComboBox<String> cursorBox = new JComboBox<>(new String[]{"Block", "Underscore", "I-Beam"});
        p.add(cursorBox);
        
        JCheckBox blink = new JCheckBox("Cursor Blink", true); 
        JCheckBox sound = new JCheckBox("Sound", enableSound);
        p.add(blink); p.add(sound);
        
        JButton ok = new JButton("OK");
        ok.addActionListener(e -> {
             String style = (String)cursorBox.getSelectedItem();
             if(style.equals("Block")) terminalPanel.setCursorStyle(TerminalPanel.CursorStyle.BLOCK);
             else if(style.equals("Underscore")) terminalPanel.setCursorStyle(TerminalPanel.CursorStyle.UNDERSCORE);
             else terminalPanel.setCursorStyle(TerminalPanel.CursorStyle.I_BEAM);
             
             this.enableSound = sound.isSelected();
             dialog.dispose();
        });
        
        dialog.add(p, BorderLayout.CENTER);
        dialog.add(ok, BorderLayout.SOUTH);
        dialog.pack(); dialog.setLocationRelativeTo(getParentFrame()); dialog.setVisible(true);
    }
    
    // Accessors for external use (e.g. by Settings Dialogs)
    public int getFontSize() {
        return terminalPanel.getTerminalFont().getSize();
    }
    
    public void setFontSize(int size) {
        terminalPanel.setFont(new Font("Monospaced", Font.PLAIN, size));
    }
    
    public void setCursorStyle(CursorStyle style) {
        this.cursorStyle = style; // Update local state
        
        // Map local enum to UI enum
        com.tn3270.ui.TerminalPanel.CursorStyle uiStyle;
        switch (style) {
            case BLOCK: uiStyle = com.tn3270.ui.TerminalPanel.CursorStyle.BLOCK; break;
            case UNDERSCORE: uiStyle = com.tn3270.ui.TerminalPanel.CursorStyle.UNDERSCORE; break;
            default: uiStyle = com.tn3270.ui.TerminalPanel.CursorStyle.I_BEAM; break;
        }
        
        if (terminalPanel != null) {
            terminalPanel.setCursorStyle(uiStyle);
        }
    }
} // End of TN3270Session
