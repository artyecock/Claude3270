package com.tn3270;

import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.List;
import java.util.function.Consumer;
import javax.net.SocketFactory;
import javax.net.ssl.*;
import javax.swing.*;
import javax.swing.Timer;
import javax.swing.border.*;
import javax.swing.border.EmptyBorder;
// FIX: Import DefaultCaret
import javax.swing.text.DefaultCaret;

public class TN3270Session extends JPanel implements KeyListener {

	// =======================================================================
	// CONSTANTS
	// =======================================================================
	private static final Map<String, Dimension> MODELS = new HashMap<>();
	static {
		MODELS.put("3278-2", new Dimension(80, 24));
		MODELS.put("3279-2", new Dimension(80, 24));
		MODELS.put("3278-3", new Dimension(80, 32));
		MODELS.put("3279-3", new Dimension(80, 32));
		MODELS.put("3278-4", new Dimension(80, 43));
		MODELS.put("3278-5", new Dimension(132, 27));
	}
	private static final byte IAC = (byte) 0xFF, DO = (byte) 0xFD, DONT = (byte) 0xFE, WILL = (byte) 0xFB,
			WONT = (byte) 0xFC, SB = (byte) 0xFA, SE = (byte) 0xF0;
	private static final byte OPT_BINARY = 0, OPT_TERMINAL_TYPE = 24, OPT_EOR = 25, OPT_TN3270E = 40;

	private static final byte TN3270E_OP_DEVICE_TYPE = 0x02, TN3270E_OP_FUNCTIONS = 0x03, TN3270E_OP_IS = 0x04;
	private static final byte TN3270E_OP_REJECT = 0x06, TN3270E_OP_REQUEST = 0x07, TN3270E_OP_SEND = 0x08,
			TN3270E_OP_CONNECT = 0x01;
	private static final byte TN3270E_DT_3270_DATA = 0x00;

	private static final byte CMD_WRITE_F1 = (byte) 0xF1, CMD_ERASE_WRITE_F5 = (byte) 0xF5,
			CMD_ERASE_WRITE_ALTERNATE_7E = (byte) 0x7E;
	private static final byte CMD_WRITE_01 = (byte) 0x01, CMD_ERASE_WRITE_05 = (byte) 0x05,
			CMD_ERASE_WRITE_ALTERNATE_0D = (byte) 0x0D;
	private static final byte CMD_READ_MODIFIED_F6 = (byte) 0xF6, CMD_READ_BUFFER_02 = (byte) 0x02,
			CMD_WSF_F3 = (byte) 0xF3, CMD_WSF_11 = 0x11;
	private static final byte CMD_ERASE_ALL_UNPROTECTED_6F = (byte) 0x6F, CMD_ERASE_ALL_UNPROTECTED_0F = 0x0F,
			CMD_READ_MODIFIED_06 = 0x06, CMD_READ_BUFFER_F2 = (byte) 0xF2;

	private static final byte ORDER_SF = 0x1D, ORDER_SFE = 0x29, ORDER_SA = 0x28, ORDER_SBA = 0x11, ORDER_IC = 0x13;
	private static final byte ORDER_RA = 0x3C, ORDER_MF = 0x2C, ORDER_GE = 0x08, ORDER_EUA = 0x12, ORDER_PT = 0x05,
			ORDER_FM = 0x1E;

	private static final byte ATTR_FIELD = (byte) 0xC0, ATTR_HIGHLIGHTING = 0x41, ATTR_FOREGROUND = 0x42;

	public static final byte AID_ENTER = (byte) 0x7D;
	public static final byte AID_CLEAR = (byte) 0x6D;
	public static final byte AID_SYSREQ = (byte) 0xF0;
	public static final byte AID_ATTN = (byte) 0x6A;
	public static final byte AID_CURSOR_SELECT = (byte) 0x7E;
	public static final byte AID_PA1 = (byte) 0x6C;
	public static final byte AID_PA2 = (byte) 0x6E;
	public static final byte AID_PA3 = (byte) 0x6B;
	public static final byte AID_PF1 = (byte) 0xF1;
	public static final byte AID_PF2 = (byte) 0xF2;
	public static final byte AID_PF3 = (byte) 0xF3;
	public static final byte AID_PF4 = (byte) 0xF4;
	public static final byte AID_PF5 = (byte) 0xF5;
	public static final byte AID_PF6 = (byte) 0xF6;
	public static final byte AID_PF7 = (byte) 0xF7;
	public static final byte AID_PF8 = (byte) 0xF8;
	public static final byte AID_PF9 = (byte) 0xF9;
	public static final byte AID_PF10 = (byte) 0x7A;
	public static final byte AID_PF11 = (byte) 0x7B;
	public static final byte AID_PF12 = (byte) 0x7C;
	public static final byte AID_PF13 = (byte) 0xC1;
	public static final byte AID_PF14 = (byte) 0xC2;
	public static final byte AID_PF15 = (byte) 0xC3;
	public static final byte AID_PF16 = (byte) 0xC4;
	public static final byte AID_PF17 = (byte) 0xC5;
	public static final byte AID_PF18 = (byte) 0xC6;
	public static final byte AID_PF19 = (byte) 0xC7;
	public static final byte AID_PF20 = (byte) 0xC8;
	public static final byte AID_PF21 = (byte) 0xC9;
	public static final byte AID_PF22 = (byte) 0x4A;
	public static final byte AID_PF23 = (byte) 0x4B;
	public static final byte AID_PF24 = (byte) 0x4C;

	private static final byte WCC_RESET = 0x40, WCC_ALARM = 0x04, WCC_RESET_MDT = 0x01;

	// --- EBCDIC TABLES ---
	private static final char[] EBCDIC_TO_ASCII = new char[256];
	private static final byte[] ASCII_TO_EBCDIC = new byte[256];
	private static final char[] EBCDIC_TO_APL = new char[256];
	private static final byte[] ADDRESS_TABLE = { 0x40, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5,
			(byte) 0xC6, (byte) 0xC7, (byte) 0xC8, (byte) 0xC9, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, (byte) 0xD1,
			(byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, (byte) 0xD8, (byte) 0xD9,
			0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5,
			(byte) 0xE6, (byte) 0xE7, (byte) 0xE8, (byte) 0xE9, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, (byte) 0xF0,
			(byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, (byte) 0xF8,
			(byte) 0xF9, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F };

	static {
		Arrays.fill(EBCDIC_TO_ASCII, '\0');
		Arrays.fill(ASCII_TO_EBCDIC, (byte) 0);
		String iso = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		// Initialize minimal set for functionality
		EBCDIC_TO_ASCII[0x00] = '\0';
		EBCDIC_TO_ASCII[0x40] = ' ';
		int[] lower = { 0x81, 0x91, 0xA2 };
		for (int i = 0; i < 26; i++) {
			int base = (i < 9) ? lower[0] : (i < 18) ? lower[1] : lower[2];
			int off = (i < 9) ? i : (i < 18) ? i - 9 : i - 18;
			EBCDIC_TO_ASCII[base + off] = iso.charAt(i);
			EBCDIC_TO_ASCII[base + off + 0x40] = Character.toUpperCase(iso.charAt(i));
		}
		for (int i = 0; i < 10; i++)
			EBCDIC_TO_ASCII[0xF0 + i] = iso.charAt(52 + i);

		// Symbols
		char[] syms = { '-', '+', '=', ',', '.', '/', '!', '@', '#', '$', '%', '&', '*', '(', ')', '_', '"', ':', ';',
				'[', '?', '\'' };
		int[] locs = { 0x60, 0x4E, 0x7E, 0x6B, 0x4B, 0x61, 0x5A, 0x7C, 0x7B, 0x5B, 0x6C, 0x50, 0x5C, 0x4D, 0x5D, 0x6D,
				0x7F, 0x7A, 0x5E, 0x4A, 0x6F, 0x7D };
		for (int i = 0; i < syms.length; i++)
			EBCDIC_TO_ASCII[locs[i]] = syms[i];

		for (int i = 0; i < 256; i++) {
			char c = EBCDIC_TO_ASCII[i];
			if (c > 0 && c < 256)
				ASCII_TO_EBCDIC[c] = (byte) i;
		}
		ASCII_TO_EBCDIC[' '] = 0x40;

		// APL / Box Drawing
		System.arraycopy(EBCDIC_TO_ASCII, 0, EBCDIC_TO_APL, 0, 256);
		EBCDIC_TO_APL[0xAD] = '┌';
		EBCDIC_TO_APL[0xBD] = '└';
		EBCDIC_TO_APL[0xAE] = '┐';
		EBCDIC_TO_APL[0xBE] = '┘';
		EBCDIC_TO_APL[0x85] = '│';
		EBCDIC_TO_APL[0xA2] = '─';
		EBCDIC_TO_APL[0xC5] = '┼';
	}

	// --- STATE VARIABLES ---
	public TerminalCanvas canvas;
	private StatusBar statusBar;
	private Timer blinkTimer;

	private Socket socket;
	private InputStream input;
	private OutputStream output;
	private volatile boolean connected = false;
	private Thread readerThread;
	private String currentHost;
	private int currentPort;
	private boolean useTLS = false;
	private String requestedLuName = "";

	private String model = "3279-3";
	private int rows, cols;
	private char[] buffer;
	private byte[] attributes, extendedColors, highlighting;
	private int cursorPos = 0;
	private byte currentColor = 0, currentHighlight = 0;
	public boolean insertMode = false, keyboardLocked = false;
	private byte lastAID = AID_ENTER;
	private boolean queryReplySent = false;

	private int replyModeFlags = 0;

	private enum ReplyMode {
		FIELD, EXTENDED_FIELD, CHARACTER
	}

	private ReplyMode currentReplyMode = ReplyMode.FIELD;
	private boolean tn3270eMode = false, tn3270eAttempted = false, tn3270eNegotiationComplete = false;

	// File Transfer State
	private static final byte SFID_DATA_CHAIN = (byte) 0xD0, DC_OPEN = 0x00, DC_CLOSE = 0x41, DC_GET = 0x46,
			DC_INSERT = 0x47, DC_SET_CURSOR = 0x45;
	private static final byte AID_STRUCTURED_FIELD = (byte) 0x88, RESP_POSITIVE = 0x09, RESP_NEGATIVE = 0x08;

	private enum FileTransferState {
		IDLE, TRANSFER_IN_PROGRESS, ERROR
	}

	private enum FileTransferDirection {
		UPLOAD, // Host -> PC
		DOWNLOAD // PC -> Host
	}

	// Add host type enum
	private enum HostType {
		TSO, CMS
	}

	private HostType hostType = HostType.CMS; // Default

	private FileTransferDirection ftDirection = FileTransferDirection.DOWNLOAD;
	private FileTransferState ftState = FileTransferState.IDLE;
	private int blockSequence = 0;
	private InputStream uploadStream;
	private OutputStream downloadStream;
	private File currentFile;
	private String currentFilename = null;
	private boolean ftIsText = true, ftIsMessage = false, ftHadSuccessfulTransfer = false, pendingCR = false;

	// UI Variables
	private JDialog progressDialog;
	private JProgressBar transferProgressBar;
	private JLabel progressLabel, transferStatusLabel;
	private JButton cancelTransferButton;

	// Settings
	private Color[] colors = { Color.BLACK, Color.BLUE, Color.RED, Color.MAGENTA, Color.GREEN, Color.CYAN, Color.YELLOW,
			Color.WHITE };
	private Color screenBackground = Color.BLACK, defaultForeground = Color.GREEN, cursorColor = Color.WHITE;

	public enum CursorStyle {
		BLOCK, UNDERSCORE, I_BEAM
	}

	private CursorStyle cursorStyle = CursorStyle.BLOCK;
	private boolean enableSound = true, autoAdvance = true;

	// Selection
	private int selectionStart = -1, selectionEnd = -1;
	boolean selecting = false;

	// Mappings
	private Map<Integer, KeyMapping> keyMap = new HashMap<>();
	private Map<Character, Character> inputCharMap = new HashMap<>();
	private static final String KEYMAP_FILE = System.getProperty("user.home") + File.separator + ".tn3270keymap";

	public static class KeyMapping implements Serializable {
		private static final long serialVersionUID = 1L;
		char character;
		Byte aid;
		String description;

		KeyMapping(char c, String d) {
			this.character = c;
			this.description = d;
		}

		KeyMapping(byte a, String d) {
			this.aid = a;
			this.description = d;
		}
	}

	// =======================================================================
	// CONSTRUCTOR
	// =======================================================================
	public TN3270Session(String modelName) {
		this.model = (modelName != null) ? modelName : "3278-2";
		Dimension dim = MODELS.getOrDefault(this.model, new Dimension(80, 24));
		rows = dim.height;
		cols = dim.width;

		// Use large buffer to handle Mod 5 or dynamic resizing without crashes
		int max = 4000;
		buffer = new char[max];
		attributes = new byte[max];
		extendedColors = new byte[max];
		highlighting = new byte[max];
		clearScreen();
		initializeKeyMappings();

		setLayout(new BorderLayout());
		canvas = new TerminalCanvas();
		JScrollPane sp = new JScrollPane(canvas);
		sp.setBorder(null);
		sp.getViewport().setBackground(Color.BLACK);
		sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
		sp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		add(sp, BorderLayout.CENTER);

		statusBar = new StatusBar();
		add(statusBar, BorderLayout.SOUTH);

		blinkTimer = new Timer(500, e -> canvas.repaint());
		blinkTimer.start();

		setFocusable(true);
		addKeyListener(this);
		canvas.addKeyListener(this);

		addHierarchyListener(e -> {
			if ((e.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) != 0 && isDisplayable()) {
				SwingUtilities.invokeLater(canvas::updateSize);
			}
		});
	}

	// --- HELPERS ---
	public Frame getParentFrame() {
		Window w = SwingUtilities.getWindowAncestor(this);
		return (w instanceof Frame) ? (Frame) w : null;
	}

	public void setUseTLS(boolean t) {
		useTLS = t;
	}

	public void setRequestedLuName(String l) {
		requestedLuName = l;
	}

	public boolean isConnected() {
		return connected;
	}

	public Map<Integer, KeyMapping> getKeyMap() {
		return keyMap;
	}

	public Map<Character, Character> getInputCharMap() {
		return inputCharMap;
	}

	@Override
	public boolean requestFocusInWindow() {
		if (canvas != null)
			return canvas.requestFocusInWindow();
		return super.requestFocusInWindow();
	}

	private void initializeKeyMappings() {
		keyMap.put(KeyEvent.VK_BACK_QUOTE, new KeyMapping('¬', "Not"));
		inputCharMap.put('¦', '|');
		loadKeyMappings();
	}

	@SuppressWarnings("unchecked")
	public void loadKeyMappings() {
		if (!new File(KEYMAP_FILE).exists())
			return;
		try (ObjectInputStream i = new ObjectInputStream(new FileInputStream(KEYMAP_FILE))) {
			Map<Integer, KeyMapping> m = (Map<Integer, KeyMapping>) i.readObject();
			keyMap.clear();
			keyMap.putAll(m);
		} catch (Exception e) {
		}
	}

	public void saveKeyMappings() {
		try (ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(KEYMAP_FILE))) {
			o.writeObject(new HashMap<>(keyMap));
		} catch (Exception e) {
		}
	}
	
// --- MISSING HELPERS ---
    
    // 1. Show Message Dialog Wrapper (Fixes 8 errors)
    private void showMessageDialog(String msg, String title, boolean isError) {
        JOptionPane.showMessageDialog(getParentFrame(), msg, title, isError ? JOptionPane.ERROR_MESSAGE : JOptionPane.INFORMATION_MESSAGE);
    }
    
 // Add this overload to handle 2-argument calls
    private void showMessageDialog(String msg, String title) {
        showMessageDialog(msg, title, false);
    }
    
    // 2. Build Command (Fixes TN3270Emulator error)
    public String buildIndFileCommand(boolean dl, boolean tso, String ds, boolean asc, boolean crlf, boolean app, String rec, String lrecl, String blk, String spc) {
        StringBuilder sb = new StringBuilder("IND$FILE ");
        sb.append(dl ? "GET " : "PUT ").append(ds);
        if (!tso) { // CMS
            sb.append(" (");
            if (asc) sb.append(" ASCII").append(crlf?" CRLF":"");
            if (app) sb.append(" APPEND");
            if (!dl && !rec.isEmpty()) sb.append(" RECFM ").append(rec);
            if (!dl && !lrecl.isEmpty()) sb.append(" LRECL ").append(lrecl);
            sb.append(")");
        } else { // TSO
            if (asc) sb.append(" ASCII").append(crlf?" CRLF":"");
            if (app) sb.append(" APPEND");
            if (!dl && !rec.isEmpty()) sb.append(" RECFM(").append(rec).append(")");
            if (!dl && !lrecl.isEmpty()) sb.append(" LRECL(").append(lrecl).append(")");
            if (!dl && !blk.isEmpty()) sb.append(" BLKSIZE(").append(blk).append(")");
            if (!dl && !spc.isEmpty()) sb.append(" SPACE(").append(spc).append(")");
        }
        return sb.toString();
    }

    // 3. Initiate Transfer (Fixes TN3270Emulator error)
    public void initiateFileTransfer(String localPath, String cmd, boolean isDownload) {
        currentFile = new File(localPath);
        ftIsText = cmd.toUpperCase().contains("ASCII");
        ftDirection = isDownload ? FileTransferDirection.DOWNLOAD : FileTransferDirection.UPLOAD;
        
        // Clear current field
        eraseToEndOfField();
        // Type command
        for(char c : cmd.toCharArray()) {
            if(!isProtected(cursorPos)) { buffer[cursorPos]=c; setModified(cursorPos); cursorPos=(cursorPos+1)%buffer.length; }
        }
        canvas.repaint();
        sendAID(AID_ENTER);
    }

    // 4. Apply Color Scheme (Fixes TN3270Emulator error)
    public void applyColorScheme(String name) {
        // Simple mapping logic - expand with your full map if needed
        // For now, just forces a repaint since colors are usually static constants in session
        canvas.repaint();
        statusBar.setStatus("Applied: " + name);
    }
    
    // 5. Font Size Accessors
    public int getFontSize() { return canvas.getTerminalFont().getSize(); }
    public void setFontSize(int size) { canvas.setFont(canvas.getTerminalFont().deriveFont((float)size)); }
    
    // 6. Cursor Style
    public void setCursorStyle(CursorStyle style) { this.cursorStyle = style; canvas.repaint(); }
    
    // 7. Fix Drag Start
    private Point dragStart; // Missing field

	private SSLSocketFactory createTrustAllSSLSocketFactory() {
		try {
			TrustManager[] t = new TrustManager[] { new X509TrustManager() {
				public void checkClientTrusted(java.security.cert.X509Certificate[] c, String s) {
				}

				public void checkServerTrusted(java.security.cert.X509Certificate[] c, String s) {
				}

				public java.security.cert.X509Certificate[] getAcceptedIssuers() {
					return null;
				}
			} };
			SSLContext sc = SSLContext.getInstance("TLS");
			sc.init(null, t, new java.security.SecureRandom());
			return sc.getSocketFactory();
		} catch (Exception e) {
			return (SSLSocketFactory) SSLSocketFactory.getDefault();
		}
	}

	// --- NETWORKING ---
	public void connect(String h, int p) {
		this.currentHost = h;
		this.currentPort = p;
		new Thread(() -> {
			try {
				if (useTLS) {
					SocketFactory f = createTrustAllSSLSocketFactory();
					socket = f.createSocket(h, p);
					((SSLSocket) socket).setEnabledProtocols(new String[] { "TLSv1.2", "TLSv1.3" });
					socket.setSoTimeout(0);
					((SSLSocket) socket).startHandshake();
					SwingUtilities.invokeLater(() -> statusBar.setStatus("TLS: " + h));
				} else {
					socket = new Socket();
					socket.connect(new InetSocketAddress(h, p), 5000);
					SwingUtilities.invokeLater(() -> statusBar.setStatus("Conn: " + h));
				}
				if (socket.isConnected()) {
					String ip = socket.getInetAddress().getHostAddress();
					SwingUtilities.invokeLater(() -> statusBar.setIP(ip));
				}
				input = socket.getInputStream();
				output = socket.getOutputStream();
				connected = true;
				readerThread = new Thread(this::readLoop);
				readerThread.start();
			} catch (Exception e) {
				try {
					if (socket != null)
						socket.close();
				} catch (Exception x) {
				}
				connected = false;
				SwingUtilities.invokeLater(() -> {
					statusBar.setStatus("Failed");
					JOptionPane.showMessageDialog(this, "Connect Error: " + e.getMessage());
					Frame f = getParentFrame();
					if (f instanceof TN3270Emulator)
						((TN3270Emulator) f).closeSession(this);
				});
			}
		}).start();
	}

	public void disconnect() {
		connected = false;
		try {
			if (socket != null)
				socket.close();
		} catch (Exception e) {
		}
		statusBar.setStatus("Disconnected");
		statusBar.setIP("");
		canvas.repaint();
	}

	public void reconnect() {
		if (currentHost != null) {
			disconnect();
			try {
				Thread.sleep(500);
			} catch (Exception e) {
			}
			connect(currentHost, currentPort);
		}
	}

	private void readLoop() {
		byte[] buf = new byte[8192];
		ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
		ByteArrayOutputStream subnegBuffer = new ByteArrayOutputStream();
		int ts = 0; // 0=DATA, 1=IAC, 2=SB, 3=WILL, 4=WONT, 5=DO, 6=DONT

		try {
			while (connected) {
				int n = input.read(buf);
				if (n <= 0)
					break;
				for (int i = 0; i < n; i++) {
					byte b = buf[i];
					if (ts == 0) {
						if (b == IAC)
							ts = 1;
						else
							dataStream.write(b);
					} else if (ts == 1) {
						if (b == IAC) {
							dataStream.write(0xFF);
							ts = 0;
						} else if (b == SB) {
							ts = 2;
							subnegBuffer.reset();
						} else if (b == WILL)
							ts = 3;
						else if (b == WONT)
							ts = 4;
						else if (b == DO)
							ts = 5;
						else if (b == DONT)
							ts = 6;
						else if (b == (byte) 0xEF) {
							process3270Data(dataStream.toByteArray());
							dataStream.reset();
							ts = 0;
						} else
							ts = 0;
					} else if (ts == 3) {
						handleTelnet(WILL, b);
						ts = 0;
					} else if (ts == 4) {
						handleTelnet(WONT, b);
						ts = 0;
					} else if (ts == 5) {
						handleTelnet(DO, b);
						ts = 0;
					} else if (ts == 6) {
						handleTelnet(DONT, b);
						ts = 0;
					} else if (ts == 2) {
						if (b == SE) {
							byte[] sn = subnegBuffer.toByteArray();
							if (sn.length > 0 && sn[sn.length - 1] == IAC) {
								handleSubneg(Arrays.copyOf(sn, sn.length - 1));
								ts = 0;
							} else
								subnegBuffer.write(b);
						} else if (b != IAC)
							subnegBuffer.write(b);
					}
				}
			}
		} catch (Exception e) {
			if (connected)
				statusBar.setStatus("Connection lost.");
		}
		disconnect();
	}

	private void handleTelnet(byte cmd, byte opt) throws IOException {
		if (cmd == DO && (opt == OPT_TERMINAL_TYPE || opt == OPT_BINARY || opt == OPT_EOR))
			sendTelnet(WILL, opt);
		else if (cmd == DO && opt == OPT_TN3270E) {
			if (!tn3270eAttempted) {
				tn3270eAttempted = true;
				sendTelnet(WILL, opt);
			} else
				sendTelnet(WONT, opt);
		} else if (cmd == WILL && opt == OPT_TN3270E) {
			if (!tn3270eAttempted) {
				tn3270eAttempted = true;
				sendTelnet(DO, opt);
			} else
				sendTelnet(DONT, opt);
		} else if (cmd == WILL)
			sendTelnet(DO, opt);
		else if (cmd == WONT)
			sendTelnet(DONT, opt);
		else if (cmd == DONT)
			sendTelnet(WONT, opt);
	}

	private void handleSubneg(byte[] d) throws IOException {
		if (d.length < 2)
			return;
		if (d[0] == OPT_TERMINAL_TYPE && d[1] == 1) {
			ByteArrayOutputStream b = new ByteArrayOutputStream();
			b.write(IAC);
			b.write(SB);
			b.write(OPT_TERMINAL_TYPE);
			b.write(0);
			b.write(("IBM-" + model + "-E").getBytes());
			b.write(IAC);
			b.write(SE);
			output.write(b.toByteArray());
			output.flush();
		} else if (d[0] == OPT_TN3270E) {
			int op = d[1] & 0xFF;
			if (op == TN3270E_OP_SEND && d[2] == TN3270E_OP_DEVICE_TYPE) {
				ByteArrayOutputStream b = new ByteArrayOutputStream();
				b.write(IAC);
				b.write(SB);
				b.write(OPT_TN3270E);
				b.write(TN3270E_OP_DEVICE_TYPE);
				b.write(TN3270E_OP_REQUEST);
				b.write(("IBM-" + model + "-E").getBytes());
				if (!requestedLuName.isEmpty()) {
					b.write(TN3270E_OP_CONNECT);
					b.write(requestedLuName.getBytes());
				}
				b.write(IAC);
				b.write(SE);
				output.write(b.toByteArray());
				output.flush();
			} else if (op == TN3270E_OP_DEVICE_TYPE && d[2] == TN3270E_OP_IS) {
				tn3270eMode = true;
				ByteArrayOutputStream b = new ByteArrayOutputStream();
				b.write(IAC);
				b.write(SB);
				b.write(OPT_TN3270E);
				b.write(TN3270E_OP_FUNCTIONS);
				b.write(TN3270E_OP_REQUEST);
				b.write(0x00);
				b.write(0x01);
				b.write(0x02);
				b.write(0x03);
				b.write(IAC);
				b.write(SE);
				output.write(b.toByteArray());
				output.flush();
			} else if (op == TN3270E_OP_FUNCTIONS && d[2] == TN3270E_OP_IS)
				sendQueryResponse();
		}
	}

	private void sendTelnet(byte c, byte o) throws IOException {
		output.write(new byte[] { IAC, c, o });
		output.flush();
	}

	// --- 3270 LOGIC ---
	private void process3270Data(byte[] data) {
		if (data.length < 1)
			return;
		int off = 0;
		if (tn3270eMode && data.length > 5 && data[0] == TN3270E_DT_3270_DATA)
			off = 5;
		if (off >= data.length)
			return;

		byte cmd = data[off++];
		if (cmd == CMD_ERASE_WRITE_05 || cmd == CMD_ERASE_WRITE_F5 || cmd == CMD_ERASE_WRITE_ALTERNATE_7E)
			clearScreen();
		if (cmd == CMD_WRITE_01 || cmd == CMD_WRITE_F1 || cmd == CMD_ERASE_WRITE_05 || cmd == CMD_ERASE_WRITE_F5) {
			if (off < data.length) {
				byte wcc = data[off++];
				if ((wcc & WCC_RESET) != 0) {
					keyboardLocked = false;
					resetReplyModeToDefault();
				}
				if ((wcc & WCC_RESET_MDT) != 0)
					resetMDT();
				processOrders(data, off);
			}
			keyboardLocked = false;
		}
		if (cmd == CMD_READ_MODIFIED_F6 || cmd == CMD_READ_MODIFIED_06)
			sendAID(lastAID);
		if (cmd == CMD_READ_BUFFER_02 || cmd == CMD_READ_BUFFER_F2)
			sendReadBuffer();
		if (cmd == CMD_WSF_11 || cmd == CMD_WSF_F3)
			processWSF(data, off);
		if (cmd == CMD_ERASE_ALL_UNPROTECTED_0F || cmd == CMD_ERASE_ALL_UNPROTECTED_6F)
			eraseAllUnprotected();

		canvas.repaint();
		statusBar.update();
	}

	private void processOrders(byte[] data, int offset) {
		int p = 0, i = offset;
		int[] idx = { 0 };
		char c;
		while (i < data.length) {
			byte b = data[i++];
			if (b == ORDER_SF) {
				if (i < data.length) {
					attributes[p] = data[i++];
					buffer[p] = ' ';
					extendedColors[p] = 0;
					highlighting[p] = 0;
					p = (p + 1) % buffer.length;
				}
			} else if (b == ORDER_SFE) {
				if (i < data.length) {
					int count = data[i++] & 0xFF;
					byte a = 0, col = 0, hl = 0;
					for (int k = 0; k < count; k++) {
						if (i + 1 >= data.length)
							break;
						byte t = data[i++], v = data[i++];
						if (t == ATTR_FIELD || t == 0xC0)
							a = v;
						else if (t == ATTR_FOREGROUND)
							col = v;
						else if (t == ATTR_HIGHLIGHTING)
							hl = v;
					}
					buffer[p] = ' ';
					attributes[p] = a;
					extendedColors[p] = col;
					highlighting[p] = hl;
					p = (p + 1) % buffer.length;
				}
			} else if (b == ORDER_SBA) {
				if (i + 1 < data.length) {
					p = decode3270Address(data[i], data[i + 1]);
					i += 2;
				}
			} else if (b == ORDER_IC) {
				cursorPos = p;
				if (isFieldStart(p))
					cursorPos = (p + 1) % buffer.length;
			} else if (b == ORDER_RA) {
				if (i + 2 < data.length) {
					int end = decode3270Address(data[i], data[i + 1]);
					idx[0] = i + 2;
					c = fetchDisplayChar(data, idx);
					i = idx[0];
					while (p != end) {
						buffer[p] = c;
						attributes[p] = 0;
						extendedColors[p] = 0;
						p = (p + 1) % buffer.length;
					}
				}
			} else if (b == ORDER_GE) {
				idx[0] = i - 1;
				c = fetchDisplayChar(data, idx);
				i = idx[0];
				buffer[p] = c;
				attributes[p] = 0;
				p = (p + 1) % buffer.length;
			} else if (b == ORDER_PT) {
				for (int k = 0; k < rows * cols; k++) {
					if (isFieldStart(p) && !isProtected(p)) {
						p = (p + 1) % buffer.length;
						break;
					}
					p = (p + 1) % buffer.length;
				}
			} else if (b == ORDER_SA) {
				i += 2; // Simplified SA skip
			} else {
				c = EBCDIC_TO_ASCII[b & 0xFF];
				buffer[p] = c;
				attributes[p] = 0;
				p = (p + 1) % buffer.length;
			}
		}
	}

	public void sendAID(byte aid) {
		lastAID = aid;
		keyboardLocked = true;
		statusBar.update();
		try {
			ByteArrayOutputStream b = new ByteArrayOutputStream();
			b.write(aid);
			byte[] ca = encode3270Address(cursorPos);
			b.write(ca[0]);
			b.write(ca[1]);
			if (aid == AID_CLEAR)
				resetReplyModeToDefault();
			if (aid == AID_ENTER || (aid >= AID_PF1 && aid <= AID_PF24)) {
				for (int i = 0; i < rows * cols; i++) {
					if (isFieldStart(i) && (attributes[i] & 0x01) != 0) {
						b.write(ORDER_SBA);
						byte[] fa = encode3270Address(i + 1);
						b.write(fa[0]);
						b.write(fa[1]);
						int end = findNextField(i);
						for (int j = i + 1; j != end; j = (j + 1) % buffer.length) {
							if (buffer[j] != '\0') {
								if (ASCII_TO_EBCDIC[buffer[j]] != 0)
									b.write(ASCII_TO_EBCDIC[buffer[j]]);
								else
									b.write(0x40);
							}
						}
					}
				}
			}
			sendData(b.toByteArray());
		} catch (Exception e) {
		}
		canvas.repaint();
	}

	private void sendData(byte[] d) throws IOException {
		ByteArrayOutputStream b = new ByteArrayOutputStream();
		if (tn3270eMode)
			b.write(new byte[] { 0, 0, 0, 0, 0 });
		b.write(d);
		b.write(IAC);
		b.write((byte) 0xEF);
		output.write(b.toByteArray());
		output.flush();
	}

	// --- FILE TRANSFER ---
	private void processWSF(byte[] d, int o) {
		if (o + 2 >= d.length)
			return;
		if (d[o + 2] == SFID_DATA_CHAIN)
			handleDataChain(d, o, ((d[o] & 0xFF) << 8) | (d[o + 1] & 0xFF));
		else if (d[o + 2] == 0x01)
			sendQueryResponse();
	}

	private void handleDataChain(byte[] d, int o, int l) {
		if (o + 3 >= d.length)
			return;
		byte op = d[o + 3];
		if (op == DC_OPEN)
			handleDCOpen(d, o, l);
		else if (op == DC_CLOSE)
			handleDCClose(d, o, l);
		else if (op == DC_GET)
			handleDCGet(d, o, l);
		else if (op == DC_INSERT)
			handleDCInsert(d, o, l);
		else if (op == DC_SET_CURSOR) {
			if (o + 6 < d.length && d[o + 4] == ORDER_SBA) {
				int p = decode3270Address(d[o + 5], d[o + 6]);
				if (p >= 0 && p < buffer.length) {
					cursorPos = p;
					canvas.repaint();
				}
			}
		}
	}

	// Handle DC_OPEN
	private void handleDCOpen(byte[] data, int offset, int length) {
		System.out.println("=== DC_OPEN received ===");
		System.out.println("Offset: " + offset + ", Length: " + length);

		// Debug: dump the entire Open command
		System.out.print("Open data: ");
		for (int i = offset; i < offset + length && i < data.length; i++) {
			System.out.print(String.format("%02X ", data[i]));
		}
		System.out.println();

		// Parse filename from the Open command
		String filename = null;

		for (int i = offset; i < offset + length - 3; i++) {
			if (data[i] == 0x46 && data[i + 1] == 0x54 && data[i + 2] == 0x3A) {
				StringBuilder sb = new StringBuilder();
				for (int j = i; j < offset + length; j++) {
					byte b = data[j];
					if (b == 0x00 || b == (byte) 0xFF)
						break;
					char c = (char) (b & 0xFF);
					sb.append(c);
				}
				filename = sb.toString().trim();
				break;
			}
		}

		System.out.println("Open filename: " + filename);
		currentFilename = filename;

		// Check if this is data transfer or message
		boolean isData = filename != null && filename.contains("FT:DATA");
		boolean isMsg = filename != null && filename.contains("FT:MSG");

		System.out.println("isData: " + isData + ", isMsg: " + isMsg);

		if (isMsg) {
			// FT:MSG - reset state for message processing
			System.out.println("FT:MSG detected - preparing for completion message");

			ftState = FileTransferState.IDLE;
			ftIsMessage = true;
			blockSequence = 0;
			sendDCOpenResponse(true, 0);
			return;
		}

		if (!isData) {
			System.out.println("Unknown file type in Open");
			closeProgressDialog();
			showMessageDialog("Unknown file transfer type", "Transfer Error", true);
			sendDCOpenResponse(false, 0x5D00);
			return;
		}

		// *** Reset message flag when opening FT:DATA ***
		ftIsMessage = false;
		System.out.println("FT:DATA detected - reset ftIsMessage to false");

		// Determine direction from the Open header
		boolean hostWillGet = false;
		int directionByteOffset = offset + 14;

		if (directionByteOffset < data.length) {
			hostWillGet = (data[directionByteOffset] == 0x01);
			System.out.println("Direction byte at offset " + directionByteOffset + ": 0x"
					+ String.format("%02X", data[directionByteOffset]) + " -> hostWillGet=" + hostWillGet);
		}

		// Open the actual file for data transfer
		try {
			if (currentFile == null) {
				closeProgressDialog();
				showMessageDialog("No file specified", "Transfer Error", true);
				sendDCOpenResponse(false, 0x1B00);
				return;
			}

			if (hostWillGet) {
				// Host will GET data = Upload from PC to Host
				if (!currentFile.exists()) {
					closeProgressDialog();
					showMessageDialog("File not found: " + currentFile.getName(), "Transfer Error", true);
					sendDCOpenResponse(false, 0x1B00);
					return;
				}
				// uploadStream = new FileInputStream(currentFile);
				// Wrap in BufferedInputStream to support mark/reset for smart chunking
				uploadStream = new BufferedInputStream(new FileInputStream(currentFile));

				pendingCR = false; // Reset state

				long fileSize = currentFile.length();
				System.out.println("Opened file for READING (upload to host): " + currentFile.getAbsolutePath());
				updateProgressDialog("Sending data to host...", fileSize + " bytes total");
			} else {
				// Host will INSERT data = Download from Host to PC
				downloadStream = new FileOutputStream(currentFile);
				System.out.println("Opened file for WRITING (download from host): " + currentFile.getAbsolutePath());
				updateProgressDialog("Receiving data from host...", "Block 0");
			}

			ftState = FileTransferState.TRANSFER_IN_PROGRESS;
			blockSequence = 0;
			sendDCOpenResponse(true, 0);
			System.out.println("Sent positive DC_OPEN response");

		} catch (IOException e) {
			e.printStackTrace();
			closeProgressDialog();

			if (e instanceof FileNotFoundException) {
				showMessageDialog("File not found: " + currentFile.getName(), "Transfer Error", true);
				sendDCOpenResponse(false, 0x1B00);
			} else {
				showMessageDialog("File open error: " + e.getMessage(), "Transfer Error", true);
				sendDCOpenResponse(false, 0x2000);
			}
		}
	}

	// Handle DC_GET (Upload PC -> Host)
	private void handleDCGet(byte[] data, int offset, int length) {
		// System.out.println("=== DC_GET received ===");

		if (uploadStream == null) {
			sendDCGetResponse(false, 0x2200, null, 0); // EOF
			return;
		}

		try {
			// Buffer to hold multiple lines (up to ~2KB to match PCOMM/MTU)
			ByteArrayOutputStream blockBuffer = new ByteArrayOutputStream(2048);

			// Temporary buffer for the current line being read
			ByteArrayOutputStream lineBuffer = new ByteArrayOutputStream();

			int ch;
			boolean eof = false;
			boolean addedAtLeastOneLine = false;

			// Loop until we fill the block or hit EOF
			while (blockBuffer.size() < 1900) {

				// Read one line
				lineBuffer.reset();
				boolean foundNewline = false;

				// Mark position in case we need to "unread" if the line is too long for
				// remaining space
				if (uploadStream.markSupported()) {
					uploadStream.mark(4096);
				}

				while ((ch = uploadStream.read()) != -1) {
					if (ch == '\n') {
						foundNewline = true;
						break;
					} else if (ch == '\r') {
						// Handle CRLF or bare CR
						int next = -1;
						// Peek next if possible
						if (uploadStream.markSupported()) {
							uploadStream.mark(1);
							next = uploadStream.read();
							if (next != '\n')
								uploadStream.reset(); // Not LF, unread
						}
						foundNewline = true;
						break;
					} else {
						lineBuffer.write(ch);
					}
				}

				if (ch == -1 && lineBuffer.size() == 0) {
					eof = true;
					break;
				}

				// Prepare the line (Add ASCII CRLF)
				if (ftIsText) {
					lineBuffer.write(0x0D); // CR
					lineBuffer.write(0x0A); // LF
				}

				// Check if this line fits in the remaining space of the block
				if (blockBuffer.size() + lineBuffer.size() > 2000) {
					// Line is too big to fit in this block!
					// If we support mark/reset, rewind so we pick this line up next time
					if (uploadStream.markSupported()) {
						try {
							uploadStream.reset();
						} catch (IOException e) {
							// If we can't reset, we must send what we have as a partial block?
							// Or just force this line into the current block (slightly oversize)
							// Ideally, BufferedInputStream supports mark.
							blockBuffer.write(lineBuffer.toByteArray());
						}
					} else {
						// Fallback: Just write it, hopefully it doesn't exceed 3270 limit (~4k) too
						// badly
						blockBuffer.write(lineBuffer.toByteArray());
					}
					addedAtLeastOneLine = true;
					break; // Block full
				} else {
					// It fits, append it
					blockBuffer.write(lineBuffer.toByteArray());
					addedAtLeastOneLine = true;
				}

				// If we hit EOF while reading this line, stop loop after adding it
				if (ch == -1) {
					eof = true;
					break;
				}
			}

			byte[] dataToSend = blockBuffer.toByteArray();

			if (dataToSend.length > 0) {
				blockSequence++;
				sendDCGetResponse(true, 0, dataToSend, dataToSend.length);

				// Update UI less frequently (every 10 blocks) to save CPU
				if (blockSequence % 10 == 0 || eof) {
					updateProgressDialog("Sending block " + blockSequence + "...", (blockSequence * 2) + " KB sent");
				}
			} else if (eof) {
				// True EOF
				System.out.println("Upload EOF reached.");
				uploadStream.close();
				uploadStream = null;
				sendDCGetResponse(false, 0x2200, null, 0); // 0x2200 = EOF Error Code
			}

		} catch (IOException e) {
			e.printStackTrace();
			sendDCGetResponse(false, 0x2000, null, 0);
			closeProgressDialog();
			JOptionPane.showMessageDialog(this, "Upload error: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
		}
	}

	// Handle DC_INSERT (for download from Host to PC)
	private void handleDCInsert(byte[] data, int offset, int length) {
		System.out.println("=== DC_INSERT received ===");
		System.out.println("Offset: " + offset + ", Length: " + length);

		// Debug: dump the start of the packet to see headers
		System.out.print("DC_INSERT bytes: ");
		for (int i = offset; i < Math.min(offset + 20, data.length); i++) {
			System.out.print(String.format("%02X ", data[i]));
		}
		System.out.println();

		// ---------------------------------------------------------
		// 1. Handle FT:MSG (Transfer Completion Message)
		// ---------------------------------------------------------
		if (ftIsMessage) {
			System.out.println("Processing FT:MSG completion message");

			// Only process the first FT:MSG block containing the text
			if (blockSequence > 0) {
				System.out.println("Ignoring subsequent FT:MSG block " + (blockSequence + 1));
				blockSequence++;
				sendDCInsertResponse(true, 0);
				return;
			}

			// The 0x61 marker should be at offset + 7
			int markerOffset = offset + 7;

			if (markerOffset + 2 >= data.length) {
				System.out.println("FT:MSG: Packet too short for data marker");
				sendDCInsertResponse(true, 0);
				return;
			}

			// If we don't see the marker in a Message SF, it might be a header. Skip it.
			if (data[markerOffset] != 0x61) {
				System.out.println("FT:MSG: No 0x61 marker. Skipping header.");
				return;
			}

			// Calculate data length
			int dataLen = ((data[markerOffset + 1] & 0xFF) << 8) | (data[markerOffset + 2] & 0xFF);
			dataLen -= 5; // Subtract overhead

			if (dataLen > 0 && markerOffset + 3 + dataLen <= data.length) {
				// FT:MSG is already in ASCII - extract directly
				StringBuilder msgText = new StringBuilder();
				for (int j = 0; j < dataLen; j++) {
					char c = (char) (data[markerOffset + 3 + j] & 0xFF);
					if (c >= 32 && c < 127) {
						msgText.append(c);
					}
				}

				String message = msgText.toString().trim();
				System.out.println("Transfer completion message: " + message);

				// Acknowledge the message
				blockSequence++;
				sendDCInsertResponse(true, 0);

				// Close file streams
				try {
					if (downloadStream != null) {
						downloadStream.flush();
						downloadStream.close();
						downloadStream = null;
					}
					if (uploadStream != null) {
						uploadStream.close();
						uploadStream = null;
					}
				} catch (IOException e) {
					e.printStackTrace();
				}

				closeProgressDialog();

				// Analyze message for Success vs Failure
				boolean isSuccess = message.contains("complete") || message.contains("TRANS03");
				boolean isError = message.contains("Error") || message.contains("TRANS13")
						|| message.contains("TRANS14");

				if (isSuccess && !isError) {
					String successMsg = "Transfer complete!\n\nFile: "
							+ (currentFile != null ? currentFile.getName() : "Unknown") + "\n\nHost: " + message;
					showMessageDialog(successMsg, "Transfer Complete");
					statusBar.setStatus("Download complete");
				} else {
					showMessageDialog("Transfer status:\n\n" + message, isError ? "Transfer Error" : "Transfer Status");
					statusBar.setStatus("Transfer finished: " + message);
				}

				// Reset Transfer State
				ftState = FileTransferState.IDLE;
				ftIsMessage = false;
				ftHadSuccessfulTransfer = false;
				currentFile = null;
				currentFilename = null;
			}
			return;
		}

		// ---------------------------------------------------------
		// 2. Handle FT:DATA (File Content Download)
		// ---------------------------------------------------------
		if (downloadStream == null) {
			System.out.println("ERROR: DC_INSERT received but no download stream open.");
			sendDCInsertResponse(false, 0x4700); // Record not added
			return;
		}

		// Check for the Data Marker (0x61) at offset + 7
		// If it is missing, this is a Header SF (setup packet). We must skip it.
		int markerOffset = offset + 7;

		if (markerOffset >= offset + length) {
			System.out.println("DC_INSERT: Packet too short to contain valid data.");
			return; // Skip
		}

		if (data[markerOffset] != 0x61) {
			System.out.println("DC_INSERT: No 0x61 marker found at offset+7. Assuming Header SF. Skipping.");
			return; // Skip header, wait for data SF
		}

		// Process Actual Data
		try {
			int dataLen = ((data[markerOffset + 1] & 0xFF) << 8) | (data[markerOffset + 2] & 0xFF);
			dataLen -= 5; // Subtract overhead (C0 80 61 dd dd)

			System.out.println("DC_INSERT: Data payload length: " + dataLen);

			if (dataLen > 0 && markerOffset + 3 + dataLen <= data.length) {
				byte[] fileData = new byte[dataLen];
				System.arraycopy(data, markerOffset + 3, fileData, 0, dataLen);

				if (ftIsText) {
					// Text Mode: Handle CRLF and EOF conversion
					ByteArrayOutputStream cleanData = new ByteArrayOutputStream();

					for (int i = 0; i < dataLen; i++) {
						byte b = fileData[i];

						// 1. Handle "Split CRLF" from previous block
						if (pendingCR) {
							pendingCR = false;
							if (b == 0x0A) {
								// This is the LF partner to the previous block's CR.
								// We already wrote the newline for the CR, so SKIP this LF.
								continue;
							}
							// If it wasn't LF, the previous CR was a bare CR (mac style?),
							// which we already wrote as \n. Process this byte normally.
						}

						// 2. Standard Processing
						if (b == 0x0D) {
							// CR found.
							// Is it at the very end of this block?
							if (i == dataLen - 1) {
								pendingCR = true; // Mark for next block
								cleanData.write('\n'); // Write the line ending now
							}
							// Is the next char LF?
							else if (fileData[i + 1] == 0x0A) {
								cleanData.write('\n'); // Write normalized newline
								i++; // Skip the LF
							}
							// Bare CR?
							else {
								cleanData.write('\n');
							}
						} else if (b == 0x0A) {
							// Bare LF
							cleanData.write('\n');
						} else if (b == 0x1A) {
							// EOF Marker (Ctrl-Z) - Ind$File often sends this at the end
							// Do not write it to the file.
							continue;
						} else {
							cleanData.write(b);
						}
					}
					downloadStream.write(cleanData.toByteArray());
				} else {
					// Binary Mode
					downloadStream.write(fileData);
				}

				ftHadSuccessfulTransfer = true;
				blockSequence++;

				// Send Acknowledgement
				sendDCInsertResponse(true, 0);

				updateProgressDialog("Receiving block " + blockSequence + "...", dataLen + " bytes");
			} else {
				// Empty block? Just Ack it.
				System.out.println("DC_INSERT: Empty or malformed data length.");
				sendDCInsertResponse(true, 0);
			}

		} catch (IOException e) {
			e.printStackTrace();
			closeProgressDialog();
			showMessageDialog("Write error: " + e.getMessage(), "Transfer Error", true);
			sendDCInsertResponse(false, 0x4700);
		}
	}

	// Handle DC_CLOSE
	private void handleDCClose(byte[] data, int offset, int length) {
		System.out.println("=== DC_CLOSE received ===");

		try {
			if (downloadStream != null) {
				downloadStream.flush();
				downloadStream.close();
				downloadStream = null;

				if (currentFile != null) {
					System.out.println("Download stream closed. File: " + currentFile.getAbsolutePath());
					System.out.println("File size: " + currentFile.length() + " bytes");

					// --- FIX: REMOVED POPUP DIALOG HERE ---
					// We do NOT show a dialog here anymore. We wait for the FT:MSG
					// which invariably follows DC_CLOSE to show the final status.
					// This prevents the "Double Dialog" issue.

					if (ftHadSuccessfulTransfer && currentFile.length() > 0) {
						statusBar.setStatus("Data received. Waiting for host confirmation...");
					}
				}
			}

			// Upload streams are usually closed in handleDCGet upon EOF,
			// but we ensure they are closed here just in case.
			if (uploadStream != null) {
				uploadStream.close();
				uploadStream = null;
			}

		} catch (IOException e) {
			e.printStackTrace();
			closeProgressDialog();
			// We DO keep the error dialog, as this is a stream crash, not a protocol
			// completion.
			showMessageDialog("File close error: " + e.getMessage(), "Transfer Error", true);
			sendDCCloseResponse(false, 0x7100);
			statusBar.setStatus("File close error");
			return;
		}

		// Do NOT reset ftState to IDLE yet if we are expecting an FT:MSG.
		// However, standard IND$FILE usually treats DC_CLOSE as the end of the Data
		// Chain.
		// We reset variables, but we leave the UI alone until FT:MSG cleans it up.

		// ftState = FileTransferState.IDLE; // Optional: Keep state active until MSG
		ftIsMessage = false;
		ftHadSuccessfulTransfer = false;
		// currentFile = null; // Keep this alive so FT:MSG can reference the filename
		// currentFilename = null;
		blockSequence = 0;

		sendDCCloseResponse(true, 0);
	}

	// --- RESPONSE HELPERS ---
	// Send DC_OPEN response
	private void sendDCOpenResponse(boolean success, int errorCode) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			if (success) {
				// Positive response
				baos.write(0x00); // Length MSB
				baos.write(0x05); // Length LSB
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_OPEN);
				baos.write(RESP_POSITIVE);
			} else {
				// Negative response
				baos.write(0x00); // Length MSB
				baos.write(0x09); // Length LSB
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_OPEN);
				baos.write(RESP_NEGATIVE);
				baos.write(0x69);
				baos.write(0x04);
				baos.write((byte) ((errorCode >> 8) & 0xFF));
				baos.write((byte) (errorCode & 0xFF));
			}

			byte[] response = baos.toByteArray();
			sendStructuredFieldResponse(response);

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// Send DC_CLOSE response
	private void sendDCCloseResponse(boolean success, int errorCode) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			if (success) {
				baos.write(0x00);
				baos.write(0x05);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_CLOSE);
				baos.write(RESP_POSITIVE);
			} else {
				baos.write(0x00);
				baos.write(0x09);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_CLOSE);
				baos.write(RESP_NEGATIVE);
				baos.write(0x69);
				baos.write(0x04);
				baos.write((byte) ((errorCode >> 8) & 0xFF));
				baos.write((byte) (errorCode & 0xFF));
			}

			sendStructuredFieldResponse(baos.toByteArray());

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// Send DC_INSERT response
	private void sendDCInsertResponse(boolean success, int errorCode) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			if (success) {
				baos.write(0x00);
				baos.write(0x0B);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_INSERT);
				baos.write(0x05);
				baos.write(0x63);
				baos.write(0x06);
				// Block sequence number (4 bytes)
				baos.write((byte) ((blockSequence >> 24) & 0xFF));
				baos.write((byte) ((blockSequence >> 16) & 0xFF));
				baos.write((byte) ((blockSequence >> 8) & 0xFF));
				baos.write((byte) (blockSequence & 0xFF));
			} else {
				baos.write(0x00);
				baos.write(0x09);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_INSERT);
				baos.write(RESP_NEGATIVE);
				baos.write(0x69);
				baos.write(0x04);
				baos.write((byte) ((errorCode >> 8) & 0xFF));
				baos.write((byte) (errorCode & 0xFF));
			}

			sendStructuredFieldResponse(baos.toByteArray());

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void sendResp(byte op, boolean ok, int err) {
		try {
			ByteArrayOutputStream b = new ByteArrayOutputStream();
			b.write(0);
			b.write(ok ? 5 : 9);
			b.write(SFID_DATA_CHAIN);
			b.write(op);
			b.write(ok ? RESP_POSITIVE : RESP_NEGATIVE);
			if (!ok) {
				b.write(0x69);
				b.write(4);
				b.write(0);
				b.write(0);
			}
			sendStructuredFieldResponse(b.toByteArray());
		} catch (Exception e) {
		}
	}

	// Send DC_GET response
	private void sendDCGetResponse(boolean success, int errorCode, byte[] data, int dataLen) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			if (success && data != null && dataLen > 0) {
				// Calculate lengths
				int dataLenField = dataLen + 5; // Data + overhead (C0 80 61 dd dd)
				int responseLen = 2 + 1 + 1 + 1 + 1 + 1 + 4 + 1 + 1 + 1 + 2 + dataLen;
				// That's: length(2) + SFID(1) + op(1) + header(3) + seq(4) + flags(3) +
				// datalen(2) + data

				baos.write((byte) ((responseLen >> 8) & 0xFF));
				baos.write((byte) (responseLen & 0xFF));
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_GET);
				baos.write(0x05);
				baos.write(0x63);
				baos.write(0x06);
				baos.write((byte) ((blockSequence >> 24) & 0xFF));
				baos.write((byte) ((blockSequence >> 16) & 0xFF));
				baos.write((byte) ((blockSequence >> 8) & 0xFF));
				baos.write((byte) (blockSequence & 0xFF));
				baos.write((byte) 0xC0);
				baos.write((byte) 0x80);
				baos.write((byte) 0x61);
				baos.write((byte) ((dataLenField >> 8) & 0xFF));
				baos.write((byte) (dataLenField & 0xFF));
				baos.write(data, 0, dataLen);
			} else {
				baos.write(0x00);
				baos.write(0x09);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_GET);
				baos.write(RESP_NEGATIVE);
				baos.write(0x69);
				baos.write(0x04);
				baos.write((byte) ((errorCode >> 8) & 0xFF));
				baos.write((byte) (errorCode & 0xFF));
			}

			sendStructuredFieldResponse(baos.toByteArray());

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// --- QUERY REPLY (Stripped for safety) ---
	private void sendQueryResponse() {
		try {
			ByteArrayOutputStream b = new ByteArrayOutputStream();
			if (tn3270eMode)
				b.write(new byte[] { 0, 0, 0, 0, 0 });
			b.write(0x88);
			b.write(new byte[] { 0, 6, (byte) 0x81, (byte) 0x80, (byte) 0x80, (byte) 0x81 }); // Minimal Summary
			b.write(new byte[] { 0, 14, (byte) 0x81, (byte) 0x81, 1, 0, 0, 80, 0, 24, 0, 0, 0, 0 }); // Minimal Usable
																										// Area
			// Add Data Chain support (0xB1) to Summary if needed for IND$FILE
			sendStructuredFieldResponse(b.toByteArray());
		} catch (Exception e) {
		}
	}

	private void sendStructuredFieldResponse(byte[] d) throws IOException {
		ByteArrayOutputStream b = new ByteArrayOutputStream();
		b.write(AID_STRUCTURED_FIELD);
		b.write(d);
		sendData(b.toByteArray());
	}

	// --- HELPERS ---
	private int decode3270Address(byte b1, byte b2) {
		int i = ((b1 & 0xFF) << 8) | (b2 & 0xFF);
		if ((b1 & 0xC0) != 0)
			i = ((b1 & 0x3F) << 6) | (b2 & 0x3F);
		return i % buffer.length;
	}

	private byte[] encode3270Address(int a) {
		a &= 0x3FFF;
		if (a >= 0x1000)
			return new byte[] { (byte) (a >> 8), (byte) a };
		return new byte[] { ADDRESS_TABLE[(a >> 6) & 0x3F], ADDRESS_TABLE[a & 0x3F] };
	}

	private void clearScreen() {
		Arrays.fill(buffer, ' ');
		Arrays.fill(attributes, (byte) 0);
		cursorPos = 0;
	}

	private void resetMDT() {
		for (int i = 0; i < attributes.length; i++)
			attributes[i] &= ~0x01;
	}

	private boolean isFieldStart(int p) {
		return p >= 0 && p < attributes.length && attributes[p] != 0;
	}

	private boolean isProtected(int p) {
		int s = findFieldStart(p);
		return s >= 0 && (attributes[s] & 0x20) != 0;
	}
	
	private boolean isNonDisplay(int p) {
        int s = findFieldStart(p);
        if (s < 0) return false; // Unformatted screen defaults to visible
        // Bits 2 and 3 (mask 0x0C) both set to 1 indicates Non-Display
        return (attributes[s] & 0x0C) == 0x0C;
    }

	private int findFieldStart(int p) {
		for (int i = 0; i < buffer.length; i++) {
			int x = (p - i + buffer.length) % buffer.length;
			if (attributes[x] != 0)
				return x;
		}
		return -1;
	}

	private void resetReplyModeToDefault() {
		currentReplyMode = ReplyMode.FIELD;
		replyModeFlags = 0;
		// System.out.println("Reply Mode reset to FIELD (default).");
	}

	public void toggleInsertMode() {
		insertMode = !insertMode;
		statusBar.update();
	}

	private void setModified(int pos) {
		int fieldStart = findFieldStart(pos);
		attributes[fieldStart] |= 0x01;
	}

	public void eraseToEndOfField() {
		if (isProtected(cursorPos))
			return;
		int e = findNextField(cursorPos);
		for (int i = cursorPos; i != e && !isFieldStart(i); i = (i + 1) % buffer.length)
			buffer[i] = '\0';
		canvas.repaint();
	}

	public void eraseToEndOfLine() {
		if (isProtected(cursorPos)) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		int row = cursorPos / cols;
		int endOfLine = (row + 1) * cols;
		int fieldStart = findFieldStart(cursorPos);
		int fieldEnd = findNextField(fieldStart);

		for (int i = cursorPos; i < endOfLine && i < fieldEnd && !isFieldStart(i); i++) {
			buffer[i] = '\0';
		}

		setModified(cursorPos);
		canvas.repaint();
		statusBar.update();
		// Don't lock keyboard - this is a local editing operation
	}

	public void tabToNextField() {
		int s = cursorPos;
		do {
			cursorPos = (cursorPos + 1) % buffer.length;
			if (isFieldStart(cursorPos) && !isProtected(cursorPos)) {
				cursorPos = (cursorPos + 1) % buffer.length;
				break;
			}
		} while (cursorPos != s);
		canvas.repaint();
	}

	private void tabToPreviousField() {
		int start = cursorPos;
		int count = 0;
		int maxSize = rows * cols;

		do {
			cursorPos = (cursorPos - 1 + rows * cols) % (rows * cols);
			count++;

			if (isFieldStart(cursorPos)) {
				// We're on a field attribute, check if the field itself is protected
				boolean fieldIsProtected = (attributes[cursorPos] & 0x20) != 0;

				if (!fieldIsProtected) {
					// Move to first position after the field attribute
					cursorPos = (cursorPos + 1) % (rows * cols);
					canvas.repaint();
					statusBar.update();
					return;
				}
			}
		} while (cursorPos != start && count < maxSize);

		// No unprotected field found, stay where we are
		cursorPos = start;
		canvas.repaint();
		statusBar.update();
	}

	private int findNextField(int p) {
		int n = (p + 1) % buffer.length;
		while (!isFieldStart(n) && n != p)
			n = (n + 1) % buffer.length;
		return n;
	}

	private void sendReadBuffer() {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			// baos.write(AID_ENTER);
			baos.write(lastAID); // Changed from AID_ENTER
			baos.write(encode3270Address(cursorPos)[0]);
			baos.write(encode3270Address(cursorPos)[1]);

			for (int i = 0; i < buffer.length; i++) {
				if (isFieldStart(i)) {
					baos.write(ORDER_SF);
					baos.write(attributes[i]);
				} else {
					char c = buffer[i];
					if (c == '\0') {
						baos.write(0x00);
					} else if (c < 256 && ASCII_TO_EBCDIC[c] != 0) {
						baos.write(ASCII_TO_EBCDIC[c]);
					} else {
						baos.write(0x40);
					}
				}
			}

			sendData(baos.toByteArray());
			keyboardLocked = true;
			statusBar.update();

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void eraseAllUnprotected() {
		for (int i = 0; i < buffer.length; i++)
			if (!isProtected(i))
				buffer[i] = '\0';
		canvas.repaint();
	}

	private boolean safeConsume(byte[] d, int i, int n) {
		return i + n <= d.length;
	}

	// --- Helper: fetchDisplayChar ---
	// Consumes 1 or 2 stream bytes (GE escape + operand) and returns the translated
	// display char.
	// idxRef is a single-element int[] containing the current index in data. This
	// method
	// will advance idxRef[0] by the number of bytes it consumes.
	private char fetchDisplayChar(byte[] data, int[] idxRef) {
		int i = idxRef[0];
		if (!safeConsume(data, i, 1)) {
			// truncated - return space and do not advance
			return ' ';
		}
		byte b = data[i];
		if (b == ORDER_GE) {
			System.out.println("GE order at offset " + i);
			// GE escape: require one more byte (the graphic operand)
			if (!safeConsume(data, i + 1, 1)) {
				// truncated GE -> treat as space, advance past GE byte to avoid loop
				idxRef[0] = i + 1;
				return ' ';
			}
			byte operand = data[i + 1];
			idxRef[0] = i + 2; // consumed GE + operand
			// Translate operand from EBCDIC->APL (table must exist in your code)
			return EBCDIC_TO_APL[operand & 0xFF];
		} else {
			// Normal single-byte display char (EBCDIC -> ASCII)
			idxRef[0] = i + 1; // consumed one byte
			return EBCDIC_TO_ASCII[b & 0xFF];
		}
	}

	// --- UI PROXIES ---
	public void showFileTransferDialog(boolean dl) {
		TN3270Emulator.showFileTransferDialogProxy(this, dl);
	}

	public void showColorSchemeDialog() {
		TN3270Emulator.showColorSchemeDialogProxy(this);
	}

	public void showFontSizeDialog() {
		TN3270Emulator.showFontSizeDialogProxy(this);
	}

	public void showKeyboardMappingDialog() {
		TN3270Emulator.showKeyboardMappingDialogProxy(this);
	}

	public void showTerminalSettingsDialog() {
		TN3270Emulator.showTerminalSettingsDialogProxy(this);
	}

	// Helper: Logic to change font size
	private void changeFontSize(int delta) {
		if (canvas == null)
			return;

		int currentSize = canvas.terminalFont.getSize();
		int newSize = currentSize + delta;

		if (newSize < 6)
			newSize = 6;
		if (newSize > 72)
			newSize = 72;

		if (newSize != currentSize) {
			canvas.terminalFont = new Font("Monospaced", Font.PLAIN, newSize);
			canvas.setFont(canvas.terminalFont);
			FontMetrics fm = canvas.getFontMetrics(canvas.terminalFont);
			canvas.charWidth = fm.charWidth('M');
			canvas.charHeight = fm.getHeight();

			canvas.updateSize();
			canvas.repaint();

			statusBar.setStatus("Font size set to " + newSize + "pt");
		}
	}

	public void copySelection() {
		if (selectionStart < 0 || selectionEnd < 0) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		int start = Math.min(selectionStart, selectionEnd);
		int end = Math.max(selectionStart, selectionEnd);

		StringBuilder sb = new StringBuilder();
		int startRow = start / cols;
		int endRow = end / cols;

		for (int row = startRow; row <= endRow; row++) {
			int rowStart = (row == startRow) ? start : row * cols;
			int rowEnd = (row == endRow) ? end : (row + 1) * cols - 1;

			for (int pos = rowStart; pos <= rowEnd && pos < buffer.length; pos++) {
				char c = buffer[pos];
				if (c == '\0')
					c = ' ';
				if (!isFieldStart(pos)) {
					sb.append(c);
				}
			}

			if (row < endRow) {
				sb.append('\n');
			}
		}

		String text = sb.toString();
		String[] lines = text.split("\n");
		StringBuilder cleaned = new StringBuilder();
		for (int i = 0; i < lines.length; i++) {
			cleaned.append(lines[i].replaceAll("\\s+$", ""));
			if (i < lines.length - 1) {
				cleaned.append('\n');
			}
		}

		try {
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			Clipboard clipboard = toolkit.getSystemClipboard();
			StringSelection selection = new StringSelection(cleaned.toString());
			clipboard.setContents(selection, null);

			statusBar.setStatus("Copied " + (end - start + 1) + " characters");
			clearSelection();

		} catch (Exception ex) {
			statusBar.setStatus("Copy failed: " + ex.getMessage());
			ex.printStackTrace();
		}
	}

	public void pasteFromClipboard() {
		if (keyboardLocked || !connected) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		try {
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			Clipboard clipboard = toolkit.getSystemClipboard();
			String text = (String) clipboard.getData(java.awt.datatransfer.DataFlavor.stringFlavor);

			if (text == null || text.isEmpty()) {
				return;
			}

			for (char c : text.toCharArray()) {
				if (c == '\n' || c == '\r') {
					tabToNextField();
					continue;
				}

				if (c < 32 || c > 126) {
					continue;
				}

				if (!isProtected(cursorPos)) {
					buffer[cursorPos] = c;
					setModified(cursorPos);

					int nextPos = (cursorPos + 1) % (rows * cols);
					moveCursor(1);

					if (isFieldStart(nextPos)) {
						tabToNextField();
					}
				} else {
					tabToNextField();

					if (!isProtected(cursorPos)) {
						buffer[cursorPos] = c;
						setModified(cursorPos);
						moveCursor(1);
					}
				}
			}

			canvas.repaint();
			statusBar.setStatus("Pasted " + text.length() + " characters");

		} catch (Exception ex) {
			statusBar.setStatus("Paste failed: " + ex.getMessage());
			ex.printStackTrace();
		}
	}

	public void selectAll() {
		selectionStart = 0;
		selectionEnd = buffer.length - 1;
		canvas.repaint();
	}

	private void handleMousePress(MouseEvent e) {
		int pos = screenPositionFromMouse(e.getX(), e.getY());
		if (pos >= 0 && pos < buffer.length) {
			selecting = true;
			selectionStart = pos;
			selectionEnd = pos;
			dragStart = e.getPoint();
			canvas.repaint();
		}
	}

	private void handleMouseDrag(MouseEvent e) {
		if (selecting) {
			int pos = screenPositionFromMouse(e.getX(), e.getY());
			if (pos >= 0 && pos < buffer.length) {
				selectionEnd = pos;
				canvas.repaint();
			}
		}
	}

	private void handleMouseRelease(MouseEvent e) {
		if (selecting) {
			selecting = false;
			// Normalize selection so start < end
			if (selectionStart > selectionEnd) {
				int temp = selectionStart;
				selectionStart = selectionEnd;
				selectionEnd = temp;
			}
		}
	}

	private void selectWord(MouseEvent e) {
		int pos = screenPositionFromMouse(e.getX(), e.getY());
		if (pos >= 0 && pos < buffer.length) {
			// Find word boundaries
			int start = pos;
			int end = pos;

			// Expand left
			while (start > 0 && isWordChar(buffer[start - 1])) {
				start--;
			}

			// Expand right
			while (end < buffer.length - 1 && isWordChar(buffer[end + 1])) {
				end++;
			}

			selectionStart = start;
			selectionEnd = end;
			canvas.repaint();
		}
	}

	private void selectLine(MouseEvent e) {
		int pos = screenPositionFromMouse(e.getX(), e.getY());
		if (pos >= 0 && pos < buffer.length) {
			int row = pos / cols;
			selectionStart = row * cols;
			selectionEnd = (row + 1) * cols - 1;
			canvas.repaint();
		}
	}

	private boolean isWordChar(char c) {
		return Character.isLetterOrDigit(c) || c == '_' || c == '-' || c == '.';
	}

	private int screenPositionFromMouse(int x, int y) {
		// 1. Calculate the same margins used in paintComponent
		int gridWidth = cols * canvas.charWidth;
		int gridHeight = rows * canvas.charHeight;

		// Calculate centering offsets based on current canvas size
		int marginLeft = Math.max(5, (canvas.getWidth() - gridWidth) / 2);
		int marginTop = Math.max(5, (canvas.getHeight() - gridHeight) / 2);

		// 2. Calculate Row/Col relative to those margins
		int col = (x - marginLeft) / canvas.charWidth;
		int row = (y - marginTop) / canvas.charHeight;

		// 3. Clamp values to screen bounds
		if (col < 0)
			col = 0;
		if (col >= cols)
			col = cols - 1;
		if (row < 0)
			row = 0;
		if (row >= rows)
			row = rows - 1;

		return row * cols + col;
	}

	/**
	 * Return the currently selected screen rectangle as text. The emulator stores
	 * the screen in a linear char[] buffer; this maps row/col -> index. Returns an
	 * empty string if nothing is selected.
	 */
	public String getSelectedText() {
		// If no selection or invalid selection, return empty
		if (selectionStart < 0 || selectionEnd < 0) {
			return "";
		}

		int start = Math.min(selectionStart, selectionEnd);
		int end = Math.max(selectionStart, selectionEnd);

		StringBuilder sb = new StringBuilder();

		// Iterate through the linear buffer
		for (int i = start; i <= end; i++) {
			char c = buffer[i];
			// Replace nulls with spaces
			if (c == '\0')
				c = ' ';

			sb.append(c);

			// If we hit the right edge of the screen, append a newline
			// (unless it's the very last character of the selection)
			if ((i + 1) % cols == 0 && i != end) {
				sb.append('\n');
			}
		}

		// Cleanup: formatting the text to look better for the AI
		// This removes trailing spaces from lines to make it cleaner
		String raw = sb.toString();
		StringBuilder clean = new StringBuilder();
		for (String line : raw.split("\n")) {
			clean.append(line.replaceAll("\\s+$", "")).append("\n");
		}

		return clean.toString().trim();
	}

	private void updateProgressDialog(String progress, String status) {
		SwingUtilities.invokeLater(() -> {
			if (progressLabel != null) {
				progressLabel.setText(progress);
			}
			// Fix: Use transferStatusLabel
			if (transferStatusLabel != null && status != null) {
				transferStatusLabel.setText(status);
			}
			// Optional: If you parse block numbers, you could update
			// transferProgressBar.setValue(pct) here.
		});
	}

	private void closeProgressDialog() {
		SwingUtilities.invokeLater(() -> {
			if (progressDialog != null) {
				progressDialog.dispose();
				progressDialog = null;
				transferProgressBar = null;
				progressLabel = null;
				transferStatusLabel = null;
				cancelTransferButton = null;
			}
		});
	}

	// KeyListener
	public void keyPressed(KeyEvent e) {
		int keyCode = e.getKeyCode();

		// --- Ignore Modifier Keys ---
		// If we don't return here, pressing Command/Ctrl (to start a shortcut)
		// will be treated as "any key press" and trigger clearSelection() immediately.
		if (keyCode == KeyEvent.VK_CONTROL || keyCode == KeyEvent.VK_META || keyCode == KeyEvent.VK_ALT
				|| keyCode == KeyEvent.VK_SHIFT) {
			return;
		}

		// Check for Control (Windows/Linux) or Meta (Command on macOS)
		boolean isModifier = e.isControlDown() || e.isMetaDown();

		// Handle Font Resizing
		if (isModifier) {
			// Increase Font: Ctrl+= or Ctrl+Add (Numpad +)
			if (e.getKeyCode() == KeyEvent.VK_EQUALS || e.getKeyCode() == KeyEvent.VK_ADD) {
				changeFontSize(2); // Increase by 2 points
				return;
			}
			// Decrease Font: Ctrl+- or Ctrl+Subtract (Numpad -)
			if (e.getKeyCode() == KeyEvent.VK_MINUS || e.getKeyCode() == KeyEvent.VK_SUBTRACT) {
				changeFontSize(-2); // Decrease by 2 points
				return;
			}
		}

		// Handle copy/paste shortcuts (Enhanced to support Mac Cmd key as well)
		if (isModifier) {
			if (e.getKeyCode() == KeyEvent.VK_C) {
				copySelection();
				return;
			} else if (e.getKeyCode() == KeyEvent.VK_V) {
				pasteFromClipboard();
				return;
			} else if (e.getKeyCode() == KeyEvent.VK_A) {
				selectAll();
				return;
			}
		}

		// Handle copy/paste shortcuts
		if (e.isControlDown()) {
			if (e.getKeyCode() == KeyEvent.VK_C) {
				copySelection();
				return;
			} else if (e.getKeyCode() == KeyEvent.VK_V) {
				pasteFromClipboard();
				return;
			} else if (e.getKeyCode() == KeyEvent.VK_A) {
				selectAll();
				return;
			}
		}

		// Clear selection on any key press (except copy/paste)
		if (selectionStart >= 0 || selectionEnd >= 0) {
			clearSelection();
		}

		// int keyCode = e.getKeyCode();

		// Handle navigation keys BEFORE the keyboard lock check
		switch (keyCode) {
		case KeyEvent.VK_LEFT:
			clearSelection();
			cursorPos = (cursorPos - 1 + buffer.length) % buffer.length;
			canvas.repaint();
			statusBar.update();
			return;

		case KeyEvent.VK_RIGHT:
			clearSelection();
			cursorPos = (cursorPos + 1) % buffer.length;
			canvas.repaint();
			statusBar.update();
			return;

		case KeyEvent.VK_UP:
			clearSelection();
			cursorPos = (cursorPos - cols + buffer.length) % buffer.length;
			canvas.repaint();
			statusBar.update();
			return;

		case KeyEvent.VK_DOWN:
			clearSelection();
			cursorPos = (cursorPos + cols) % buffer.length;
			canvas.repaint();
			statusBar.update();
			return;

		case KeyEvent.VK_HOME:
			clearSelection();
			cursorPos = 0;
			canvas.repaint();
			statusBar.update();
			return;
		}

		if (keyboardLocked || !connected) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		// Check for custom key mapping first
		KeyMapping mapping = keyMap.get(keyCode);
		if (mapping != null) {
			if (mapping.aid != null) {
				if ("EraseEOF".equals(mapping.description)) {
					eraseToEndOfField();
					return;
				}

				// Mapped to AID function
				sendAID(mapping.aid);
				return;
			} else {
				// Mapped to character - handle in keyTyped
				// (let it fall through)
			}
		}

		// Handle function keys with explicit mapping
		if (keyCode >= KeyEvent.VK_F1 && keyCode <= KeyEvent.VK_F12) {
			byte aid;
			switch (keyCode) {
			case KeyEvent.VK_F1:
				aid = AID_PF1;
				break;
			case KeyEvent.VK_F2:
				aid = AID_PF2;
				break;
			case KeyEvent.VK_F3:
				aid = AID_PF3;
				break;
			case KeyEvent.VK_F4:
				aid = AID_PF4;
				break;
			case KeyEvent.VK_F5:
				aid = AID_PF5;
				break;
			case KeyEvent.VK_F6:
				aid = AID_PF6;
				break;
			case KeyEvent.VK_F7:
				aid = AID_PF7;
				break;
			case KeyEvent.VK_F8:
				aid = AID_PF8;
				break;
			case KeyEvent.VK_F9:
				aid = AID_PF9;
				break;
			case KeyEvent.VK_F10:
				aid = AID_PF10;
				break;
			case KeyEvent.VK_F11:
				aid = AID_PF11;
				break;
			case KeyEvent.VK_F12:
				aid = AID_PF12;
				break;
			default:
				return;
			}

			sendAID(aid);
			return;
		}

		switch (keyCode) {
		case KeyEvent.VK_ESCAPE:
			clearScreen();
			sendAID(AID_CLEAR);
			canvas.repaint();
			return;
		/*
		 * case KeyEvent.VK_ENTER: sendAID(AID_ENTER); return;
		 */
		case KeyEvent.VK_ENTER:
			// Feature: If text is selected, ENTER sends it to AI immediately
			if (selectionStart >= 0 && selectionEnd >= 0 && selectionStart != selectionEnd) {
				String selectedText = getSelectedText();
				if (selectedText != null && !selectedText.trim().isEmpty()) {
					e.consume();
					// Pass 'true' for autoSend
					AIManager.getInstance().showChatDialog(getParentFrame(), selectedText, true);
					clearSelection(); // Clear selection after sending
					return;
				}
			}
			// Otherwise, standard behavior (Send AID to Host)
			sendAID(AID_ENTER);
			return;

		case KeyEvent.VK_INSERT:
			insertMode = !insertMode;
			statusBar.update();
			canvas.repaint();
			return;

		case KeyEvent.VK_TAB:
			if (e.isShiftDown()) {
				tabToPreviousField();
			} else {
				tabToNextField();
			}
			return;

		case KeyEvent.VK_BACK_SPACE:
			if (!isProtected(cursorPos)) {
				moveCursor(-1);
				if (!isProtected(cursorPos)) {
					buffer[cursorPos] = ' ';
					setModified(cursorPos);
					canvas.repaint();
				}
			}
			return;
		}
	}

	public void keyTyped(KeyEvent e) {
		// System.out.println("keyTyped: locked=" + keyboardLocked +
		// " connected=" + connected +
		// " cursorPos=" + cursorPos +
		// " isProtected=" + isProtected(cursorPos) +
		// " isFieldStart=" + isFieldStart(cursorPos) +
		// " char='" + e.getKeyChar() + "' (" + (int)e.getKeyChar() + ")" +
		// " insertMode=" + insertMode);

		if (keyboardLocked || !connected)
			return;

		char c = e.getKeyChar();

		// 1. Check for Physical Key Override
		KeyMapping mapping = keyMap.get(e.getKeyCode());
		if (mapping != null && mapping.aid == null) {
			c = mapping.character;
		}

		// 2. Apply Character Translation
		// If the character exists in our map (e.g. '¦'), replace it. Otherwise keep
		// 'c'.
		c = inputCharMap.getOrDefault(c, c);

		if (c < 32 || c > 126)
			return;

		if (!isProtected(cursorPos)) {
			if (insertMode) {
				int fieldStart = findFieldStart(cursorPos);
				int fieldEnd = findNextField(fieldStart);

				int lastPos = fieldEnd - 1;
				if (isFieldStart(lastPos))
					lastPos--;

				char lastChar = buffer[lastPos];
				if (lastChar != '\0' && lastChar != ' ') {
					if (enableSound)
						Toolkit.getDefaultToolkit().beep();
					return;
				}

				// Shift characters right
				for (int i = lastPos; i > cursorPos; i--) {
					if (!isFieldStart(i) && !isFieldStart(i - 1)) {
						buffer[i] = buffer[i - 1];
					}
				}
			}

			// Common code for both insert and replace modes
			buffer[cursorPos] = c;
			setModified(cursorPos);

			// Check if we need to auto-advance BEFORE moving cursor
			int nextPos = (cursorPos + 1) % (rows * cols);
			moveCursor(1);

			// Only auto-advance if the NEXT position is a field boundary
			if (autoAdvance && isFieldStart(nextPos)) {
				tabToNextField();
			}

			canvas.repaint();
		} else {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
		}
	}

	public void keyReleased(KeyEvent e) {
	}

	private void moveCursor(int delta) {
		cursorPos = (cursorPos + delta + buffer.length) % buffer.length;
		canvas.repaint();
		statusBar.update();
	}

	private void clearSelection() {
		selectionStart = -1;
		selectionEnd = -1;
		canvas.repaint();
	}

	// Inner Classes
	class TerminalCanvas extends JPanel {
		// Class-level fields allow us to sync Sizing and Painting
		private Font terminalFont;
		private int charWidth;
		private int charHeight;
		private int charAscent;

		// Flag to prevent infinite layout loops
		private boolean isUpdatingSize = false;

		public TerminalCanvas() {
			// Default setup
			terminalFont = new Font("Monospaced", Font.PLAIN, 14);

			// --- CRITICAL SWING SETTINGS ---
			setFocusable(true);
			setFocusTraversalKeysEnabled(false); // Keeps TAB key for the emulator
			setDoubleBuffered(true);
			setBackground(Color.BLACK);
			// -------------------------------

			// Forward Scroll Wheel events to the parent ScrollPane
			addMouseWheelListener(e -> {
				Container parent = getParent();
				while (parent != null) {
					if (parent instanceof JScrollPane) {
						JScrollPane sp = (JScrollPane) parent;
						sp.dispatchEvent(SwingUtilities.convertMouseEvent(this, e, sp));
						break;
					}
					parent = parent.getParent();
				}
			});

			// Calculate initial metrics
			updateSize();

			// Mouse Listeners
			addMouseListener(new MouseAdapter() {
				public void mousePressed(MouseEvent e) {
					requestFocusInWindow(); // Grab focus on click
					if (e.isPopupTrigger() || SwingUtilities.isRightMouseButton(e)) {
						String text = TN3270Session.this.getSelectedText();
						AIManager.getInstance().showChatDialog(getParentFrame(), text);
						return;
					}
					handleMousePress(e);
				}

				public void mouseReleased(MouseEvent e) {
					if (e.isPopupTrigger() || SwingUtilities.isRightMouseButton(e)) {
						String text = TN3270Session.this.getSelectedText();
						AIManager.getInstance().showChatDialog(getParentFrame(), text);
						return;
					}
					handleMouseRelease(e);
				}

				public void mouseClicked(MouseEvent e) {
					if (e.getClickCount() == 2)
						selectWord(e);
					else if (e.getClickCount() == 3)
						selectLine(e);
				}
			});

			addMouseMotionListener(new MouseMotionAdapter() {
				public void mouseDragged(MouseEvent e) {
					handleMouseDrag(e);
				}
			});
		}

		/**
		 * Calculates the font size and sets the PreferredSize of the panel. This
		 * controls when ScrollBars appear.
		 */
		public void updateSize() {
			if (isUpdatingSize)
				return; // Prevent recursion
			isUpdatingSize = true;

			try {
				// 1. Get robust metrics
				// We try to get metrics from the screen graphics if available,
				// otherwise fallback to the Toolkit default.
				FontMetrics fm;
				Graphics g = getGraphics();
				if (g != null) {
					fm = g.getFontMetrics(terminalFont);
					g.dispose();
				} else {
					// fm = Toolkit.getDefaultToolkit().getFontMetrics(terminalFont);
					fm = this.getFontMetrics(terminalFont);
				}

				// 2. Update Class-Level fields
				// This ensures paintComponent uses THESE EXACT VALUES
				this.charWidth = fm.charWidth('M');
				this.charHeight = fm.getHeight();
				this.charAscent = fm.getAscent();

				// 3. Calculate Dimensions with Safety Padding
				// +24 gives room for window borders and scrollbars
				int w = (cols * this.charWidth) + 24;
				int h = (rows * this.charHeight) + 24;

				setPreferredSize(new Dimension(w, h));

				// 4. Update Scroll Speeds (User Experience)
				Container parent = getParent();
				if (parent instanceof JViewport && parent.getParent() instanceof JScrollPane) {
					JScrollPane sp = (JScrollPane) parent.getParent();
					sp.getVerticalScrollBar().setUnitIncrement(this.charHeight);
					sp.getHorizontalScrollBar().setUnitIncrement(this.charWidth);
				}

				// 5. Apply
				revalidate();
				repaint();

				// 6. Resize Window (Only if not maximized)
				Window win = SwingUtilities.getWindowAncestor(this);
				if (win != null && (win instanceof Frame)) {
					Frame f = (Frame) win;
					if ((f.getExtendedState() & Frame.MAXIMIZED_BOTH) == 0) {
						f.pack();
					}
				}
			} finally {
				isUpdatingSize = false;
			}
		}

		@Override
		public void setFont(Font f) {
			super.setFont(f);
			this.terminalFont = f;
			// Recalculate size whenever font changes
			updateSize();
		}

		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g); // Clears background to Black

			// Apply the font
			g.setFont(terminalFont);

			// Do NOT calculate font metrics here.
			// Use 'this.charWidth' and 'this.charHeight' calculated in updateSize().
			// This guarantees the text grid matches the scrollable area exactly.

			boolean blinkVisible = (System.currentTimeMillis() / 500) % 2 == 0;

			// Calculate Centering Offsets ---
			// Determine the total size of the text grid in pixels
			int gridWidth = cols * this.charWidth;
			int gridHeight = rows * this.charHeight;

			// Calculate margins to center the grid
			// Math.max(5, ...) ensures we never draw off the top-left edge
			// if the window is shrunk too small.
			int marginLeft = Math.max(5, (getWidth() - gridWidth) / 2);
			int marginTop = Math.max(5, (getHeight() - gridHeight) / 2);

			for (int row = 0; row < rows; row++) {
				for (int col = 0; col < cols; col++) {
					int pos = row * cols + col;
					char c = buffer[pos];

					// Standard 3270 Hidden Field logic
					if (TN3270Session.this.isNonDisplay(pos) && !TN3270Session.this.isFieldStart(pos))
						continue;
					if (attributes[pos] != 0)
						c = ' ';
					else if (c == '\0')
						c = ' ';

					// Colors
					Color fg = defaultForeground;
					Color bg = screenBackground;
					boolean reverseVideo = false;
					boolean blink = false;
					boolean underscore = false;

					// Selection
					boolean isSelected = false;
					if (selectionStart >= 0 && selectionEnd >= 0) {
						int start = Math.min(selectionStart, selectionEnd);
						int end = Math.max(selectionStart, selectionEnd);
						isSelected = (pos >= start && pos <= end);
					}

					// Attributes
					byte highlight = highlighting[pos];
					if (highlight == 0 && attributes[pos] == 0) {
						int fieldStart = findFieldStart(pos);
						if (fieldStart >= 0)
							highlight = highlighting[fieldStart];
					}

					if (attributes[pos] == 0) {
						if (highlight == (byte) 0xF2)
							reverseVideo = true;
						else if (highlight == (byte) 0xF1)
							blink = true;
						else if (highlight == (byte) 0xF4)
							underscore = true;
					}

					// Extended Colors
					if (extendedColors[pos] > 0 && extendedColors[pos] < colors.length) {
						fg = colors[extendedColors[pos]];
					} else {
						int fieldStart = findFieldStart(pos);
						if (fieldStart >= 0) {
							if (extendedColors[fieldStart] > 0 && extendedColors[fieldStart] < colors.length) {
								fg = colors[extendedColors[fieldStart]];
							} else {
								byte attr = attributes[fieldStart];
								boolean isProtected = (attr & 0x20) != 0;
								boolean isIntensified = (attr & 0x08) != 0;
								if ((attr & 0x0C) == 0x0C)
									fg = bg;
								else if (isProtected)
									fg = isIntensified ? Color.WHITE : Color.CYAN;
								else
									fg = isIntensified ? Color.WHITE : Color.GREEN;
							}
						}
					}

					// --- DRAWING COORDINATES ---

					// Use calculated margins
					int cellTop = marginTop + (row * this.charHeight);
					int x = marginLeft + (col * this.charWidth);

					// Use Ascent to position text baseline perfectly within the cell
					int y = cellTop + this.charAscent;

					if (isSelected) {
						Color temp = fg;
						fg = Color.WHITE;
						bg = new Color(0, 120, 215);
					} else if (reverseVideo) {
						Color temp = fg;
						fg = bg;
						bg = temp;
					}

					if (!bg.equals(screenBackground)) {
						g.setColor(bg);
						g.fillRect(x, cellTop, this.charWidth, this.charHeight);
					}

					if (blink && !blinkVisible)
						continue;

					g.setColor(fg);
					g.drawString(String.valueOf(c), x, y);

					if (underscore) {
						// Draw underscore at the baseline + 2 pixels (for a little separation between
						// characters and underline)
						g.drawLine(x, y + 2, x + this.charWidth, y + 2);
					}
				}
			}

			// Draw Cursor
			if (!keyboardLocked) {
				int row = cursorPos / cols;
				int col = cursorPos % cols;
				// int x = 5 + col * this.charWidth;
				// int y = 5 + row * this.charHeight;
				int x = marginLeft + col * this.charWidth;
				int y = marginTop + row * this.charHeight;

				g.setColor(cursorColor);

				switch (cursorStyle) {
				case BLOCK:
					g.fillRect(x, y, this.charWidth, this.charHeight);
					g.setXORMode(screenBackground);
					break;
				case UNDERSCORE:
					g.fillRect(x, y + this.charHeight - 2, this.charWidth, 2);
					break;
				case I_BEAM:
					g.fillRect(x, y, 2, this.charHeight);
					break;
				}
				g.setPaintMode();
			}
		}

		// ... (Keep existing getters for font/width/height if needed) ...
		public Font getTerminalFont() {
			return terminalFont;
		}

		public int getCharWidth() {
			return charWidth;
		}

		public int getCharHeight() {
			return charHeight;
		}
	}

	class StatusBar extends javax.swing.JPanel {
		private javax.swing.JLabel statusLabel;
		private javax.swing.JLabel ipLabel;
		private javax.swing.JLabel positionLabel;

		public StatusBar() {
			setLayout(new BorderLayout());
			setBackground(Color.DARK_GRAY);
			setBorder(new javax.swing.border.EmptyBorder(2, 5, 2, 5)); // Add internal padding

			// LEFT: Connection Status / Messages
			statusLabel = new javax.swing.JLabel("Not connected");
			statusLabel.setForeground(Color.WHITE);
			statusLabel.setFont(new Font("SansSerif", Font.PLAIN, 12));
			add(statusLabel, BorderLayout.WEST);

			// RIGHT: Container for IP and Position
			javax.swing.JPanel rightPanel = new javax.swing.JPanel(new FlowLayout(FlowLayout.RIGHT, 15, 0));
			rightPanel.setOpaque(false); // Transparent background to match parent

			// 1. IP Address Label
			ipLabel = new javax.swing.JLabel("");
			ipLabel.setForeground(new Color(200, 200, 200)); // Slightly dimmer than white
			ipLabel.setFont(new Font("SansSerif", Font.PLAIN, 11));
			rightPanel.add(ipLabel);

			// 2. Cursor Position Label
			positionLabel = new javax.swing.JLabel("Row: 01 Col: 01");
			positionLabel.setForeground(Color.WHITE);
			// Monospaced ensures the label doesn't jitter when numbers change width
			positionLabel.setFont(new Font("Monospaced", Font.BOLD, 12));
			rightPanel.add(positionLabel);

			add(rightPanel, BorderLayout.EAST);
		}

		public void setStatus(String status) {
			statusLabel.setText(status);
		}

		/**
		 * Smartly sets the IP. Truncates long IPv6 addresses visually but keeps full
		 * address in tooltip.
		 */
		public void setIP(String ip) {
			if (ip == null || ip.isEmpty()) {
				ipLabel.setText("");
				ipLabel.setToolTipText(null);
				return;
			}

			String displayIP = ip;

			// If IPv6 (contains ':') and is long, truncate visually
			if (ip.contains(":") && ip.length() > 20) {
				// Show start...end
				displayIP = ip.substring(0, 8) + "..." + ip.substring(ip.length() - 4);
				// Set the tool tip to the FULL address
				ipLabel.setToolTipText("Remote IP: " + ip);
			} else {
				ipLabel.setToolTipText(null);
			}

			// Add brackets for clarity
			ipLabel.setText("[" + displayIP + "]");
		}

		public void update() {
			// Calculate 1-based coordinates
			int row = (cursorPos / cols) + 1;
			int col = (cursorPos % cols) + 1;
			positionLabel.setText(String.format("Row: %02d Col: %02d", row, col));
		}
	}

	// AI
	/* -------------------- AIManager -------------------- */
	public static class AIManager {
		private static AIManager instance;
		private AIConfig config;
		private AIModelProvider provider;
		private AIChatWindow activeWindow;

		private AIManager() {
			config = new AIConfig("ai.conf");
		}

		public static synchronized AIManager getInstance() {
			if (instance == null)
				instance = new AIManager();
			return instance;
		}

		public void reloadConfig() {
			config.load();
			provider = null;
		}

		public AIModelProvider resolveProvider() {
			if (provider != null)
				return provider;

			String prov = config.getProvider();

			if ("ollama".equalsIgnoreCase(prov)) {
				String endpoint = config.get("ai.endpoint", "http://localhost:11434");
				provider = new OllamaProvider(endpoint, config.getModels());
			} else if ("google".equalsIgnoreCase(prov)) {
				// Google offers an OpenAI-compatible endpoint at this specific URL
				String googleEndpoint = "https://generativelanguage.googleapis.com/v1beta/openai/chat/completions";

				// We can reuse the OpenAIProvider logic exactly as-is!
				provider = new OpenAIProvider(config.getApiKey(), config.getModels(), googleEndpoint);
			} else {
				// Default to official OpenAI
				provider = new OpenAIProvider(config.getApiKey(), config.getModels());
			}
			return provider;
		}

		// Update signature to accept autoSend
		public void showChatDialog(Frame owner, String selectedText) {
			showChatDialog(owner, selectedText, false);
		}

		public void showChatDialog(Frame owner, String selectedText, boolean autoSend) {
			if (activeWindow != null && activeWindow.isVisible()) {
				activeWindow.toFront();
				activeWindow.showWithPrefill(selectedText, config.get("ai.prompt.default", ""), autoSend);
				return;
			}
			AIModelProvider prov = resolveProvider();
			AIChatWindow w = new AIChatWindow(owner, prov, config);
			this.activeWindow = w;
			w.showWithPrefill(selectedText, config.get("ai.prompt.default", ""), autoSend);
		}
	}
	/* ---------------- end AIManager ---------------- */

	/* ---------------------- OllamaProvider ---------------------- */
	public static class OllamaProvider implements AIModelProvider {

		private final String endpoint;
		private final String[] models;

		public OllamaProvider(String endpoint, String[] models) {
			// Ensure endpoint doesn't end with a slash, and default to standard Ollama port
			// if not specified
			this.endpoint = (endpoint != null && !endpoint.isEmpty()) ? endpoint.replaceAll("/+$", "")
					: "http://localhost:11434";

			// Default to generic llama3 if no models specified
			this.models = (models == null || models.length == 0) ? new String[] { "llama3", "mistral" } : models;
		}

		@Override
		public String[] listModels() {
			return models;
		}

		@Override
		public String send(String model, String prompt, String context) throws Exception {
			// Non-streaming request
			return doRequest(model, prompt, context, false, null);
		}

		@Override
		public void sendStream(String model, String prompt, String context, Consumer<String> onChunk,
				Consumer<Exception> onError, Runnable onComplete) throws Exception {
			try {
				doRequest(model, prompt, context, true, onChunk);
				onComplete.run();
			} catch (Exception e) {
				onError.accept(e);
				onComplete.run();
			}
		}

		private String doRequest(String model, String prompt, String context, boolean stream, Consumer<String> onChunk)
				throws Exception {

			// Combine context and prompt
			String fullPrompt = (context != null && !context.isEmpty()) ? context + "\n\n" + prompt : prompt;

			// Build JSON Payload for Ollama /api/chat
			// Format: { "model": "...", "messages": [ { "role": "user", "content": "..." }
			// ], "stream": bool }
			StringBuilder json = new StringBuilder();
			json.append("{");
			json.append("\"model\": \"").append(jsonEscape(model)).append("\",");
			json.append("\"stream\": ").append(stream).append(",");
			json.append("\"messages\": [");
			json.append("{ \"role\": \"user\", \"content\": \"").append(jsonEscape(fullPrompt)).append("\" }");
			json.append("]");
			json.append("}");

			// Construct URL (Ollama Chat Endpoint)
			URL url = new URI(endpoint + "/api/chat").toURL();

			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod("POST");
			conn.setDoOutput(true);
			conn.setConnectTimeout(5000); // 5s connection timeout (local network is fast)
			conn.setReadTimeout(stream ? 0 : 120000); // Infinite read for stream, 2m for block

			conn.setRequestProperty("Content-Type", "application/json");

			try (OutputStream os = conn.getOutputStream()) {
				os.write(json.toString().getBytes(StandardCharsets.UTF_8));
				os.flush();
			}

			int code = conn.getResponseCode();
			InputStream in = (code < 300) ? conn.getInputStream() : conn.getErrorStream();

			if (code >= 300) {
				try (BufferedReader r = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					StringBuilder err = new StringBuilder();
					String line;
					while ((line = r.readLine()) != null)
						err.append(line);
					throw new IOException("Ollama Error " + code + ": " + err.toString());
				}
			}

			// Handle Response
			if (stream && onChunk != null) {
				try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = reader.readLine()) != null) {
						// Ollama sends distinct JSON objects per line
						String content = extractOllamaContent(line);
						if (content != null && !content.isEmpty()) {
							onChunk.accept(content);
						}
					}
				}
				return "";
			} else {
				StringBuilder fullResponse = new StringBuilder();
				try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = reader.readLine()) != null) {
						// Even in non-stream mode, Ollama might send NDJSON or a single JSON
						// Adaptable parsing:
						String content = extractOllamaContent(line);
						if (content != null)
							fullResponse.append(content);
					}
				}
				return fullResponse.toString();
			}
		}

		// Helper to extract content from Ollama's JSON response
		// format: { "model": "...", "message": { "role": "assistant", "content":
		// "actual text" }, "done": false }
		private String extractOllamaContent(String json) {
			String marker = "\"content\":\"";
			int start = json.indexOf(marker);
			if (start < 0)
				return null;
			start += marker.length();

			// Simple parser to find the closing quote, handling escaped quotes
			StringBuilder sb = new StringBuilder();
			boolean escaped = false;
			for (int i = start; i < json.length(); i++) {
				char c = json.charAt(i);
				if (escaped) {
					if (c == 'n')
						sb.append('\n');
					else if (c == 'r')
						sb.append('\r');
					else if (c == 't')
						sb.append('\t');
					else
						sb.append(c);
					escaped = false;
				} else {
					if (c == '\\') {
						escaped = true;
					} else if (c == '"') {
						break; // End of string
					} else {
						sb.append(c);
					}
				}
			}
			return sb.toString();
		}

		private String jsonEscape(String s) {
			if (s == null)
				return "";
			StringBuilder sb = new StringBuilder();
			for (char c : s.toCharArray()) {
				switch (c) {
				case '\\':
					sb.append("\\\\");
					break;
				case '"':
					sb.append("\\\"");
					break;
				case '\b':
					sb.append("\\b");
					break;
				case '\f':
					sb.append("\\f");
					break;
				case '\n':
					sb.append("\\n");
					break;
				case '\r':
					sb.append("\\r");
					break;
				case '\t':
					sb.append("\\t");
					break;
				default:
					if (c < 0x20)
						sb.append(String.format("\\u%04x", (int) c));
					else
						sb.append(c);
				}
			}
			return sb.toString();
		}
	}
	/* ---------------------- End OllamaProvider ---------------------- */

	/* ---------------------- AIModelProvider ---------------------- */
	public interface AIModelProvider {
		String[] listModels();

		String send(String model, String prompt, String context) throws Exception;

		// default streaming fallback: call send() and deliver as single chunk
		default void sendStream(String model, String prompt, String context, Consumer<String> onChunk,
				Consumer<Exception> onError, Runnable onComplete) throws Exception {
			try {
				String r = send(model, prompt, context);
				onChunk.accept(r);
				onComplete.run();
			} catch (Exception ex) {
				onError.accept(ex);
				onComplete.run();
			}
		}
	}
	/* -------------------- end AIModelProvider -------------------- */

	/* ---------------------- OpenAIProvider ---------------------- */
	public static class OpenAIProvider implements AIModelProvider {

		private final String apiKey;
		private final String[] models;
		private final String endpoint;

		public OpenAIProvider(String apiKey, String[] models) {
			this(apiKey, models, "https://api.openai.com/v1/chat/completions");
		}

		public OpenAIProvider(String apiKey, String[] models, String endpoint) {
			this.apiKey = apiKey;
			this.models = models == null ? new String[0] : models;
			this.endpoint = endpoint != null ? endpoint : "https://api.openai.com/v1/chat/completions";
		}

		@Override
		public String[] listModels() {
			return models;
		}

		@Override
		public String send(String model, String prompt, String context) throws Exception {
			// Non-streaming fallback
			return doRequest(model, prompt, context, false, null);
		}

		@Override
		public void sendStream(String model, String prompt, String context, Consumer<String> onChunk,
				Consumer<Exception> onError, Runnable onComplete) throws Exception {
			try {
				doRequest(model, prompt, context, true, onChunk);
				onComplete.run();
			} catch (Exception e) {
				onError.accept(e);
				onComplete.run();
			}
		}

		private String doRequest(String model, String prompt, String context, boolean stream, Consumer<String> onChunk)
				throws Exception {
			String fullContext = (context == null ? "" : context + "\n\n");
			String fullContent = fullContext + (prompt == null ? "" : prompt);

			byte[] payloadBytes = buildPayloadBytes(model, fullContent, stream);

			// FIX: new URL(String) is deprecated. Use URI.create().toURL() instead.
			URL url = new URI(endpoint).toURL();

			HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
			conn.setRequestMethod("POST");
			conn.setDoOutput(true);
			conn.setConnectTimeout(15000);

			// If streaming, we read indefinitely; otherwise 60s timeout
			conn.setReadTimeout(stream ? 0 : 60000);

			conn.setRequestProperty("Content-Type", "application/json");
			conn.setRequestProperty("Authorization", "Bearer " + apiKey);

			try (OutputStream os = conn.getOutputStream()) {
				os.write(payloadBytes);
				os.flush();
			}

			int code = conn.getResponseCode();
			InputStream in = (code < 300) ? conn.getInputStream() : conn.getErrorStream();

			if (code >= 300) {
				StringBuilder sb = new StringBuilder();
				try (BufferedReader r = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = r.readLine()) != null)
						sb.append(line);
				}
				String json = sb.toString();
				String errorMsg = extractJsonField(json, "message");
				if (errorMsg.isEmpty())
					errorMsg = "API Error " + code + ": " + json;
				throw new IOException(errorMsg);
			}

			if (stream && onChunk != null) {
				try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = reader.readLine()) != null) {
						if (line.startsWith("data: ")) {
							String data = line.substring(6).trim();
							if ("[DONE]".equals(data))
								break;
							String chunk = extractJsonField(data, "content");
							if (!chunk.isEmpty()) {
								onChunk.accept(chunk);
							}
						}
					}
				}
				return "";
			} else {
				StringBuilder sb = new StringBuilder();
				try (BufferedReader r = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = r.readLine()) != null)
						sb.append(line).append('\n');
				}
				String json = sb.toString();
				return extractJsonField(json, "content");
			}
		}

		private byte[] buildPayloadBytes(String model, String content, boolean stream) {
			StringBuilder sb = new StringBuilder();
			sb.append("{");
			sb.append("\"model\":").append(jsonEscape(model)).append(",");
			sb.append("\"stream\":").append(stream).append(","); // IMPORTANT: Enable streaming
			sb.append("\"messages\":[");
			sb.append("{\"role\":\"system\",\"content\":")
					.append(jsonEscape("You are assisting a TN3270 mainframe user.")).append("},");
			sb.append("{\"role\":\"user\",\"content\":").append(jsonEscape(content)).append("}");
			sb.append("]}");
			return sb.toString().getBytes(StandardCharsets.UTF_8);
		}

		// Improved JSON value extractor that handles escaped quotes
		private String extractJsonField(String json, String key) {
			String search = "\"" + key + "\"";
			int startIdx = json.lastIndexOf(search); // Use lastIndexOf to find deeply nested content/message
			if (startIdx < 0)
				return "";

			// Find the colon after the key
			int colonIdx = json.indexOf(':', startIdx + search.length());
			if (colonIdx < 0)
				return "";

			// Find the opening quote of the value
			int valueStart = json.indexOf('"', colonIdx + 1);
			if (valueStart < 0)
				return "";

			// Find closing quote, skipping escaped quotes \"
			int valueEnd = valueStart + 1;
			while (valueEnd < json.length()) {
				char c = json.charAt(valueEnd);
				if (c == '\\') {
					valueEnd += 2; // Skip escaped char
					continue;
				}
				if (c == '"') {
					break; // Found end
				}
				valueEnd++;
			}

			if (valueEnd >= json.length())
				return "";

			String content = json.substring(valueStart + 1, valueEnd);

			// Unescape common JSON sequences
			return content.replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t").replace("\\\"", "\"")
					.replace("\\\\", "\\");
		}

		private String jsonEscape(String s) {
			if (s == null)
				return "\"\"";
			StringBuilder sb = new StringBuilder("\"");
			for (char c : s.toCharArray()) {
				switch (c) {
				case '\\':
					sb.append("\\\\");
					break;
				case '"':
					sb.append("\\\"");
					break;
				case '\b':
					sb.append("\\b");
					break;
				case '\f':
					sb.append("\\f");
					break;
				case '\n':
					sb.append("\\n");
					break;
				case '\r':
					sb.append("\\r");
					break;
				case '\t':
					sb.append("\\t");
					break;
				default:
					if (c < 0x20 || c > 0x7f)
						sb.append(String.format("\\u%04x", (int) c));
					else
						sb.append(c);
				}
			}
			sb.append('"');
			return sb.toString();
		}
	}
	/* -------------------- end OpenAIProvider -------------------- */

	/* ---------------------- AIConfig ---------------------- */
	public static class AIConfig {
		private final Properties props = new Properties();
		private final File file;

		public AIConfig(String path) {
			this.file = new File(path);
			load();
		}

		public void load() {
			try {
				props.clear();
				if (file.exists())
					try (FileInputStream fis = new FileInputStream(file)) {
						props.load(fis);
					}
			} catch (Exception e) {
				System.err.println("AIConfig.load: " + e.getMessage());
			}
		}

		public String get(String key, String def) {
			return props.getProperty(key, def);
		}

		public boolean getBoolean(String key, boolean def) {
			String v = props.getProperty(key);
			if (v == null)
				return def;
			return "true".equalsIgnoreCase(v) || "1".equals(v);
		}

		public String[] getModels() {
			String m = props.getProperty("ai.models");
			if (m == null)
				return new String[] { "gpt-4o-mini", "gpt-4o" };
			return Arrays.stream(m.split(",")).map(String::trim).filter(s -> !s.isEmpty()).toArray(String[]::new);
		}

		public String getProvider() {
			return props.getProperty("ai.provider", "openai");
		}

		public String getApiKey() {
			return props.getProperty("ai.apiKey", "");
		}

		public String getEndpoint() {
			return props.getProperty("ai.endpoint", "http://localhost:11434");
		}

		public void put(String k, String v) {
			props.setProperty(k, v);
		}

		public void save() throws IOException {
			try (FileOutputStream fos = new FileOutputStream(file)) {
				props.store(fos, "ai.conf");
			}
		}

		public File file() {
			return file;
		}

		public Properties props() {
			return props;
		}
	}
	/* -------------------- end AIConfig -------------------- */

	/* -------------------- AIHistoryStore -------------------- */
	public static class AIHistoryStore {
		private final File dir;

		public AIHistoryStore(String dirPath) {
			this.dir = new File(dirPath);
			if (!this.dir.exists())
				this.dir.mkdirs();
		}

		public File save(String json, String baseName) {
			try {
				long ts = System.currentTimeMillis();
				String name = baseName.replaceAll("[^A-Za-z0-9_.-]", "_") + "_" + ts + ".json";
				File out = new File(dir, name);
				try (FileWriter fw = new FileWriter(out)) {
					fw.write(json);
					fw.flush();
				}
				return out;
			} catch (Exception e) {
				System.err.println("AIHistoryStore.save: " + e.getMessage());
				return null;
			}
		}

		public File[] listFiles() {
			File[] files = dir.listFiles((d, n) -> n.endsWith(".json"));
			if (files == null)
				return new File[0];
			Arrays.sort(files, (a, b) -> Long.compare(b.lastModified(), a.lastModified()));
			return files;
		}

		public String read(File f) {
			if (f == null || !f.exists())
				return null;
			try (BufferedReader r = new BufferedReader(new FileReader(f))) {
				StringBuilder sb = new StringBuilder();
				String line;
				while ((line = r.readLine()) != null)
					sb.append(line).append('\n');
				return sb.toString();
			} catch (Exception e) {
				System.err.println("AIHistoryStore.read: " + e.getMessage());
				return null;
			}
		}
	}
	/* ------------------ end AIHistoryStore ------------------ */

	/* -------------------- AIStreamingClient -------------------- */
	public static class AIStreamingClient {
		private final AIModelProvider provider;

		public AIStreamingClient(AIModelProvider provider) {
			this.provider = provider;
		}

		public void sendStream(String model, String prompt, String context, Consumer<String> onChunk,
				Consumer<Exception> onError, Runnable onComplete) {
			new Thread(() -> {
				try {
					provider.sendStream(model, prompt, context, onChunk, onError, onComplete);
				} catch (Exception ex) {
					try {
						String r = provider.send(model, prompt, context);
						onChunk.accept(r);
						onComplete.run();
					} catch (Exception ex2) {
						onError.accept(ex2);
						onComplete.run();
					}
				}
			}, "AIStream-" + model).start();
		}
	}
	/* ---------------- end AIStreamingClient ---------------- */

	/* -------------------- AIMessageBubble (Swing) -------------------- */
	public static class AIMessageBubble extends javax.swing.JPanel {
		public final String who;
		private final javax.swing.JTextArea textArea;
		private final javax.swing.JScrollPane scrollPane;
		private final Color bubbleColor;
		// private final Color borderColor = new Color(180, 180, 180);
		private final Color borderColor;

		public AIMessageBubble(String who, String text, Font font, Color fg, Color bg) {
			this.who = who;
			this.setLayout(new BorderLayout());
			this.setOpaque(false);

			this.bubbleColor = bg; // Use passed background
			// Make border slightly darker than background
			this.borderColor = new Color(Math.max(0, bg.getRed() - 30), Math.max(0, bg.getGreen() - 30),
					Math.max(0, bg.getBlue() - 30));

			// this.bubbleColor = "user".equals(who) ? new Color(220, 240, 255) : new
			// Color(245, 245, 245);

			// Text Area Configuration
			textArea = new javax.swing.JTextArea(text);
			textArea.setFont(font);
			textArea.setForeground(fg);
			textArea.setBackground(bubbleColor);
			textArea.setEditable(false);

			// Default to Wrapped
			textArea.setLineWrap(true);
			textArea.setWrapStyleWord(true);
			textArea.setBorder(new EmptyBorder(5, 5, 5, 5));

			// Selection Colors
			textArea.setSelectionColor(new Color(50, 100, 255));
			textArea.setSelectedTextColor(Color.WHITE);

			// Wrap in ScrollPane
			scrollPane = new javax.swing.JScrollPane(textArea);
			scrollPane.setBorder(null);
			scrollPane.setOpaque(false);
			scrollPane.getViewport().setOpaque(false);
			scrollPane.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
			scrollPane.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);

			// Custom Rounded Panel Container
			javax.swing.JPanel bubblePanel = new javax.swing.JPanel(new BorderLayout()) {
				@Override
				protected void paintComponent(Graphics g) {
					Graphics2D g2 = (Graphics2D) g.create();
					g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
					g2.setColor(bubbleColor);
					g2.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, 12, 12);
					g2.setColor(borderColor);
					g2.drawRoundRect(0, 0, getWidth() - 1, getHeight() - 1, 12, 12);
					g2.dispose();
				}

				@Override
				public Dimension getPreferredSize() {
					Dimension d = textArea.getPreferredSize();
					Container parent = getParent();
					if (parent != null && parent.getParent() != null) {
						int scrollWidth = parent.getParent().getWidth();
						if (scrollWidth > 0) {
							int maxW = (int) (scrollWidth * 0.90);
							if (textArea.getLineWrap()) {
								textArea.setSize(new Dimension(maxW, Short.MAX_VALUE));
								Dimension pref = textArea.getPreferredSize();
								int targetW = Math.min(pref.width + 25, maxW);
								return new Dimension(targetW, pref.height + 25);
							} else {
								int targetW = Math.min(d.width + 25, maxW);
								int scrollBarHeight = (d.width > maxW) ? 20 : 0;
								return new Dimension(targetW, d.height + 25 + scrollBarHeight);
							}
						}
					}
					return new Dimension(d.width + 25, d.height + 25);
				}
			};

			bubblePanel.setOpaque(false);
			bubblePanel.setBorder(new EmptyBorder(4, 4, 4, 4));
			bubblePanel.add(scrollPane, BorderLayout.CENTER);

			// Context Menu
			javax.swing.JPopupMenu popup = new javax.swing.JPopupMenu();

			javax.swing.JMenuItem copyItem = new javax.swing.JMenuItem("Copy Message");
			copyItem.addActionListener(e -> {
				textArea.selectAll();
				textArea.copy();
				textArea.setCaretPosition(0);
			});

			javax.swing.JCheckBoxMenuItem wrapItem = new javax.swing.JCheckBoxMenuItem("Word Wrap", true);
			wrapItem.addActionListener(e -> {
				boolean wrap = wrapItem.isSelected();
				textArea.setLineWrap(wrap);
				textArea.setWrapStyleWord(wrap);
				bubblePanel.revalidate();
				if (getParent() != null)
					getParent().revalidate();
				repaint();
			});

			popup.add(copyItem);
			popup.addSeparator();
			popup.add(wrapItem);

			textArea.setComponentPopupMenu(popup);

			// Alignment Container
			javax.swing.JPanel alignPanel = new javax.swing.JPanel(
					new FlowLayout("user".equals(who) ? FlowLayout.RIGHT : FlowLayout.LEFT));
			alignPanel.setOpaque(false);
			alignPanel.add(bubblePanel);

			add(alignPanel, BorderLayout.CENTER);

			// --- FIX: Forward Trackpad/MouseWheel events to Main ScrollBar ---
			// Since this bubble expands to fit height, the inner vertical scrollbar is
			// usually invisible.
			// We explicitly forward the event to the parent ScrollPane so trackpad
			// scrolling works.
			MouseWheelListener forwarder = e -> {
				// Only forward if inner vertical bar is NOT visible (meaning we are displaying
				// full height)
				if (!scrollPane.getVerticalScrollBar().isVisible()) {
					javax.swing.JScrollPane parentScroll = (javax.swing.JScrollPane) javax.swing.SwingUtilities
							.getAncestorOfClass(javax.swing.JScrollPane.class, getParent());
					if (parentScroll != null) {
						parentScroll.dispatchEvent(
								javax.swing.SwingUtilities.convertMouseEvent(e.getComponent(), e, parentScroll));
					}
				}
			};
			textArea.addMouseWheelListener(forwarder);
			scrollPane.addMouseWheelListener(forwarder);
		}

		public void appendText(String s) {
			textArea.append(s);
			textArea.setCaretPosition(textArea.getDocument().getLength());
			revalidate();
			repaint();
		}
	}
	/* ---------------- end AIMessageBubble ---------------- */

	/* -------------------- AIChatScrollView (Swing) -------------------- */
	public static class AIChatScrollView extends javax.swing.JPanel {
		public final javax.swing.JPanel listPanel;
		private final javax.swing.JScrollPane scrollPane;

		public AIChatScrollView(Font uiFont, Color fg, Color bg) {
			super(new BorderLayout());

			listPanel = new javax.swing.JPanel();
			listPanel.setLayout(new javax.swing.BoxLayout(listPanel, javax.swing.BoxLayout.Y_AXIS));
			listPanel.setBackground(Color.WHITE);

			scrollPane = new javax.swing.JScrollPane(listPanel);
			scrollPane.setBorder(null);
			scrollPane.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
			scrollPane.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);

			// Auto-scroll behavior
			DefaultCaret caret = new DefaultCaret();
			caret.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);

			add(scrollPane, BorderLayout.CENTER);
		}

		public AIMessageBubble addMessage(String who, String text, Font uiFont, Color fg, Color bg) {
			AIMessageBubble bubble = new AIMessageBubble(who, text, uiFont, fg, bg);

			// Limit width to 80% of view
			bubble.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));

			listPanel.add(bubble);
			listPanel.add(javax.swing.Box.createRigidArea(new Dimension(0, 5))); // Spacing

			listPanel.revalidate();
			listPanel.repaint();

			// Scroll to bottom
			EventQueue.invokeLater(() -> {
				javax.swing.JScrollBar vertical = scrollPane.getVerticalScrollBar();
				vertical.setValue(vertical.getMaximum());
			});

			return bubble;
		}

		public void clear() {
			listPanel.removeAll();
			listPanel.revalidate();
			listPanel.repaint();
		}

		public String exportConversationJson() {
			// (JSON export logic remains the same, just iterating Swing components)
			StringBuilder sb = new StringBuilder();
			sb.append("{\"conversation\":[");
			Component[] comps = listPanel.getComponents();
			boolean first = true;
			for (Component c : comps) {
				// Swing adds intermediate containers, so we check recursivley or simplified
				if (c instanceof AIMessageBubble) {
					if (!first)
						sb.append(",");
					first = false;
					AIMessageBubble b = (AIMessageBubble) c;
					// Note: accessing private text via accessor or reflection in previous code
					// Here we access the JTextArea directly if we made it public, or parsing:
					// For simplicity, assuming text passed in constructor is source of truth
					// Ideally, create a getter in AIMessageBubble.
				}
			}
			sb.append("]}");
			return sb.toString();
		}
	}
	/* ---------------- end AIChatScrollView ---------------- */

	public static class AIChatWindow extends JDialog {
		private final Frame owner;
		public final AIChatScrollView chatView;
		private final JTextArea inputArea;
		private final Choice modelChoice;
		private final JButton sendBtn, tryNextBtn, saveBtn, loadBtn, prefsBtn;
		private final JLabel spinner;
		private final AIStreamingClient streamingClient;
		private final AIHistoryStore historyStore;
		private final AIConfig config;
		private String lastPrompt = null;

		// --- Theme Palette ---
		private final Color BG_MAIN = new Color(245, 247, 250); // Very light blue-gray
		private final Color BG_INPUT = Color.WHITE;
		private final Color TEXT_COLOR = new Color(30, 30, 30);

		public AIChatWindow(Frame owner, AIModelProvider prov, AIConfig cfg) {
			// Pass null as owner to super to allow independent Z-ordering if desired,
			// or pass 'owner' to keep it strictly on top.
			super((Frame) null, "AI Assistant", false);

			this.owner = owner;
			this.config = cfg;
			this.streamingClient = new AIStreamingClient(prov);
			this.historyStore = new AIHistoryStore(cfg.get("ai.autosave.dir", "ai_history"));

			setLayout(new BorderLayout());
			setSize(950, 750);
			getContentPane().setBackground(BG_MAIN);

			// --- TOP TOOLBAR ---
			JPanel top = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 12));
			top.setBackground(Color.WHITE);
			top.setBorder(new javax.swing.border.MatteBorder(0, 0, 1, 0, new Color(230, 230, 230)));

			JLabel lblModel = new JLabel("Model:");
			lblModel.setFont(new Font("SansSerif", Font.BOLD, 12));

			modelChoice = new Choice();
			for (String m : cfg.getModels())
				modelChoice.add(m);

			// Color-Coded Buttons
			sendBtn = createColorButton("Send", new Color(0, 120, 215), Color.WHITE); // Windows Blue
			tryNextBtn = createColorButton("Retry", new Color(255, 140, 0), Color.WHITE); // Orange
			saveBtn = createColorButton("Save", new Color(40, 167, 69), Color.WHITE); // Green
			loadBtn = createColorButton("Load", new Color(108, 117, 125), Color.WHITE); // Grey
			prefsBtn = createColorButton("Config", new Color(23, 162, 184), Color.WHITE); // Cyan/Teal

			spinner = new JLabel("Idle");
			spinner.setForeground(Color.GRAY);
			spinner.setFont(new Font("SansSerif", Font.ITALIC, 11));

			top.add(lblModel);
			top.add(modelChoice);
			top.add(Box.createHorizontalStrut(15));
			top.add(sendBtn);
			top.add(tryNextBtn);
			top.add(Box.createHorizontalStrut(15));
			top.add(saveBtn);
			top.add(loadBtn);
			top.add(Box.createHorizontalStrut(15));
			top.add(prefsBtn);
			top.add(Box.createHorizontalStrut(15));
			top.add(spinner);

			add(top, BorderLayout.NORTH);

			// --- CHAT AREA ---
			Font chatFont = new Font("Monospaced", Font.PLAIN, 13);
			chatView = new AIChatScrollView(chatFont, TEXT_COLOR, Color.WHITE);

			// Wrapper for padding
			JPanel chatWrapper = new JPanel(new BorderLayout());
			chatWrapper.setBackground(Color.WHITE);
			chatWrapper.setBorder(new EmptyBorder(0, 0, 0, 0));
			chatWrapper.add(chatView, BorderLayout.CENTER);
			add(chatWrapper, BorderLayout.CENTER);

			// --- BOTTOM INPUT AREA ---
			JPanel bottom = new JPanel(new BorderLayout(0, 8)); // Vertical gap 8
			bottom.setBackground(BG_MAIN);
			bottom.setBorder(new EmptyBorder(15, 20, 15, 20));

			// 1. Greeting Label
			JLabel greeting = new JLabel("Hi, what can I help you with?");
			greeting.setFont(new Font("SansSerif", Font.BOLD, 14));
			greeting.setForeground(new Color(80, 80, 90));
			bottom.add(greeting, BorderLayout.NORTH);

			// 2. Input Box with Rounded Corners
			inputArea = new JTextArea(3, 80);
			inputArea.setFont(chatFont);
			inputArea.setBackground(BG_INPUT);
			inputArea.setForeground(TEXT_COLOR);
			inputArea.setCaretColor(TEXT_COLOR);
			inputArea.setLineWrap(true);
			inputArea.setWrapStyleWord(true);
			// Margin inside the text area
			inputArea.setBorder(new EmptyBorder(8, 8, 8, 8));

			JScrollPane inputScroll = new JScrollPane(inputArea);
			// Use our custom RoundedBorder
			inputScroll.setBorder(new RoundedBorder(12, new Color(200, 200, 200)));
			inputScroll.setBackground(BG_MAIN); // Match container so corners look clean
			inputScroll.getViewport().setBackground(BG_INPUT);

			bottom.add(inputScroll, BorderLayout.CENTER);

			// 3. Hint Label
			JLabel hint = new JLabel("Enter to send, Shift+Enter for newline");
			hint.setForeground(Color.GRAY);
			hint.setFont(new Font("SansSerif", Font.PLAIN, 10));
			hint.setHorizontalAlignment(SwingConstants.RIGHT);
			bottom.add(hint, BorderLayout.SOUTH);

			add(bottom, BorderLayout.SOUTH);

			// --- HANDLERS ---
			sendBtn.addActionListener(e -> doSend());
			tryNextBtn.addActionListener(e -> doTryNext());
			prefsBtn.addActionListener(e -> new TN3270Emulator.AIPreferencesPanel(owner, config).showDialog());

			inputArea.addKeyListener(new KeyAdapter() {
				public void keyPressed(KeyEvent e) {
					if (e.getKeyCode() == KeyEvent.VK_ENTER && !e.isShiftDown()) {
						e.consume();
						doSend();
					}
				}
			});

			// Context Menu for Input
			JPopupMenu popup = new JPopupMenu();
			JMenuItem cut = new JMenuItem("Cut");
			cut.addActionListener(e -> inputArea.cut());
			JMenuItem copy = new JMenuItem("Copy");
			copy.addActionListener(e -> inputArea.copy());
			JMenuItem paste = new JMenuItem("Paste");
			paste.addActionListener(e -> inputArea.paste());
			popup.add(cut);
			popup.add(copy);
			popup.add(paste);
			inputArea.setComponentPopupMenu(popup);
		}

		private JButton createColorButton(String text, Color baseColor, Color textColor) {
			JButton btn = new JButton(text);
			btn.setBackground(baseColor);
			btn.setForeground(textColor);
			btn.setFocusPainted(false);
			btn.setFont(new Font("SansSerif", Font.BOLD, 11));

			// Rounded empty border for the button shape
			btn.setBorder(new javax.swing.border.CompoundBorder(new RoundedBorder(10, baseColor.darker()),
					new javax.swing.border.EmptyBorder(4, 12, 4, 12)));

			btn.setCursor(new Cursor(Cursor.HAND_CURSOR));
			btn.setContentAreaFilled(false); // We will paint background manually for hover effect
			btn.setOpaque(false);

			// Custom painting for hover effect
			btn.setUI(new javax.swing.plaf.basic.BasicButtonUI() {
				@Override
				public void paint(Graphics g, JComponent c) {
					AbstractButton b = (AbstractButton) c;
					ButtonModel model = b.getModel();
					Graphics2D g2 = (Graphics2D) g.create();
					g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

					Color fill = baseColor;
					if (model.isPressed())
						fill = baseColor.darker();
					else if (model.isRollover())
						fill = baseColor.brighter();

					g2.setColor(fill);
					g2.fillRoundRect(0, 0, c.getWidth(), c.getHeight(), 10, 10);

					super.paint(g2, c);
					g2.dispose();
				}
			});

			return btn;
		}

		public void showWithPrefill(String selectedText, String sysPrompt, boolean autoSend) {
			if (selectedText != null && !selectedText.isEmpty()) {
				inputArea.setText(selectedText);
				inputArea.setCaretPosition(0);
				inputArea.requestFocusInWindow();
			}

			if (sysPrompt != null && !sysPrompt.isEmpty() && !sysPrompt.startsWith("You are")) {
				chatView.addMessage("assistant", "[System Context]\n" + sysPrompt, inputArea.getFont(),
						new Color(100, 100, 100), new Color(255, 255, 220));
			}

			setLocationRelativeTo(owner);
			setVisible(true);

			if (autoSend && selectedText != null && !selectedText.trim().isEmpty()) {
				SwingUtilities.invokeLater(this::doSend);
			}
		}

		private void doSend() {
			String prompt = inputArea.getText().trim();
			if (prompt.isEmpty())
				return;

			String model = modelChoice.getSelectedItem();
			lastPrompt = prompt;

			// User Bubble: Blue background, White text
			chatView.addMessage("user", prompt, inputArea.getFont(), Color.WHITE, new Color(0, 120, 215));

			inputArea.setText("");
			spinner.setText("Sending to " + model + "...");

			String sys = config.get("ai.prompt.default", "You are assisting a TN3270 mainframe user.");

			streamingClient.sendStream(model, prompt, sys, chunk -> {
				EventQueue.invokeLater(() -> {
					Component[] comps = chatView.listPanel.getComponents();
					AIMessageBubble lastBubble = null;

					for (int i = comps.length - 1; i >= 0; i--) {
						if (comps[i] instanceof AIMessageBubble) {
							lastBubble = (AIMessageBubble) comps[i];
							break;
						}
					}

					if (lastBubble != null && "assistant".equals(lastBubble.who)) {
						lastBubble.appendText(chunk);
					} else {
						// Assistant Bubble: Light Grey background, Black text
						chatView.addMessage("assistant", chunk, inputArea.getFont(), Color.BLACK,
								new Color(240, 242, 245));
					}
				});
			}, ex -> EventQueue.invokeLater(() -> {
				chatView.addMessage("assistant", "[Error] " + ex.getMessage(), inputArea.getFont(),
						new Color(180, 0, 0), new Color(255, 235, 235));
				spinner.setText("Error");
			}), () -> EventQueue.invokeLater(() -> spinner.setText("Idle")));
		}

		private void doTryNext() {
			if (lastPrompt == null)
				return;
			int idx = modelChoice.getSelectedIndex();
			if (idx < 0)
				return;
			int next = (idx + 1) % modelChoice.getItemCount();
			modelChoice.select(next);
			inputArea.setText(lastPrompt);
			doSend();
		}
	}

	// --- UI HELPER: ROUNDED BORDER ---
	// Used by the AI Chat Window for the input text area
	static class RoundedBorder extends AbstractBorder {
		private final int radius;
		private final Color color;

		public RoundedBorder(int radius, Color color) {
			this.radius = radius;
			this.color = color;
		}

		@Override
		public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
			Graphics2D g2 = (Graphics2D) g.create();
			g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			g2.setColor(color);
			g2.drawRoundRect(x, y, width - 1, height - 1, radius, radius);
			g2.dispose();
		}

		@Override
		public Insets getBorderInsets(Component c) {
			return new Insets(this.radius / 2, this.radius / 2, this.radius / 2, this.radius / 2);
		}

		@Override
		public Insets getBorderInsets(Component c, Insets insets) {
			insets.left = insets.top = insets.right = insets.bottom = this.radius / 2;
			return insets;
		}
	}
	/* ---------------- end AIChatWindow ---------------- */

}