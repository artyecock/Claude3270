package com.tn3270;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.security.Key;
import java.util.*;
import java.util.List;

import javax.swing.*;
import javax.swing.Timer;
import javax.swing.border.*;
import java.awt.event.*;
import java.util.Map;

import javax.net.ssl.*;

import java.awt.datatransfer.*;

import java.awt.image.BufferedImage;
import java.awt.geom.*;

import javax.net.ssl.HttpsURLConnection;
import java.net.URI;
import java.net.URL;
import java.nio.charset.StandardCharsets;

import java.util.function.Consumer;

// AI dialogs need Swing
import javax.swing.border.EmptyBorder;
import javax.swing.text.DefaultCaret;

public class TN3270Session extends JPanel implements KeyListener {

	// Terminal models and dimensions
	private static final Map<String, Dimension> MODELS = new HashMap<>();
	static {
		MODELS.put("3278-2", new Dimension(80, 24));
		MODELS.put("3278-3", new Dimension(80, 32));
		MODELS.put("3278-4", new Dimension(80, 43));
		MODELS.put("3278-5", new Dimension(132, 27));
		MODELS.put("3279-2", new Dimension(80, 24)); // Color
		MODELS.put("3279-3", new Dimension(80, 32)); // Color
	}

	// Telnet commands
	private static final byte IAC = (byte) 0xFF;
	private static final byte DO = (byte) 0xFD;
	private static final byte DONT = (byte) 0xFE;
	private static final byte WILL = (byte) 0xFB;
	private static final byte WONT = (byte) 0xFC;
	private static final byte SB = (byte) 0xFA;
	private static final byte SE = (byte) 0xF0;

	// Telnet options
	private static final byte OPT_BINARY = (byte) 0x00;
	private static final byte OPT_TERMINAL_TYPE = (byte) 0x18;
	private static final byte OPT_EOR = (byte) 0x19;
	private static final byte OPT_TN3270E = (byte) 0x28;

	// TN3270E header
	private static final byte TN3270E_DT_3270_DATA = 0x00;
	private static final byte TN3270E_DT_SCS_DATA = 0x01;
	private static final byte TN3270E_DT_RESPONSE = 0x02;
	private static final byte TN3270E_DT_BIND_IMAGE = 0x03;
	private static final byte TN3270E_DT_UNBIND = 0x04;

	// TN3270E Opcodes (RFC 2355)
	private static final byte TN3270E_OP_ASSOCIATE = 0x00;
	private static final byte TN3270E_OP_CONNECT = 0x01;
	private static final byte TN3270E_OP_DEVICE_TYPE = 0x02;
	private static final byte TN3270E_OP_FUNCTIONS = 0x03;
	private static final byte TN3270E_OP_IS = 0x04;
	private static final byte TN3270E_OP_REASON = 0x05;
	private static final byte TN3270E_OP_REJECT = 0x06;
	private static final byte TN3270E_OP_REQUEST = 0x07;
	private static final byte TN3270E_OP_SEND = 0x08;

	// Define states to persist across read() calls
	private static final int STATE_DATA = 0;
	private static final int STATE_IAC = 1;
	private static final int STATE_SB = 2;
	private static final int STATE_WILL = 3;
	private static final int STATE_WONT = 4;
	private static final int STATE_DO = 5;
	private static final int STATE_DONT = 6;

	// 3270 Commands
	// CCWs with "high" bits are for Remote attached 3270 devices
	private static final byte CMD_WRITE_01 = (byte) 0x01;
	private static final byte CMD_WRITE_F1 = (byte) 0xF1;
	private static final byte CMD_ERASE_WRITE_05 = (byte) 0x05;
	private static final byte CMD_ERASE_WRITE_F5 = (byte) 0xF5;
	private static final byte CMD_ERASE_WRITE_ALTERNATE_0D = (byte) 0x0D;
	private static final byte CMD_ERASE_WRITE_ALTERNATE_7E = (byte) 0x7E;
	private static final byte CMD_READ_BUFFER_02 = (byte) 0x02;
	private static final byte CMD_READ_BUFFER_F2 = (byte) 0xF2;
	private static final byte CMD_READ_MODIFIED_06 = (byte) 0x06;
	private static final byte CMD_READ_MODIFIED_F6 = (byte) 0xF6;
	private static final byte CMD_READ_MODIFIED_ALL_0E = (byte) 0x0E;
	private static final byte CMD_READ_MODIFIED_ALL_6E = (byte) 0x6E;
	private static final byte CMD_WSF_11 = (byte) 0x11;
	private static final byte CMD_WSF_F3 = (byte) 0xF3;
	private static final byte CMD_ERASE_ALL_UNPROTECTED_0F = (byte) 0x0F;
	private static final byte CMD_ERASE_ALL_UNPROTECTED_6F = (byte) 0x6F;

	// 3270 Orders
	private static final byte ORDER_SF = (byte) 0x1D;
	private static final byte ORDER_SFE = (byte) 0x29;
	private static final byte ORDER_SA = (byte) 0x28;
	private static final byte ORDER_SBA = (byte) 0x11;
	private static final byte ORDER_IC = (byte) 0x13;
	private static final byte ORDER_RA = (byte) 0x3C;
	private static final byte ORDER_MF = (byte) 0x2C;
	private static final byte ORDER_GE = (byte) 0x08;
	private static final byte ORDER_EUA = (byte) 0x12;
	private static final byte ORDER_FM = (byte) 0x0E;
	private static final byte ORDER_PT = (byte) 0x05;

	// Attribute types for SA/SFE
	private static final byte ATTR_FIELD = (byte) 0xC0;
	private static final byte ATTR_HIGHLIGHTING = (byte) 0x41;
	private static final byte ATTR_FOREGROUND = (byte) 0x42;
	private static final byte ATTR_BACKGROUND = (byte) 0x45;

	// 3270 AIDs
	public static final byte AID_ENTER = (byte) 0x7D;
	public static final byte AID_CLEAR = (byte) 0x6D;
	public static final byte AID_SYSREQ = (byte) 0xF0;
	public static final byte AID_ATTN = (byte) 0x6A;
	public static final byte AID_CURSOR_SELECT = (byte) 0x7E;
	public static final byte AID_PA1 = (byte) 0x6C;
	public static final byte AID_PA2 = (byte) 0x6E;
	public static final byte AID_PA3 = (byte) 0x6B;
	public static final byte AID_PF1 = (byte) 0xF1;
	public static final byte AID_PF2 = (byte) 0xF2;
	public static final byte AID_PF3 = (byte) 0xF3;
	public static final byte AID_PF4 = (byte) 0xF4;
	public static final byte AID_PF5 = (byte) 0xF5;
	public static final byte AID_PF6 = (byte) 0xF6;
	public static final byte AID_PF7 = (byte) 0xF7;
	public static final byte AID_PF8 = (byte) 0xF8;
	public static final byte AID_PF9 = (byte) 0xF9;
	public static final byte AID_PF10 = (byte) 0x7A;
	public static final byte AID_PF11 = (byte) 0x7B;
	public static final byte AID_PF12 = (byte) 0x7C;
	public static final byte AID_PF13 = (byte) 0xC1;
	public static final byte AID_PF14 = (byte) 0xC2;
	public static final byte AID_PF15 = (byte) 0xC3;
	public static final byte AID_PF16 = (byte) 0xC4;
	public static final byte AID_PF17 = (byte) 0xC5;
	public static final byte AID_PF18 = (byte) 0xC6;
	public static final byte AID_PF19 = (byte) 0xC7;
	public static final byte AID_PF20 = (byte) 0xC8;
	public static final byte AID_PF21 = (byte) 0xC9;
	public static final byte AID_PF22 = (byte) 0x4A;
	public static final byte AID_PF23 = (byte) 0x4B;
	public static final byte AID_PF24 = (byte) 0x4C;

	// PF1–PF24 for keyboard panel
	private static final byte[] PF_AID = new byte[] { AID_PF1, AID_PF2, AID_PF3, AID_PF4, AID_PF5, AID_PF6, AID_PF7,
			AID_PF8, AID_PF9, AID_PF10, AID_PF11, AID_PF12, AID_PF13, AID_PF14, AID_PF15, AID_PF16, AID_PF17, AID_PF18,
			AID_PF19, AID_PF20, AID_PF21, AID_PF22, AID_PF23, AID_PF24 };

	// WCC bits
	private static final byte WCC_RESET = (byte) 0x40;
	private static final byte WCC_ALARM = (byte) 0x04;
	private static final byte WCC_RESET_MDT = (byte) 0x01;

	// EBCDIC to ASCII translation table (Code Page 037)
	private static final char[] EBCDIC_TO_ASCII = new char[256];
	private static final byte[] ASCII_TO_EBCDIC = new byte[256];
	private static final char[] EBCDIC_TO_APL = new char[256];
	private char[] currentCharSet = EBCDIC_TO_ASCII;

	// Color scheme presets (static - shared across all instances)
	private static final Map<String, ColorScheme> COLOR_SCHEMES = new HashMap<>();

	public static class ColorScheme {
		Color background;
		Color defaultFg;
		Color cursor;
		Color[] colors;

		ColorScheme(Color bg, Color defaultFg, Color cursor, Color[] colors) {
			this.background = bg;
			this.defaultFg = defaultFg;
			this.cursor = cursor;
			this.colors = colors;
		}
	}

	// Static Initialization Blocks
	static {
		// Initialize with nulls
		Arrays.fill(EBCDIC_TO_ASCII, '\0');
		Arrays.fill(ASCII_TO_EBCDIC, (byte) 0x00);

		// EBCDIC to ASCII mapping (CP037)
		EBCDIC_TO_ASCII[0x00] = '\0';
		EBCDIC_TO_ASCII[0x0B] = '\u000B';
		EBCDIC_TO_ASCII[0x0C] = '\f';
		EBCDIC_TO_ASCII[0x0D] = '\r';
		EBCDIC_TO_ASCII[0x0E] = '\u000E';
		EBCDIC_TO_ASCII[0x0F] = '\u000F';
		EBCDIC_TO_ASCII[0x16] = '\u0016';
		EBCDIC_TO_ASCII[0x25] = '\n';
		EBCDIC_TO_ASCII[0x40] = ' ';
		EBCDIC_TO_ASCII[0x4A] = '[';
		EBCDIC_TO_ASCII[0x4B] = '.';
		EBCDIC_TO_ASCII[0x4C] = '<';
		EBCDIC_TO_ASCII[0x4D] = '(';
		EBCDIC_TO_ASCII[0x4E] = '+';
		EBCDIC_TO_ASCII[0x4F] = '|';
		EBCDIC_TO_ASCII[0x50] = '&';
		EBCDIC_TO_ASCII[0x5A] = '!';
		EBCDIC_TO_ASCII[0x5B] = '$';
		EBCDIC_TO_ASCII[0x5C] = '*';
		EBCDIC_TO_ASCII[0x5D] = ')';
		EBCDIC_TO_ASCII[0x5E] = ';';
		EBCDIC_TO_ASCII[0x5F] = '^';
		EBCDIC_TO_ASCII[0x60] = '-';
		EBCDIC_TO_ASCII[0x61] = '/';
		EBCDIC_TO_ASCII[0x6A] = '|';
		EBCDIC_TO_ASCII[0x6B] = ',';
		EBCDIC_TO_ASCII[0x6C] = '%';
		EBCDIC_TO_ASCII[0x6D] = '_';
		EBCDIC_TO_ASCII[0x6E] = '>';
		EBCDIC_TO_ASCII[0x6F] = '?';
		EBCDIC_TO_ASCII[0x79] = '`';
		EBCDIC_TO_ASCII[0x7A] = ':';
		EBCDIC_TO_ASCII[0x7B] = '#';
		EBCDIC_TO_ASCII[0x7C] = '@';
		EBCDIC_TO_ASCII[0x7D] = '\'';
		EBCDIC_TO_ASCII[0x7E] = '=';
		EBCDIC_TO_ASCII[0x7F] = '"';
		EBCDIC_TO_ASCII[0x80] = ' ';

		// Lowercase letters
		EBCDIC_TO_ASCII[0x81] = 'a';
		EBCDIC_TO_ASCII[0x82] = 'b';
		EBCDIC_TO_ASCII[0x83] = 'c';
		EBCDIC_TO_ASCII[0x84] = 'd';
		EBCDIC_TO_ASCII[0x85] = 'e';
		EBCDIC_TO_ASCII[0x86] = 'f';
		EBCDIC_TO_ASCII[0x87] = 'g';
		EBCDIC_TO_ASCII[0x88] = 'h';
		EBCDIC_TO_ASCII[0x89] = 'i';
		EBCDIC_TO_ASCII[0x91] = 'j';
		EBCDIC_TO_ASCII[0x92] = 'k';
		EBCDIC_TO_ASCII[0x93] = 'l';
		EBCDIC_TO_ASCII[0x94] = 'm';
		EBCDIC_TO_ASCII[0x95] = 'n';
		EBCDIC_TO_ASCII[0x96] = 'o';
		EBCDIC_TO_ASCII[0x97] = 'p';
		EBCDIC_TO_ASCII[0x98] = 'q';
		EBCDIC_TO_ASCII[0x99] = 'r';
		EBCDIC_TO_ASCII[0xA1] = '~';
		EBCDIC_TO_ASCII[0xA2] = 's';
		EBCDIC_TO_ASCII[0xA3] = 't';
		EBCDIC_TO_ASCII[0xA4] = 'u';
		EBCDIC_TO_ASCII[0xA5] = 'v';
		EBCDIC_TO_ASCII[0xA6] = 'w';
		EBCDIC_TO_ASCII[0xA7] = 'x';
		EBCDIC_TO_ASCII[0xA8] = 'y';
		EBCDIC_TO_ASCII[0xA9] = 'z';

		// Uppercase letters
		EBCDIC_TO_ASCII[0xC1] = 'A';
		EBCDIC_TO_ASCII[0xC2] = 'B';
		EBCDIC_TO_ASCII[0xC3] = 'C';
		EBCDIC_TO_ASCII[0xC4] = 'D';
		EBCDIC_TO_ASCII[0xC5] = 'E';
		EBCDIC_TO_ASCII[0xC6] = 'F';
		EBCDIC_TO_ASCII[0xC7] = 'G';
		EBCDIC_TO_ASCII[0xC8] = 'H';
		EBCDIC_TO_ASCII[0xC9] = 'I';
		EBCDIC_TO_ASCII[0xD1] = 'J';
		EBCDIC_TO_ASCII[0xD2] = 'K';
		EBCDIC_TO_ASCII[0xD3] = 'L';
		EBCDIC_TO_ASCII[0xD4] = 'M';
		EBCDIC_TO_ASCII[0xD5] = 'N';
		EBCDIC_TO_ASCII[0xD6] = 'O';
		EBCDIC_TO_ASCII[0xD7] = 'P';
		EBCDIC_TO_ASCII[0xD8] = 'Q';
		EBCDIC_TO_ASCII[0xD9] = 'R';
		EBCDIC_TO_ASCII[0xE2] = 'S';
		EBCDIC_TO_ASCII[0xE3] = 'T';
		EBCDIC_TO_ASCII[0xE4] = 'U';
		EBCDIC_TO_ASCII[0xE5] = 'V';
		EBCDIC_TO_ASCII[0xE6] = 'W';
		EBCDIC_TO_ASCII[0xE7] = 'X';
		EBCDIC_TO_ASCII[0xE8] = 'Y';
		EBCDIC_TO_ASCII[0xE9] = 'Z';

		// Numbers
		EBCDIC_TO_ASCII[0xF0] = '0';
		EBCDIC_TO_ASCII[0xF1] = '1';
		EBCDIC_TO_ASCII[0xF2] = '2';
		EBCDIC_TO_ASCII[0xF3] = '3';
		EBCDIC_TO_ASCII[0xF4] = '4';
		EBCDIC_TO_ASCII[0xF5] = '5';
		EBCDIC_TO_ASCII[0xF6] = '6';
		EBCDIC_TO_ASCII[0xF7] = '7';
		EBCDIC_TO_ASCII[0xF8] = '8';
		EBCDIC_TO_ASCII[0xF9] = '9';

		// Additional characters
		EBCDIC_TO_ASCII[0xBA] = '[';
		EBCDIC_TO_ASCII[0xBB] = ']';
		EBCDIC_TO_ASCII[0xC0] = '{';
		EBCDIC_TO_ASCII[0xD0] = '}';
		EBCDIC_TO_ASCII[0xE0] = '\\';

		// Build reverse mapping
		ASCII_TO_EBCDIC[' '] = 0x40;
		ASCII_TO_EBCDIC['\0'] = 0x00;
		for (int i = 0; i < 256; i++) {
			char c = EBCDIC_TO_ASCII[i];
			if (c > 0 && c < 256 && c != ' ' && c != '\0') {
				ASCII_TO_EBCDIC[c] = (byte) i;
			}
		}

		// Initialize color schemes
		initializeColorSchemes();
	}

	static {
		// Initialize APL character set
		System.arraycopy(EBCDIC_TO_ASCII, 0, EBCDIC_TO_APL, 0, 256);

		// Override with APL/box-drawing characters
		EBCDIC_TO_APL[0xAD] = '┌'; // Top-left 'E'
		EBCDIC_TO_APL[0xC5] = '┌'; // Top-left 'E' (corrected) \u2308 (left ceiling/Up Stile)
		EBCDIC_TO_APL[0xAE] = '┐'; // Top-right 'N'
		EBCDIC_TO_APL[0xD5] = '┐'; // Top-right 'N' (corrected)
		EBCDIC_TO_APL[0xBD] = '└'; // Bottom-left 'D'
		EBCDIC_TO_APL[0xC4] = '└'; // Bottom-left 'D' (corrected) \u230a (left floor/Down Stile)
		EBCDIC_TO_APL[0xBE] = '┘'; // Bottom-right 'M'
		EBCDIC_TO_APL[0xD4] = '┘'; // Bottom-right 'M' (corrected)
		// EBCDIC_TO_APL[0xBF] = '├'; // Left T \u22a2
		EBCDIC_TO_APL[0xC6] = '├'; // Left T \u22a2 (corrected) (right tack/Left Tack)
		// EBCDIC_TO_APL[0xC6] = '┤'; // Right T \u22a3 (left tack/Right Tack)
		EBCDIC_TO_APL[0xD6] = '┤'; // Right T 'O' (corrected) \u22a3
		EBCDIC_TO_APL[0xD7] = '┬'; // Top T \u22a4 (down tack/Up Tack) \u252c?
		// EBCDIC_TO_APL[0xD8] = '┴'; // Bottom T \u22a5 (up tack/Down Tack)
		EBCDIC_TO_APL[0xC7] = '┴'; // Bottom T \u22a5 (corrected) \u2534?
		// EBCDIC_TO_APL[0xCE] = '┼'; // Cross
		EBCDIC_TO_APL[0xD3] = '┼'; // Cross 'L' (corrected) \u2532 (Light Vertical and Horizontal)
		// EBCDIC_TO_APL[0xA2] = '─'; // Horizontal '-' \u2500 or \u2501
		// I think \u2501 might be too "thick":
		EBCDIC_TO_APL[0xA2] = '\u2500'; // Horizontal '-' \u2500 (Light Horizontal) or \u2501
		// EBCDIC_TO_APL[0x85] = '│'; // Vertical '|'. \u2223 (Divides) or \u2502
		EBCDIC_TO_APL[0x85] = '\u2502'; // Vertical '|'. \u2223 or \u2502 (Light Vertical)
		// EBCDIC_TO_APL[0xA3] = '\u2022'; // 't' should be a bullet \u25cf is small
		EBCDIC_TO_APL[0xA3] = '\u25cf'; // 't' should be a bullet (black circle) or \u2b24?
		// Add more APL characters as needed
		// u2190 is a Leftwards Arrow
		// u2192 is a Rightwards Arrow
		// u2191 is an Upwards Arrow
		// u2193 is a Downwards Arrow
		// See: https://en.wikipedia.org/wiki/Digital_encoding_of_APL_symbols
		// https://en.wikipedia.org/wiki/Box-drawing_characters
		// Code Page 437
	}

	private static final byte[] ADDRESS_TABLE = { (byte) 0x40, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4,
			(byte) 0xC5, (byte) 0xC6, (byte) 0xC7, // 0x00-0x07
			(byte) 0xC8, (byte) 0xC9, (byte) 0x4A, (byte) 0x4B, (byte) 0x4C, (byte) 0x4D, (byte) 0x4E, (byte) 0x4F, // 0x08-0x0F
			(byte) 0x50, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, // 0x10-0x17
			(byte) 0xD8, (byte) 0xD9, (byte) 0x5A, (byte) 0x5B, (byte) 0x5C, (byte) 0x5D, (byte) 0x5E, (byte) 0x5F, // 0x18-0x1F
			(byte) 0x60, (byte) 0x61, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, // 0x20-0x27
			(byte) 0xE8, (byte) 0xE9, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, // 0x28-0x2F
			(byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, // 0x30-0x37
			(byte) 0xF8, (byte) 0xF9, (byte) 0x7A, (byte) 0x7B, (byte) 0x7C, (byte) 0x7D, (byte) 0x7E, (byte) 0x7F // 0x38-0x3F
	};

	private static void initializeColorSchemes() {
		// Green on Black (Classic)
		COLOR_SCHEMES.put("Green on Black (Classic)",
				new ColorScheme(Color.BLACK, Color.GREEN, Color.WHITE, new Color[] { Color.BLACK, // 0 - Default
						Color.BLUE, // 1
						Color.RED, // 2
						Color.MAGENTA, // 3
						Color.GREEN, // 4
						Color.CYAN, // 5
						Color.YELLOW, // 6
						Color.WHITE // 7
				}));

		// White on Black
		COLOR_SCHEMES.put("White on Black", new ColorScheme(Color.BLACK, Color.WHITE, new Color(255, 255, 0), // Yellow
																												// cursor
				new Color[] { Color.BLACK, // 0 - Default
						new Color(100, 149, 237), // 1 - Cornflower Blue
						new Color(255, 99, 71), // 2 - Tomato Red
						new Color(255, 105, 180), // 3 - Hot Pink
						new Color(144, 238, 144), // 4 - Light Green
						new Color(64, 224, 208), // 5 - Turquoise
						new Color(255, 255, 0), // 6 - Yellow
						Color.WHITE // 7
				}));

		// Amber on Black (Old Terminal)
		COLOR_SCHEMES.put("Amber on Black", new ColorScheme(Color.BLACK, new Color(255, 176, 0), // Amber
				new Color(255, 200, 50), // Bright amber cursor
				new Color[] { Color.BLACK, // 0 - Default
						new Color(180, 130, 0), // 1 - Dark amber
						new Color(255, 100, 0), // 2 - Orange-red
						new Color(255, 140, 0), // 3 - Dark orange
						new Color(255, 176, 0), // 4 - Amber
						new Color(255, 200, 50), // 5 - Light amber
						new Color(255, 220, 100), // 6 - Pale amber
						new Color(255, 230, 150) // 7 - Very pale amber
				}));

		// Green on Dark Green (Phosphor)
		COLOR_SCHEMES.put("Green on Dark Green", new ColorScheme(new Color(0, 40, 0), // Very dark green
				new Color(51, 255, 51), // Bright green
				new Color(102, 255, 102), // Light green cursor
				new Color[] { new Color(0, 40, 0), // 0 - Background
						new Color(0, 128, 128), // 1 - Teal
						new Color(0, 200, 0), // 2 - Medium green
						new Color(102, 255, 102), // 3 - Light green
						new Color(51, 255, 51), // 4 - Bright green
						new Color(153, 255, 153), // 5 - Very light green
						new Color(204, 255, 204), // 6 - Pale green
						new Color(230, 255, 230) // 7 - Almost white
				}));

		// IBM 3270 Blue (Classic IBM)
		COLOR_SCHEMES.put("IBM 3270 Blue", new ColorScheme(new Color(0, 0, 64), // Dark blue
				new Color(0, 255, 0), // Bright green
				Color.WHITE, new Color[] { new Color(0, 0, 64), // 0 - Background
						new Color(85, 170, 255), // 1 - Light blue
						new Color(255, 85, 85), // 2 - Light red
						new Color(255, 85, 255), // 3 - Pink/Magenta
						new Color(0, 255, 0), // 4 - Bright green
						new Color(85, 255, 255), // 5 - Cyan
						new Color(255, 255, 85), // 6 - Yellow
						Color.WHITE // 7
				}));

		// Solarized Dark
		COLOR_SCHEMES.put("Solarized Dark", new ColorScheme(new Color(0, 43, 54), // Base03
				new Color(131, 148, 150), // Base0
				new Color(147, 161, 161), // Base1 cursor
				new Color[] { new Color(0, 43, 54), // 0 - Base03
						new Color(38, 139, 210), // 1 - Blue
						new Color(220, 50, 47), // 2 - Red
						new Color(211, 54, 130), // 3 - Magenta
						new Color(133, 153, 0), // 4 - Green
						new Color(42, 161, 152), // 5 - Cyan
						new Color(181, 137, 0), // 6 - Yellow
						new Color(238, 232, 213) // 7 - Base2
				}));
	}

	// =======================================================================
	// 3. INSTANCE VARIABLES
	// =======================================================================

	// Components
	public TerminalCanvas canvas;
	private StatusBar statusBar;
	private Timer blinkTimer;
	private TN3270Emulator parentEmulator; // Reference to the Shell

	// Connection
	private Socket socket;
	private InputStream input;
	private OutputStream output;
	private volatile boolean connected = false;
	private Thread readerThread;
	private boolean useTLS = false;
	private String requestedLuName = "";

	// Reconnection state (migrated from local vars in connect logic to instance
	// vars for reconnect())
	private String currentHost = "";
	private int currentPort = 23;

	// Terminal state
	private String model = "3278-2";
	private int rows;
	private int cols;
	private int primaryRows;
	private int primaryCols;
	private int alternateRows;
	private int alternateCols;
	private boolean useAlternateSize = false;
	private char[] buffer;
	private byte[] attributes;
	private byte[] extendedColors;
	private byte[] highlighting;
	private byte currentColor = 0;
	private byte currentHighlight = 0;
	private int cursorPos = 0;
	public boolean insertMode = false; // Public for KeyboardPanel access
	public boolean keyboardLocked = false; // Public for KeyboardPanel access
	private byte lastAID = AID_ENTER;

	// Reply mode flags recorded from host (bitfield or structured)
	private int replyModeFlags = 0;
	private boolean queryReplySent = false;

	private enum ReplyMode {
		FIELD, EXTENDED_FIELD, CHARACTER
	}

	// Current reply mode selected by host (default to FIELD for compatibility)
	private ReplyMode currentReplyMode = ReplyMode.FIELD;

	// TN3270E state
	private boolean tn3270eMode = false;
	private boolean tn3270eNegotiationComplete = false;
	private boolean tn3270eOffered = false;
	private boolean tn3270eAttempted = false;
	private boolean tn3270eFailed = false;
	
	private static final byte AID_STRUCTURED_FIELD = (byte) 0x88;

	// File Transfer
	private static final byte SFID_DATA_CHAIN = (byte) 0xD0;
	private static final byte SFID_INBOUND_3270DS = (byte) 0x61;

	// Structured Field IDs
	private static final byte SF_ID_SET_REPLY_MODE = (byte) 0x09;
	private static final byte SF_ID_READ_PARTITION_QUERY_LIST = (byte) 0xA1;

	// Common SF tags we will check for
	private static final byte SF_SUBTYPE_QUERY_LIST = (byte) 0x01;
	private static final byte SF_SUBTYPE_REPLY = (byte) 0x02;

	// Data Chain operations
	private static final byte DC_OPEN = 0x00;
	private static final byte DC_CLOSE = 0x41;
	private static final byte DC_SET_CURSOR = 0x45;
	private static final byte DC_GET = 0x46;
	private static final byte DC_INSERT = 0x47;

	// Response codes
	private static final byte RESP_POSITIVE = 0x09;
	private static final byte RESP_NEGATIVE = 0x08;

	// File transfer state
	private enum FileTransferState {
		IDLE, OPEN_SENT, TRANSFER_IN_PROGRESS, CLOSE_SENT, ERROR
	}

	private FileTransferState ftState = FileTransferState.IDLE;
	private int blockSequence = 0;
	// private FileOutputStream downloadStream = null;
	// private FileInputStream uploadStream = null;
	private InputStream uploadStream = null; // Generic InputStream allows Buffered wrapper
	private OutputStream downloadStream = null; // Generic OutputStream allows Buffered wrapper
	private String currentFilename = null;

	private enum FileTransferDirection {
		UPLOAD, // Host -> PC
		DOWNLOAD // PC -> Host
	}

	// Add host type enum
	private enum HostType {
		TSO, CMS
	}

	private HostType hostType = HostType.CMS; // Default

	private FileTransferDirection ftDirection = FileTransferDirection.DOWNLOAD;
	private File currentFile = null;
	private boolean ftIsText = true; // true for TEXT/ASCII, false for BINARY
	private boolean ftIsMessage = false;
	private boolean ftHadSuccessfulTransfer = false;
	private boolean pendingCR = false; // Tracks split CRLF across packets

	// --- File Transfer Progress UI (Swing) ---
	private JDialog progressDialog = null;
	private JProgressBar transferProgressBar = null;
	private JLabel progressLabel = null;
	private JLabel transferStatusLabel = null;
	private JButton cancelTransferButton = null;

	// Keyboard remapping
	private Map<Integer, KeyMapping> keyMap = new HashMap<>();
	private Map<Character, Character> inputCharMap = new HashMap<>();

	// Keymap persistence
	private static final String KEYMAP_FILE = System.getProperty("user.home") + File.separator + ".tn3270keymap";

	// Make KeyMapping serializable
	public static class KeyMapping implements java.io.Serializable {
		private static final long serialVersionUID = 1L;
		public char character;
		public Byte aid;
		public String description;

		KeyMapping(char character, String description) {
			this.character = character;
			this.aid = null;
			this.description = description;
		}

		KeyMapping(byte aid, String description) {
			this.character = '\0';
			this.aid = aid;
			this.description = description;
		}
	}

	// Selection state
	private boolean selecting = false;
	private int selectionStart = -1;
	private int selectionEnd = -1;
	private Point dragStart = null;

	private java.awt.Rectangle selectionRect = null;
	// These are updated by updateSize in TerminalCanvas
	private int charWidth = 9;
	private int charHeight = 16;

	// Color scheme settings (instance-specific)
	private Color screenBackground = Color.BLACK;
	private Color defaultForeground = Color.GREEN;
	private Color cursorColor = Color.WHITE;
	private Color[] colors;

	// --- Cursor Configuration ---
	public enum CursorStyle {
		BLOCK("Solid Box"), UNDERSCORE("Underscore"), I_BEAM("Vertical Line");

		private final String label;

		CursorStyle(String label) {
			this.label = label;
		}

		@Override
		public String toString() {
			return label;
		}
	}

	private CursorStyle cursorStyle = CursorStyle.BLOCK; // Default

	private boolean enableSound = true;
	private boolean autoAdvance = true;

	// =======================================================================
	// 4. CONSTRUCTOR
	// =======================================================================

	public TN3270Session(String modelName, TN3270Emulator parent) {
		super(new BorderLayout());
		this.parentEmulator = parent;

		this.model = modelName.trim();
		Dimension dim = MODELS.get(model);

		if (dim == null) {
			// Fallback to 3278-2
			System.err.println("Unknown model: " + model + ", using 3278-2");
			this.model = "3278-2";
			dim = MODELS.get(this.model);
		}

		// Always use the model's defined size for both Primary and Alternate.
		// This prevents the emulator from "shrinking" to 24 rows on a 0xF5 command
		// when the host actually intends to write to Row 32.
		primaryRows = dim.height;
		primaryCols = dim.width;
		alternateRows = dim.height;
		alternateCols = dim.width;

		// Start with alternate size
		rows = alternateRows;
		cols = alternateCols;
		useAlternateSize = true;

		colors = new Color[] { Color.BLACK, // 0 - Default
				Color.BLUE, // 1 Or maybe: Color.DODGERBLUE
				Color.RED, // 2
				Color.MAGENTA, // 3 Color.PINK
				Color.GREEN, // 4 Color.LIME
				Color.CYAN, // 5 Color.TURQUOISE
				Color.YELLOW, // 6
				Color.WHITE // 7 Color.WHITESMOKE
		};

		// int maxSize = primaryRows * primaryCols;
		// System.out.println("MaxSize computed as: " + maxSize);
		int maxSize = 4000;
		buffer = new char[maxSize];
		attributes = new byte[maxSize];
		extendedColors = new byte[maxSize];
		highlighting = new byte[maxSize];

		clearScreen();

		// setLayout(new BorderLayout()); // Already done in super() call

		// RibbonToolbar ribbon = new RibbonToolbar(this);
		// EnhancedRibbonToolbar ribbon = new EnhancedRibbonToolbar(this);
		// add(ribbon, BorderLayout.NORTH);
		// (Ribbon moved to Shell)

		canvas = new TerminalCanvas();
		// add(canvas, BorderLayout.CENTER);

		// Wrap the canvas in a ScrollPane
		JScrollPane scrollPane = new JScrollPane(canvas);

		// Ensure bars appear when the window is too small for the font
		scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
		scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);

		// Aesthetic: Remove the default border so it looks clean like a native terminal
		scrollPane.setBorder(null);

		// Optimization: The canvas isn't transparent, so this helps painting
		// performance
		scrollPane.getViewport().setOpaque(true);
		scrollPane.getViewport().setBackground(Color.BLACK);

		add(scrollPane, BorderLayout.CENTER);
		// canvas.updateSize(); // Called via hierarchy listener or explicitly later

		// Create menu bar
		// createMenuBar(); // Moved to Shell

		// JPanel bottomPanel = new JPanel(new BorderLayout());

		statusBar = new StatusBar();
		// bottomPanel.add(statusBar, BorderLayout.NORTH);
		// keyboardPanel = new ModernKeyboardPanel(this);
		// bottomPanel.add(keyboardPanel, BorderLayout.SOUTH);
		// add(bottomPanel, BorderLayout.SOUTH);

		// In Tabbed view, StatusBar is at bottom of this JPanel.
		// KeyboardPanel is shared in Shell.
		add(statusBar, BorderLayout.SOUTH);

		canvas.addKeyListener(this);

		initializeKeyMappings();

		// Start blink timer
		blinkTimer = new Timer(500, e -> canvas.repaint());
		blinkTimer.start();

		// Window Closing listener moved to Shell

		// Global Shortcuts moved to Shell

		// Hierarchy Listener (Auto-resize on first show)
		// Triggers a pack() when this panel is added to a real window
		addHierarchyListener(e -> {
			if ((e.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) != 0) {
				if (isDisplayable()) {
					SwingUtilities.invokeLater(this.canvas::updateSize);
				}
			}
		});

		// Ensure the component is focusable so it receives key events
		this.setFocusable(true);
	}

	// =======================================================================
	// 5. KEY MAP METHODS & ACCESSORS
	// =======================================================================

	public void setUseTLS(boolean useTLS) {
		this.useTLS = useTLS;
	}

	public void setRequestedLuName(String luName) {
		// Trim whitespace just in case
		if (luName != null && !luName.trim().isEmpty()) {
			this.requestedLuName = luName.trim();
		} else {
			this.requestedLuName = null;
		}
	}

	// Accessors for Shell/Dialogs
	public Map<Integer, KeyMapping> getKeyMap() {
		return keyMap;
	}

	public Map<Character, Character> getInputCharMap() {
		return inputCharMap;
	}

	public Frame getParentFrame() {
		if (parentEmulator != null)
			return parentEmulator;
		Window w = SwingUtilities.getWindowAncestor(this);
		return (w instanceof Frame) ? (Frame) w : null;
	}

	public boolean isConnected() {
		return connected;
	}

	@Override
	public boolean requestFocusInWindow() {
		if (canvas != null)
			return canvas.requestFocusInWindow();
		return super.requestFocusInWindow();
	}

	public void saveKeyMappings() {
		try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(KEYMAP_FILE))) {
			out.writeObject(new HashMap<>(keyMap));
			System.out.println("Keymaps saved to " + KEYMAP_FILE);
		} catch (IOException e) {
			System.err.println("Could not save keymaps: " + e.getMessage());
		}
	}

	@SuppressWarnings("unchecked")
	public void loadKeyMappings() {
		File file = new File(KEYMAP_FILE);
		if (!file.exists()) {
			return;
		}

		try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(file))) {
			Map<Integer, KeyMapping> loaded = (Map<Integer, KeyMapping>) in.readObject();
			keyMap.clear();
			keyMap.putAll(loaded);
			System.out.println("Keymaps loaded from " + KEYMAP_FILE);
		} catch (IOException | ClassNotFoundException e) {
			System.err.println("Could not load keymaps: " + e.getMessage());
		}
	}

	// Update initializeKeyMappings to load saved mappings
	private void initializeKeyMappings() {
		// 1. Physical Key Overrides (AID keys, etc)
		keyMap.put(KeyEvent.VK_BACK_QUOTE, new KeyMapping('¬', "Not sign"));

		// 2. Character Replacements (Fixing broken bars, etc)
		// This preserves the Shift logic but swaps the resulting character
		inputCharMap.clear();
		inputCharMap.put('¦', '|'); // Convert Broken Bar to Solid Pipe

		// Try to load saved mappings
		loadKeyMappings();
	}

	// =======================================================================
	// 6. NETWORKING METHODS
	// =======================================================================

	private SSLSocketFactory createTrustAllSSLSocketFactory() {
		try {
			// Create a trust manager that does not validate certificate chains
			TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
				public java.security.cert.X509Certificate[] getAcceptedIssuers() {
					return null;
				}

				public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
				}

				public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
				}
			} };

			// Install the all-trusting trust manager
			SSLContext sc = SSLContext.getInstance("TLS");
			sc.init(null, trustAllCerts, new java.security.SecureRandom());
			return sc.getSocketFactory();

		} catch (Exception e) {
			e.printStackTrace();
			return (SSLSocketFactory) SSLSocketFactory.getDefault();
		}
	}

	public void connect(String hostname, int port) {
		this.currentHost = hostname;
		this.currentPort = port;

		// Run in a separate thread so the UI doesn't freeze during the handshake
		new Thread(() -> {
			try {
				if (useTLS) {
					SSLSocketFactory factory = createTrustAllSSLSocketFactory();
					socket = factory.createSocket(hostname, port);

					if (socket instanceof SSLSocket) {
						SSLSocket sslSocket = (SSLSocket) socket;
						// Modern + Legacy support
						sslSocket.setEnabledProtocols(new String[] { "TLSv1.2", "TLSv1.3" });

						// Connection timeout is handled by the socket creation in SSL,
						// but read timeout should be 0 (infinite) for Telnet
						socket.setSoTimeout(0);

						sslSocket.startHandshake();
					}

					// Update status on EDT
					SwingUtilities.invokeLater(() -> statusBar.setStatus("TLS connected to " + hostname + ":" + port));
				} else {
					socket = new Socket();
					// 5-second timeout for initial connection
					socket.connect(new InetSocketAddress(hostname, port), 5000);

					SwingUtilities.invokeLater(() -> statusBar.setStatus("Connected to " + hostname + ":" + port));
				}

				// Update IP in Status Bar
				if (socket != null && socket.isConnected()) {
					String remoteIP = socket.getInetAddress().getHostAddress();
					SwingUtilities.invokeLater(() -> statusBar.setIP(remoteIP));
				}

				input = socket.getInputStream();
				output = socket.getOutputStream();
				connected = true;

				// Reset state
				currentColor = 0;
				currentHighlight = 0;

				// If you have a parent frame callback for menus, call it here
				// if (parentFrame != null) parentFrame.updateStatusIndicators();

				// Start the Reader
				readerThread = new Thread(this::readLoop);
				readerThread.start();

				// NOTE: We do NOT start a blinkThread here because the
				// TN3270Session constructor already started a Swing Timer for that.

			} catch (IOException e) {
				// 1. Cleanup resources
				try {
					if (socket != null)
						socket.close();
				} catch (IOException ignored) {
				}
				connected = false;

				// 2. Handle UI updates on the Event Thread
				SwingUtilities.invokeLater(() -> {
					if (statusBar != null) {
						statusBar.setStatus("Connection failed");
						statusBar.setIP("");
					}

					// Show the error dialog (Blocking call)
					JOptionPane
							.showMessageDialog(this,
									"Could not connect to host: " + hostname + "\n" + "Port: " + port + "\n\n"
											+ "Reason: " + e.getMessage(),
									"Connection Error", JOptionPane.ERROR_MESSAGE);

					// 3. Close THIS window (Monolith behavior)
					// In tabbed version, we might just leave the tab open but disconnected
					// this.dispose();

					// 4. Check if this was the last window open
					// (Logic removed for Tabbed version)
				});
			}
		}).start(); // End of Thread
	}

	public void disconnect() {
		connected = false;

		// Clear IP display
		if (statusBar != null) {
			statusBar.setIP(""); // Clear the IP label
			statusBar.setStatus("Disconnected");
		}

		// updateStatusIndicators();

		try {
			if (socket != null)
				socket.close();
		} catch (IOException e) {
			// Ignore
		}
	}

	public void reconnect() {
		if (socket != null && !socket.isClosed()) {
			try {
				String hostname = socket.getInetAddress().getHostName();
				int port = socket.getPort();
				disconnect();

				// Brief delay to ensure clean disconnect
				Thread.sleep(500);

				connect(hostname, port);
			} catch (Exception e) {
				statusBar.setStatus("Reconnect failed: " + e.getMessage());
			}
		} else if (currentHost != null && !currentHost.isEmpty()) {
			// Fallback for tabbed logic if socket is null but we have history
			disconnect();
			connect(currentHost, currentPort);
		} else {
			// showMessageDialog("No previous connection to reconnect to", "Reconnect");
			JOptionPane.showMessageDialog(this, "No previous connection to reconnect to", "Reconnect",
					JOptionPane.INFORMATION_MESSAGE);
		}
	}

	// =======================================================================
	// 6. FILE TRANSFER (IND$FILE) - UI & LOGIC
	// =======================================================================

	// MISSING UI METHOD: File Transfer Setup Dialog
	public void showFileTransferDialog(boolean isDownload) {
		if (!connected) {
			JOptionPane.showMessageDialog(getParentFrame(), "Not connected to host.", "Connection Required",
					JOptionPane.WARNING_MESSAGE);
			return;
		}

		JDialog dialog = new JDialog(getParentFrame(), isDownload ? "Download from Host" : "Upload to Host", true);
		dialog.setLayout(new BorderLayout());

		JPanel mainPanel = new JPanel(new GridBagLayout());
		mainPanel.setBorder(new EmptyBorder(15, 15, 15, 15));
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = new Insets(5, 5, 5, 5);
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.WEST;

		// --- Row 1: Host Type ---
		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.weightx = 0;
		mainPanel.add(new JLabel("Host System:"), gbc);

		gbc.gridx = 1;
		gbc.weightx = 1.0;
		gbc.gridwidth = 2;
		JComboBox<String> hostTypeBox = new JComboBox<>(new String[] { "TSO (z/OS)", "CMS (z/VM)" });
		hostTypeBox.setSelectedIndex(hostType == HostType.TSO ? 0 : 1);
		mainPanel.add(hostTypeBox, gbc);

		// --- Row 2: Local File ---
		gbc.gridx = 0;
		gbc.gridy = 1;
		gbc.weightx = 0;
		gbc.gridwidth = 1;
		mainPanel.add(new JLabel("Local File:"), gbc);

		gbc.gridx = 1;
		gbc.weightx = 1.0;
		JTextField localFileField = new JTextField(30);
		mainPanel.add(localFileField, gbc);

		gbc.gridx = 2;
		gbc.weightx = 0;
		JButton browseBtn = new JButton("Browse...");
		mainPanel.add(browseBtn, gbc);

		// --- Row 3: Host Dataset ---
		gbc.gridx = 0;
		gbc.gridy = 2;
		JLabel datasetLabel = new JLabel("Host Dataset:");
		mainPanel.add(datasetLabel, gbc);

		gbc.gridx = 1;
		gbc.weightx = 1.0;
		gbc.gridwidth = 2;
		JTextField hostDatasetField = new JTextField(30);
		hostDatasetField.setText(hostType == HostType.TSO ? "USER.TEST.DATA" : "TEST DATA A");
		mainPanel.add(hostDatasetField, gbc);

		// --- Row 4: Transfer Mode ---
		gbc.gridx = 0;
		gbc.gridy = 3;
		gbc.gridwidth = 1;
		gbc.weightx = 0;
		mainPanel.add(new JLabel("Transfer Mode:"), gbc);

		gbc.gridx = 1;
		gbc.gridwidth = 2;
		JComboBox<String> modeBox = new JComboBox<>(new String[] { "ASCII (Text)", "BINARY" });
		mainPanel.add(modeBox, gbc);

		// --- Row 5: Options ---
		gbc.gridx = 0;
		gbc.gridy = 4;
		gbc.gridwidth = 3;
		JPanel optionsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		JCheckBox crlfCheck = new JCheckBox("CRLF (Text Mode)", true);
		JCheckBox appendCheck = new JCheckBox("Append", false);
		optionsPanel.add(crlfCheck);
		optionsPanel.add(Box.createHorizontalStrut(15));
		optionsPanel.add(appendCheck);
		mainPanel.add(optionsPanel, gbc);

		// --- Advanced Allocation Panel (TSO/CMS Params) ---
		gbc.gridy = 5;
		JPanel allocPanel = new JPanel(new GridBagLayout());
		allocPanel.setBorder(BorderFactory.createTitledBorder("Host Allocation / Format Parameters"));

		GridBagConstraints agbc = new GridBagConstraints();
		agbc.insets = new Insets(2, 5, 2, 5);
		agbc.fill = GridBagConstraints.HORIZONTAL;

		// Line 1: RECFM | LRECL
		agbc.gridx = 0;
		agbc.gridy = 0;
		agbc.weightx = 0;
		allocPanel.add(new JLabel("RECFM:"), agbc);

		agbc.gridx = 1;
		agbc.weightx = 0.5;
		JComboBox<String> recfmBox = new JComboBox<>(new String[] { "V", "F", "U", "" });
		allocPanel.add(recfmBox, agbc);

		agbc.gridx = 2;
		agbc.weightx = 0;
		allocPanel.add(new JLabel("LRECL:"), agbc);

		agbc.gridx = 3;
		agbc.weightx = 0.5;
		JTextField lreclField = new JTextField("", 5);
		allocPanel.add(lreclField, agbc);

		// Line 2: BLKSIZE | SPACE
		agbc.gridx = 0;
		agbc.gridy = 1;
		agbc.weightx = 0;
		allocPanel.add(new JLabel("BLKSIZE:"), agbc);

		agbc.gridx = 1;
		agbc.weightx = 0.5;
		JTextField blksizeField = new JTextField("", 6);
		allocPanel.add(blksizeField, agbc);

		agbc.gridx = 2;
		agbc.weightx = 0;
		JLabel spaceLabel = new JLabel("SPACE:");
		allocPanel.add(spaceLabel, agbc);

		agbc.gridx = 3;
		agbc.weightx = 0.5;
		JTextField spaceField = new JTextField("", 8);
		spaceField.setToolTipText("Primary,Secondary (TSO Only)");
		allocPanel.add(spaceField, agbc);

		mainPanel.add(allocPanel, gbc);

		dialog.add(mainPanel, BorderLayout.CENTER);

		// --- Bottom Buttons ---
		JPanel btnPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
		JButton transferBtn = new JButton(isDownload ? "Download" : "Upload");
		JButton cancelBtn = new JButton("Cancel");

		btnPanel.add(cancelBtn);
		btnPanel.add(transferBtn);
		dialog.add(btnPanel, BorderLayout.SOUTH);

		dialog.getRootPane().setDefaultButton(transferBtn);

		// --- Logic Listeners ---
		hostTypeBox.addActionListener(e -> {
			boolean tso = (hostTypeBox.getSelectedIndex() == 0);
			datasetLabel.setText(tso ? "Host Dataset:" : "Host File:");
			if (tso && hostDatasetField.getText().contains(" "))
				hostDatasetField.setText("USER.TEST.DATA");
			else if (!tso && hostDatasetField.getText().contains("."))
				hostDatasetField.setText("TEST DATA A");
			spaceLabel.setVisible(tso);
			spaceField.setVisible(tso);
		});

		modeBox.addActionListener(e -> crlfCheck.setEnabled(modeBox.getSelectedIndex() == 0));

		browseBtn.addActionListener(e -> {
			JFileChooser fc = new JFileChooser();
			if (!localFileField.getText().isEmpty()) {
				fc.setSelectedFile(new File(localFileField.getText()));
			}
			int rc = isDownload ? fc.showSaveDialog(dialog) : fc.showOpenDialog(dialog);
			if (rc == JFileChooser.APPROVE_OPTION) {
				localFileField.setText(fc.getSelectedFile().getAbsolutePath());
			}
		});

		transferBtn.addActionListener(e -> {
			String localFile = localFileField.getText().trim();
			String hostDataset = hostDatasetField.getText().trim();

			if (localFile.isEmpty() || hostDataset.isEmpty()) {
				JOptionPane.showMessageDialog(dialog, "Please specify file paths.", "Validation Error",
						JOptionPane.ERROR_MESSAGE);
				return;
			}

			// --- LRECL DEFAULT LOGIC ---
			boolean isAscii = (modeBox.getSelectedIndex() == 0);
			String lrecl = lreclField.getText().trim();
			if (!isDownload && lrecl.isEmpty() && !isAscii) {
				lrecl = "255";
			}

			// Commit values
			hostType = hostTypeBox.getSelectedIndex() == 0 ? HostType.TSO : HostType.CMS;

			String cmd = buildIndFileCommand(isDownload, hostType == HostType.TSO, hostDataset, isAscii,
					crlfCheck.isSelected(), appendCheck.isSelected(), (String) recfmBox.getSelectedItem(), lrecl,
					blksizeField.getText().trim(), spaceField.getText().trim());

			dialog.dispose();

			// Start
			initiateFileTransfer(localFile, cmd, isDownload);
		});

		cancelBtn.addActionListener(e -> dialog.dispose());

		dialog.pack();
		dialog.setLocationRelativeTo(getParentFrame());
		dialog.setVisible(true);
	}
/*
	public void initiateFileTransfer(String localFilePath, String command, boolean isDownload) {
		try {
			currentFile = new File(localFilePath);
			ftDirection = isDownload ? FileTransferDirection.DOWNLOAD : FileTransferDirection.UPLOAD;
			ftIsText = command.toUpperCase().contains("ASCII") || command.toUpperCase().contains("CRLF");
			ftIsMessage = false;
			ftHadSuccessfulTransfer = false;

			System.out.println("Initiating file transfer: " + command);

			showProgressDialog(isDownload ? "Downloading from Host" : "Uploading to Host");
			updateProgressDialog("Sending command to host...", currentFile.getName());

			// Position Cursor and Send Command logic (abbreviated here for context match,
			// but assume full logic)
			// ... (Cursor finding logic) ...

			// Send Command
			// ... (Typing logic) ...

			// For now, assuming command sent via:
			// sendAID(AID_ENTER);

		} catch (Exception e) {
			e.printStackTrace();
			statusBar.setStatus("File transfer error: " + e.getMessage());
			closeProgressDialog();
		}
	}
*/
	// Build IND$FILE command
	public String buildIndFileCommand(boolean isDownload, boolean isTSO, String hostDataset, boolean isAscii,
			boolean useCrlf, boolean append, String recfm, String lrecl, String blksize, String space) {
		StringBuilder cmd = new StringBuilder();
		cmd.append("IND$FILE ");
		cmd.append(isDownload ? "GET " : "PUT ");
		cmd.append(hostDataset);

		if (!isTSO) { // CMS
			StringBuilder params = new StringBuilder();
			if (isAscii)
				params.append(" ASCII");
			if (useCrlf && isAscii)
				params.append(" CRLF");
			if (append)
				params.append(" APPEND");
			if (!isDownload && !recfm.isEmpty()) {
				params.append(" RECFM ").append(recfm);
				if (!lrecl.isEmpty())
					params.append(" LRECL ").append(lrecl);
			}
			if (params.length() > 0)
				cmd.append(" (").append(params.toString().trim()).append(")");
		} else { // TSO
			if (isAscii)
				cmd.append(" ASCII");
			if (useCrlf && isAscii)
				cmd.append(" CRLF");
			if (append)
				cmd.append(" APPEND");
			if (!isDownload) {
				if (!recfm.isEmpty())
					cmd.append(" RECFM(").append(recfm).append(")");
				if (!lrecl.isEmpty())
					cmd.append(" LRECL(").append(lrecl).append(")");
				if (!blksize.isEmpty())
					cmd.append(" BLKSIZE(").append(blksize).append(")");
				if (!space.isEmpty())
					cmd.append(" SPACE(").append(space).append(")");
			} else {
				if (isAscii && !recfm.isEmpty())
					cmd.append(" RECFM(").append(recfm).append(")");
			}
		}
		return cmd.toString();
	}

	// --- Helper Methods for Progress Dialog ---

	private void showProgressDialog(String operation) {
		if (progressDialog != null)
			progressDialog.dispose();

		progressDialog = new JDialog(getParentFrame(), "File Transfer", false);
		progressDialog.setLayout(new BorderLayout());

		JPanel panel = new JPanel(new GridBagLayout());
		panel.setBorder(new EmptyBorder(15, 15, 15, 15));
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = new Insets(5, 5, 5, 5);
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.gridwidth = 1;

		gbc.gridx = 0;
		gbc.gridy = 0;
		JLabel title = new JLabel(operation);
		title.setFont(new Font("SansSerif", Font.BOLD, 12));
		panel.add(title, gbc);

		gbc.gridy = 1;
		transferProgressBar = new JProgressBar();
		transferProgressBar.setIndeterminate(true);
		panel.add(transferProgressBar, gbc);

		gbc.gridy = 2;
		progressLabel = new JLabel("Initializing...");
		panel.add(progressLabel, gbc);

		gbc.gridy = 3;
		transferStatusLabel = new JLabel(" ");
		panel.add(transferStatusLabel, gbc);

		gbc.gridy = 4;
		cancelTransferButton = new JButton("Cancel");
		cancelTransferButton.addActionListener(e -> {
			ftState = FileTransferState.IDLE;
			statusBar.setStatus("Transfer cancelled");
			closeProgressDialog();
		});
		panel.add(cancelTransferButton, gbc);

		progressDialog.add(panel, BorderLayout.CENTER);
		progressDialog.pack();
		progressDialog.setLocationRelativeTo(this);
		progressDialog.setVisible(true);
	}

	private void updateProgressDialog(String progress, String status) {
		SwingUtilities.invokeLater(() -> {
			if (progressLabel != null)
				progressLabel.setText(progress);
			if (transferStatusLabel != null)
				transferStatusLabel.setText(status);
		});
	}

	private void closeProgressDialog() {
		SwingUtilities.invokeLater(() -> {
			if (progressDialog != null) {
				progressDialog.dispose();
				progressDialog = null;
			}
		});
	}

	// --- Message Dialog Wrappers ---
	private void showMessageDialog(String msg, String title, boolean isError) {
		JOptionPane.showMessageDialog(getParentFrame(), msg, title,
				isError ? JOptionPane.ERROR_MESSAGE : JOptionPane.INFORMATION_MESSAGE);
	}

	private void showMessageDialog(String msg, String title) {
		showMessageDialog(msg, title, false);
	}

	// =======================================================================
	// 7. TELNET READ LOOP & PROTOCOL HANDLERS
	// =======================================================================

	private void readLoop() {
		byte[] buf = new byte[8192];
		ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
		ByteArrayOutputStream subnegBuffer = new ByteArrayOutputStream();

		// Persistent state across loop iterations
		int telnetState = STATE_DATA;

		try {
			while (connected) {
				int n = input.read(buf);
				if (n <= 0)
					break;

				System.out.println("=== ALL RECEIVED BYTES (readLoop) ===");
				for (int j = 0; j < n; j++) {
					System.out.print(String.format("%02X ", buf[j]));
					if ((j + 1) % 16 == 0)
						System.out.println();
				}
				System.out.println();

				for (int i = 0; i < n; i++) {
					byte b = buf[i];

					switch (telnetState) {
					case STATE_DATA:
						if (b == IAC) {
							telnetState = STATE_IAC;
						} else {
							dataStream.write(b);
						}
						break;

					case STATE_IAC:
						switch (b) {
						case IAC:
							// Double IAC = Literal 0xFF data
							dataStream.write((byte) 0xFF);
							telnetState = STATE_DATA;
							break;
						case SB:
							telnetState = STATE_SB;
							subnegBuffer.reset();
							break;
						case WILL:
							telnetState = STATE_WILL;
							break;
						case WONT:
							telnetState = STATE_WONT;
							break;
						case DO:
							telnetState = STATE_DO;
							break;
						case DONT:
							telnetState = STATE_DONT;
							break;
						case (byte) 0xEF: // EOR
							if (dataStream.size() > 0) {
								// Process the record immediately
								process3270Data(dataStream.toByteArray());
								// Reset to capture the NEXT record in this same packet
								dataStream.reset();
							}
							telnetState = STATE_DATA;
							break;
						default:
							// Other commands (NOP, GA, etc) are ignored
							telnetState = STATE_DATA;
							break;
						}
						break;

					case STATE_WILL:
						handleTelnetCommand(WILL, b);
						telnetState = STATE_DATA;
						break;
					case STATE_WONT:
						handleTelnetCommand(WONT, b);
						telnetState = STATE_DATA;
						break;
					case STATE_DO:
						handleTelnetCommand(DO, b);
						telnetState = STATE_DATA;
						break;
					case STATE_DONT:
						handleTelnetCommand(DONT, b);
						telnetState = STATE_DATA;
						break;

					case STATE_SB:
						if (b == SE) {
							// Check if preceding byte was IAC
							// (We need a specialized check here because SE is 0xF0,
							// we need to ensure we saw IAC before this SE)

							// Robust approach: Check buffer content
							byte[] sn = subnegBuffer.toByteArray();
							if (sn.length > 0 && sn[sn.length - 1] == IAC) {
								// Valid Subnegotiation End
								byte[] cleanData = new byte[sn.length - 1];
								System.arraycopy(sn, 0, cleanData, 0, cleanData.length);
								handleSubnegotiation(cleanData);
								telnetState = STATE_DATA;
							} else {
								subnegBuffer.write(b);
							}
						} else if (b == IAC) {
							// Just record it, next byte determines if it is SE or escaped IAC
							subnegBuffer.write(b);
						} else {
							subnegBuffer.write(b);
						}
						break;
					}
				}
			}
		} catch (IOException e) {
			if (connected)
				statusBar.setStatus("Connection lost: " + e.getMessage());
		}
		connected = false;
	}

	private void handleTelnetCommand(byte command, byte option) throws IOException {
		System.out.println("Telnet: " + String.format("%02X %02X", command, option));

		if (command == DO) {
			if (option == OPT_TERMINAL_TYPE || option == OPT_BINARY || option == OPT_EOR) {
				sendTelnet(WILL, option);
			} else if (option == OPT_TN3270E) {
				if (!tn3270eAttempted && !tn3270eFailed) {
					tn3270eAttempted = true;
					sendTelnet(WILL, option);
					System.out.println("Server requested TN3270E - attempting");
				} else {
					sendTelnet(WONT, option);
					System.out.println("Server requested TN3270E - already failed, declining");
				}
			} else {
				sendTelnet(WONT, option);
			}
		} else if (command == DONT) {
			if (option == OPT_TN3270E) {
				System.out.println("Server rejected TN3270E");
				tn3270eMode = false;
				tn3270eFailed = true;
			}
			sendTelnet(WONT, option);
		} else if (command == WILL) {
			if (option == OPT_BINARY || option == OPT_EOR) {
				sendTelnet(DO, option);
			} else if (option == OPT_TN3270E) {
				if (!tn3270eAttempted && !tn3270eFailed) {
					tn3270eAttempted = true;
					sendTelnet(DO, option);
					System.out.println("Server offers TN3270E - accepting");
				} else {
					sendTelnet(DONT, option);
					System.out.println("Server offers TN3270E - already failed, declining");
				}
			} else {
				sendTelnet(DONT, option);
			}
		} else if (command == WONT) {
			if (option == OPT_TN3270E) {
				System.out.println("Server won't do TN3270E");
				tn3270eMode = false;
				tn3270eFailed = true;
			}
			sendTelnet(DONT, option);
		}
	}

	//
	// An OSA ICC requires a three-way handshake:
	//
	// Server: SEND DEVICE-TYPE
	// Client: DEVICE-TYPE IS <model> CONNECT <luname>
	// Server: FUNCTIONS REQUEST
	// Client: FUNCTIONS IS <list>
	//
	private void handleTN3270ESubneg(byte[] data) throws IOException {
		if (data.length < 2)
			return;

		byte opcode = data[1];

		switch (opcode) {
		case TN3270E_OP_SEND:
			if (data.length >= 3) {
				byte what = data[2];
				if (what == TN3270E_OP_DEVICE_TYPE) {
					sendTN3270EDeviceTypeAndConnect();
				} else if (what == TN3270E_OP_FUNCTIONS) {
					System.out.println("TN3270E: Server requested Functions.");
					sendTN3270ERequestFunctionsIS();
				}
			}
			break;

		case TN3270E_OP_DEVICE_TYPE:
			if (data.length >= 3) {
				byte typeOp = data[2];
				if (typeOp == TN3270E_OP_IS) {
					System.out.println("TN3270E: Device Type agreed.");

					// CRITICAL FIX: Do NOT enable tn3270eMode here!
					// We are still in basic Telnet mode for the Functions negotiation.
					// tn3270eMode = true; <--- DELETED
					// tn3270eMode = true;
					// tn3270eNegotiationComplete = true;
					// statusBar.setStatus("TN3270E Connected");

					// Trigger Functions Request
					System.out.println("TN3270E: Sending Functions Request...");
					sendTN3270ERequestFunctions();

				} else if (typeOp == TN3270E_OP_REJECT) {
					System.err.println("TN3270E: Server REJECTED Device Type.");
					fallBackToTN3270();
				}
			}
			break;

		case TN3270E_OP_FUNCTIONS:
			if (data.length >= 3) {
				byte funcOp = data[2];

				if (funcOp == TN3270E_OP_REQUEST) {
					sendTN3270EFunctions();
				} else if (funcOp == TN3270E_OP_IS) {
					System.out.println("TN3270E: Functions accepted. Mode Active.");

					// ENABLE NOW: Negotiation is complete.
					// All future packets from Host will have the 5-byte Header.
					tn3270eMode = true;
					tn3270eNegotiationComplete = true;
					statusBar.setStatus("TN3270E Connected");

					// Announce capabilities (DFT, Color, etc)
					sendQueryResponse();
				}
			}
			break;

		case TN3270E_OP_REQUEST:
			if (data.length >= 3 && data[2] == TN3270E_OP_FUNCTIONS) {
				sendTN3270EFunctions();
			}
			break;

		default:
			System.out.printf("TN3270E: Unhandled Opcode %02X\n", opcode);
			break;
		}
	}

	private void sendTN3270EDeviceTypeAndConnect() throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);

		// RFC 2355 standard response to SEND is IS (0x04), but PCOMM sends REQUEST
		// (0x07).
		// Since PCOMM works with OSA-ICC, we mimic PCOMM.
		baos.write(TN3270E_OP_DEVICE_TYPE); // 0x02
		baos.write(TN3270E_OP_REQUEST); // 0x07

		// IMPORTANT: Append "-E" to indicate we support Enhanced mode.
		// Without this, the OSA-ICC will reject TN3270E and fallback to legacy mode.
		String fullModel = "IBM-" + this.model + "-E";

		baos.write(fullModel.getBytes(StandardCharsets.US_ASCII));

		if (this.requestedLuName != null && !this.requestedLuName.trim().isEmpty()) {
			baos.write(TN3270E_OP_CONNECT);
			baos.write(this.requestedLuName.trim().getBytes(StandardCharsets.US_ASCII));
			System.out.println("TN3270E: Requesting LU [" + this.requestedLuName + "]");
		}

		baos.write(IAC);
		baos.write(SE);

		output.write(baos.toByteArray());
		output.flush();
		System.out.println("TN3270E: Sent DEVICE-TYPE REQUEST " + fullModel);
	}

	private void sendTN3270EFunctions() throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);

		// Opcode: FUNCTIONS IS (0x08)
		// We tell the server what we are willing to support.
		// baos.write(TN3270E_OP_FUNCTIONS); // 0x08 OR 0x04 (IS) depending on context,
		// but usually 0x08 in response to
		// 0x08

		// Response syntax: FUNCTIONS IS ...
		baos.write(TN3270E_OP_FUNCTIONS); // 0x03 (Option)
		baos.write(TN3270E_OP_IS); // 0x04 (Opcode)

		// Functions:
		// 0x00: BIND-IMAGE (Essential for 3270E)
		// 0x01: DATA-STREAM-CTL (Essential)
		// 0x02: RESPONSES (Essential for structured fields)
		// 0x03: SYSREQ (Optional, but good to have)
		// 0x04: SCS-CTL (Printer - usually don't send this for display)

		baos.write(0x00); // BIND-IMAGE
		baos.write(0x01); // DATA-STREAM-CTL
		baos.write(0x02); // RESPONSES
		baos.write(0x03); // SYSREQ

		baos.write(IAC);
		baos.write(SE);

		output.write(baos.toByteArray());
		output.flush();

		tn3270eMode = true; // Enable extended processing
		System.out.println("TN3270E: Sent FUNCTIONS IS (BIND, DATA, RESP, SYSREQ)");
	}

	private void handleSubnegotiation(byte[] data) throws IOException {
		if (data.length < 2)
			return;

		byte option = data[0];
		if (option == OPT_TERMINAL_TYPE && data.length > 1 && data[1] == 1) {
			sendTerminalType();
		} else if (option == OPT_TN3270E) {
			handleTN3270ESubneg(data);
		}
	}

	private void handleTN3270ESubnegotiation(byte[] data) throws IOException {
		// data[0] should be 0x28 (TN3270E)
		if (data.length < 3)
			return;
		int func = data[1] & 0xFF;

		switch (func) {
		case 0x08: // FUNCTIONS IS
			System.out.println("TN3270E subnegotiation: FUNCTIONS IS received");
			sendTN3270ERequestFunctions();
			break;

		case 0x06: // CONNECT
			System.out.println("TN3270E subnegotiation: CONNECT received");
			sendTN3270EConnectReply();
			break;

		default:
			System.out.printf("TN3270E subnegotiation: unhandled function 0x%02X\n", func);
			break;
		}
	}

	private void sendTN3270EConnect(String model) throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);
		baos.write(6); // CONNECT
		baos.write("IBM-".getBytes());
		baos.write(model.getBytes());
		baos.write(IAC);
		baos.write(SE);
		output.write(baos.toByteArray());
		output.flush();
	}

	private void sendTN3270EConnectReply() throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();

		// Start subnegotiation
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);

		// Function = CONNECT REPLY
		baos.write(6); // 0x06

		// CONNECT REPLY data fields:
		// Format: [ConnectType (1)] [Response (1)] [LU name (variable, EBCDIC)]

		// ConnectType = 0x00 (default device)
		baos.write(0x00);

		// Response = 0x00 (success)
		baos.write(0x00);

		// LU Name — optional. Leave blank unless your host requires one.
		// If you need to send one, encode it in EBCDIC.
		// Example:
		// byte[] luName = "LUNAME".getBytes("Cp037");
		// baos.write(luName);

		// End subnegotiation
		baos.write(IAC);
		baos.write(SE);

		// Send it
		output.write(baos.toByteArray());
		output.flush();

		System.out.println("Sent TN3270E CONNECT REPLY (OK, default device)");
	}

	private void sendTN3270EDeviceType() throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);
		baos.write(4); // DEVICE-TYPE IS
		baos.write("IBM-".getBytes());
		baos.write(model.getBytes());
		baos.write("-E".getBytes());
		baos.write(IAC);
		baos.write(SE);
		output.write(baos.toByteArray());
		output.flush();
		System.out.println("Sent TN3270E DEVICE-TYPE IS: IBM-" + model + "-E");
	}

	private void sendTN3270EDeviceType(String model) throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);
		baos.write(4); // DEVICE-TYPE IS
		baos.write(("IBM-" + model + "-E").getBytes());
		baos.write(IAC);
		baos.write(SE);
		output.write(baos.toByteArray());
		output.flush();
		System.out.println("Sent DEVICE-TYPE IS: IBM-" + model + "-E");
	}

	private void sendTN3270ESendFunctionsRequest() throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);
		baos.write(3); // SEND FUNCTIONS
		baos.write(IAC);
		baos.write(SE);
		output.write(baos.toByteArray());
		output.flush();
		System.out.println("Sent TN3270E SEND FUNCTIONS request");
	}

	private void sendTN3270ERequestFunctions() throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();

		// Start TN3270E subnegotiation
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);

		// FIX: Must specify the operation is regarding FUNCTIONS (0x03)
		baos.write(TN3270E_OP_FUNCTIONS); // 0x03

		// Function code: REQUEST-FUNCTIONS (0x09)
		// baos.write(0x09);
		// Change 0x09 to TN3270E_OP_REQUEST (0x07)
		baos.write(TN3270E_OP_REQUEST);

		// Functions list we support: BIND-IMAGE(0x00), DATA-STREAM-CTL(0x01),
		// RESPONSES(0x02), SYSREQ(0x03)
		baos.write(0x00);
		baos.write(0x01);
		baos.write(0x02);
		baos.write(0x03);

		// End subnegotiation
		baos.write(IAC);
		baos.write(SE);

		output.write(baos.toByteArray());
		output.flush();

		System.out.println("Sent TN3270E REQUEST FUNCTIONS (00,01,02,03)");
	}

	private void sendTN3270ERequestFunctionsIS() throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();

		// Start TN3270E subnegotiation
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TN3270E);

		// FIX: Must specify the operation is regarding FUNCTIONS (0x03)
		baos.write(TN3270E_OP_FUNCTIONS); // 0x03

		// Function code: FUNCTIONS-IS (0x04)
		baos.write(TN3270E_OP_IS);

		// Functions list we support: BIND-IMAGE(0x00), DATA-STREAM-CTL(0x01),
		// RESPONSES(0x02), SYSREQ(0x03)
		baos.write(0x00);
		baos.write(0x01);
		baos.write(0x02);
		baos.write(0x03);

		// End subnegotiation
		baos.write(IAC);
		baos.write(SE);

		output.write(baos.toByteArray());
		output.flush();

		System.out.println("Sent TN3270E FUNCTIONS IS (00,01,02,03)");
	}

	private void fallBackToTN3270() {
		if (tn3270eFailed)
			return; // Already fallen back

		try {
			System.out.println("=== FALLING BACK TO TN3270 ===");
			tn3270eFailed = true;
			tn3270eMode = false;
			tn3270eNegotiationComplete = false;

			// Send WONT TN3270E to cancel
			sendTelnet(WONT, OPT_TN3270E);
			System.out.println("Sent WONT TN3270E");

			statusBar.setStatus("Using TN3270 mode (TN3270E not supported)");

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private String getFunctionName(byte function) {
		switch (function) {
		case 2:
			return "SEND DEVICE-TYPE";
		case 3:
			return "SEND FUNCTIONS";
		case 4:
			return "DEVICE-TYPE IS";
		case 7:
			return "FUNCTIONS IS";
		case 8:
			return "FUNCTIONS IS (alt)";
		default:
			return "UNKNOWN";
		}
	}

	private void sendTelnet(byte command, byte option) throws IOException {
		output.write(new byte[] { IAC, command, option });
		output.flush();
	}

	private void sendTerminalType() throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write(IAC);
		baos.write(SB);
		baos.write(OPT_TERMINAL_TYPE);
		baos.write(0); // IS
		baos.write("IBM-".getBytes());
		baos.write(model.getBytes());
		baos.write("-E".getBytes());
		baos.write(IAC);
		baos.write(SE);
		output.write(baos.toByteArray());
		output.flush();
	}

	// =======================================================================
	// 5. 3270 DATA STREAM LOGIC
	// =======================================================================

	private void process3270Data(byte[] data) {
		System.out.println("process3270Data: Length: " + data.length);
		if (data.length < 1)
			return;

		int offset = 0;

		if (tn3270eMode && data.length >= 5) {
			byte dataType = data[0];
			offset = 5;
			System.out.println("TN3270E Data type: " + String.format("%02X", dataType));

			if (dataType != TN3270E_DT_3270_DATA) {
				System.out.println("Non-3270-DATA type received, ignoring");
				return;
			}

			// If we are receiving TN3270E Data, the negotiation is definitely over.
			// If we haven't sent the Query Reply yet, send it NOW.
			if (!queryReplySent) {
				System.out.println("TN3270E: Server started data without Functions Confirm. Sending Query Reply.");
				sendQueryResponse();
				queryReplySent = true;
			}
		}

		if (offset >= data.length) {
			System.out.println("No 3270 command after TN3270E header");
			return;
		}

		byte command = data[offset++];
		System.out.println("3270 Command: " + String.format("%02X", command));
		switch (command) {
		case CMD_ERASE_WRITE_05:
		case CMD_ERASE_WRITE_F5:
			// Erase Write - use primary size
			if (useAlternateSize) {
				useAlternateSize = false;
				rows = primaryRows;
				cols = primaryCols;
				canvas.updateSize();
				System.out.println("Switched to primary size: " + cols + "x" + rows);
			}
			// currentCharSet = EBCDIC_TO_ASCII; // Reset to default
			clearScreen();
			// Fall through to normal WRITE processing
		case CMD_WRITE_01:
		case CMD_WRITE_F1:
			if (offset < data.length) {
				byte wcc = data[offset++];
				processWCC(wcc);
				processOrders(data, offset);
			}
			keyboardLocked = false;
			break;

		case CMD_ERASE_WRITE_ALTERNATE_0D:
		case CMD_ERASE_WRITE_ALTERNATE_7E:
			// Erase Write Alternate - switch to alternate size
			if (!useAlternateSize) {
				useAlternateSize = true;
				rows = alternateRows;
				cols = alternateCols;
				canvas.updateSize();
				System.out.println("Switched to alternate size: " + cols + "x" + rows);
			}
			// currentCharSet = EBCDIC_TO_ASCII; // Reset to default
			clearScreen();
			if (offset < data.length) {
				byte wcc = data[offset++];
				processWCC(wcc);
				processOrders(data, offset);
			}
			keyboardLocked = false;
			break;

		case CMD_READ_BUFFER_02:
		case CMD_READ_BUFFER_F2:
			sendReadBuffer();
			break;

		case CMD_READ_MODIFIED_06:
		case CMD_READ_MODIFIED_F6:
			sendAID(lastAID);
			break;

		case CMD_WSF_11:
		case CMD_WSF_F3:
			processWSF(data, offset);
			break;

		case CMD_ERASE_ALL_UNPROTECTED_0F:
		case CMD_ERASE_ALL_UNPROTECTED_6F:
			eraseAllUnprotected();
			break;
		}

		canvas.repaint();
		statusBar.update();
		System.out.println("Finished processing command 0x" + String.format("%02X", command));
	}

	private void eraseAllUnprotected() {
		// Erase all unprotected fields and reset MDT
		for (int i = 0; i < buffer.length; i++) {
			if (isFieldStart(i)) {
				// Reset MDT bit for ALL fields (Protected and Unprotected)
				attributes[i] &= ~0x01;
			} else if (!isProtected(i)) {
				// Clear unprotected field data
				buffer[i] = '\0';

				// Clear the "Ghost" attributes
				extendedColors[i] = 0;
				highlighting[i] = 0;
			}
		}

		keyboardLocked = false;
		canvas.repaint();
		statusBar.update();
	}

	private void processWCC(byte wcc) {
		if ((wcc & WCC_RESET) != 0) {
			keyboardLocked = false;

			// Reset Reply Mode if WCC_RESET
			resetReplyModeToDefault();
		}
		if ((wcc & WCC_RESET_MDT) != 0) {
			resetMDT();
		}
		if ((wcc & WCC_ALARM) != 0) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
		}
		statusBar.update();
	}

	private void processOrders(byte[] data, int offset) {
		int pos = 0;
		int i = offset;
		int currentFieldStart = -1;
		char c;

		// Helper array to pass index by reference to fetchDisplayChar
		int[] idxRef = new int[1];

		while (i < data.length) {
			byte b = data[i++];

			switch (b) {
			case ORDER_SF:
				if (i < data.length) {
					byte attr = data[i++];
					buffer[pos] = ' ';
					attributes[pos] = attr;
					extendedColors[pos] = 0;
					highlighting[pos] = 0;
					currentFieldStart = pos;
					currentColor = 0;
					currentHighlight = 0;
					pos = (pos + 1) % buffer.length;
				}
				break;

			case ORDER_SFE:
				if (i < data.length) {
					int count = data[i++] & 0xFF;
					currentColor = 0;
					currentHighlight = 0;
					byte attr = 0x00;
					byte color = 0;
					byte highlight = 0;

					for (int j = 0; j < count; j++) {
						if (i + 1 >= data.length)
							break;
						byte type = data[i++];
						byte value = data[i++];
						if (type == ATTR_FIELD || type == (byte) 0xC0)
							attr = value;
						else if (type == ATTR_FOREGROUND || type == (byte) 0x42)
							color = value;
						else if (type == ATTR_HIGHLIGHTING || type == (byte) 0x41)
							highlight = value;
					}

					buffer[pos] = ' ';
					attributes[pos] = attr;
					extendedColors[pos] = color;
					highlighting[pos] = highlight;
					currentFieldStart = pos;
					pos = (pos + 1) % buffer.length;
				}
				break;

			case ORDER_SA:
				if (i + 1 < data.length) {
					byte attrType = data[i++];
					byte attrValue = data[i++];
					if (attrType == ATTR_FOREGROUND || attrType == (byte) 0x42)
						currentColor = attrValue;
					else if (attrType == ATTR_HIGHLIGHTING || attrType == (byte) 0x41)
						currentHighlight = attrValue;
					else if (attrType == 0x00) {
						currentColor = 0;
						currentHighlight = 0;
					}
				}
				break;

			case ORDER_SBA:
				if (i + 1 < data.length) {
					pos = decode3270Address(data[i], data[i + 1]);
					i += 2;
				}
				break;

			case ORDER_IC:
				cursorPos = pos;
				if (isFieldStart(cursorPos))
					cursorPos = (cursorPos + 1) % buffer.length;
				break;

			case ORDER_RA:
				if (i + 2 < data.length) {
					int endPos = decode3270Address(data[i], data[i + 1]);

					// Use helper to fetch char (handles plain or GE)
					idxRef[0] = i + 2;
					c = fetchDisplayChar(data, idxRef);
					i = idxRef[0]; // Update index

					while (pos != endPos) {
						buffer[pos] = c;
						attributes[pos] = 0; // Clear attr
						extendedColors[pos] = currentColor;
						highlighting[pos] = currentHighlight;
						pos = (pos + 1) % buffer.length;
					}
				}
				break;

			case ORDER_EUA:
				if (i + 1 < data.length) {
					int endPos = decode3270Address(data[i], data[i + 1]);
					i += 2;
					while (pos != endPos) {
						if (!isProtected(pos) && !isFieldStart(pos)) {
							buffer[pos] = '\0';
							extendedColors[pos] = 0;
							highlighting[pos] = 0;
						}
						pos = (pos + 1) % buffer.length;
					}
				}
				break;

			case ORDER_MF:
				if (i < data.length) {
					int count = data[i++] & 0xFF;
					for (int j = 0; j < count && i + 1 < data.length; j++) {
						byte type = data[i++];
						byte value = data[i++];
						if (currentFieldStart >= 0 && (type == ATTR_FIELD || type == (byte) 0xC0)) {
							attributes[currentFieldStart] = value;
						}
					}
				}
				break;

			case ORDER_FM: // Field Mark
				System.out.println("FM order at offset " + i);
				break;
			case ORDER_PT: // Program Tab
				for (int k = 0; k < rows * cols; k++) {
					if (isFieldStart(pos) && !isProtected(pos)) {
						pos = (pos + 1) % buffer.length;
						break;
					}
					pos = (pos + 1) % buffer.length;
				}
				break;

			// --- FIX: Explicitly handle Graphic Escape ---
			case ORDER_GE:
				// Back up one byte (to the GE order) so fetchDisplayChar sees it
				idxRef[0] = i - 1;
				c = fetchDisplayChar(data, idxRef);
				i = idxRef[0]; // Advance index past GE and the graphic code

				buffer[pos] = c;
				attributes[pos] = 0; // Clear attribute if we overwrite one
				extendedColors[pos] = currentColor;
				highlighting[pos] = currentHighlight;
				pos = (pos + 1) % buffer.length;
				break;

			default:
				// Standard Character
				c = EBCDIC_TO_ASCII[b & 0xFF];
				buffer[pos] = c;
				attributes[pos] = 0;
				extendedColors[pos] = currentColor;
				highlighting[pos] = currentHighlight;
				pos = (pos + 1) % buffer.length;
				break;
			}
		}
	}

	private void processWSF(byte[] data, int offset) {
		System.out.println("=== processWSF called, offset=" + offset + ", data.length=" + data.length);

		int i = offset;

		while (i + 2 < data.length) {
			// Read length (2 bytes, big-endian, includes the length field itself)
			int length = ((data[i] & 0xFF) << 8) | (data[i + 1] & 0xFF);
			System.out.println("WSF: SF at offset " + i + ", Length = " + length);

			if (length < 3 || i + length > data.length) {
				System.out.println("WSF: Invalid length, stopping");
				break;
			}

			// SFID is at i+2
			byte sfid = data[i + 2];
			System.out.println("WSF: SFID = 0x" + String.format("%02X", sfid));

			if (sfid == 0x01) {
				// Read Partition - Query
				if (i + 3 < data.length) {
					byte pid = data[i + 3];
					byte qcode = i + 4 < data.length ? data[i + 4] : 0;
					System.out.println("WSF: Read Partition, PID=0x" + String.format("%02X", pid) + ", Qcode=0x"
							+ String.format("%02X", qcode));

					if (qcode == (byte) 0xFF || qcode == 0x02 || qcode == 0x03) {
						System.out.println("WSF: Sending Query Response");
						sendQueryResponse();
					}
				}
			} else if (sfid == SFID_DATA_CHAIN) {
				// Data Chain - IND$FILE operations
				handleDataChain(data, i, length);
			} else if (sfid == 0x40) {
				// Outbound 3270DS - contains embedded 3270 data
				System.out.println("WSF: Outbound 3270DS - contains embedded 3270 data");
			} else if (sfid == SF_ID_SET_REPLY_MODE) {
				handleSetReplyModeSF(data, i, length);
				// } else if (sfid == SF_ID_READ_PARTITION_QUERY_LIST) {
				// handleReadPartitionQueryList(data, i, length);
			} else {
				System.out.println("WSF: Unknown/unhandled SFID");
			}

			// Move to next structured field
			i += length;
		}
	}

	private void handleSetReplyModeSF(byte[] sfBuf, int offset, int len) {
		if (sfBuf == null || len <= 0 || offset < 0 || offset + len > sfBuf.length) {
			System.err.println("handleSetReplyModeSF: invalid params");
			return;
		}
		System.out.printf("handleSetReplyModeSF: offset=%d len=%d%n", offset, len);

		int p = offset;
		int end = offset + len;
		int flags = 0;

		// parse generic subfield triplets: [tag][len][payload...]
		while (p + 1 < end) {
			int tag = sfBuf[p++] & 0xFF;
			int slen = sfBuf[p++] & 0xFF;
			if (p + slen > end) {
				System.err.println("SetReplyMode SF truncated subfield; bailing");
				break;
			}

			// If this subfield is the reply-mode flags subfield (common implementations),
			// we aggregate up to 4 bytes into an int.
			for (int i = 0; i < Math.min(4, slen); i++) {
				flags = (flags << 8) | (sfBuf[p + i] & 0xFF);
			}
			p += slen;
		}

		// store raw flags for diagnostics
		this.replyModeFlags = flags;

		final int MASK_EXTENDED_FIELD = 0x01; // replace with exact mask from manual if needed
		final int MASK_CHARACTER = 0x02; // replace with exact mask from manual if needed

		if ((flags & MASK_CHARACTER) != 0) {
			currentReplyMode = ReplyMode.CHARACTER;
		} else if ((flags & MASK_EXTENDED_FIELD) != 0) {
			currentReplyMode = ReplyMode.EXTENDED_FIELD;
		} else {
			currentReplyMode = ReplyMode.FIELD;
		}

		System.out.printf("handleSetReplyModeSF -> rawFlags=0x%X mappedMode=%s%n", flags, currentReplyMode);
	}

	// Convenience: expose a reset helper
	private void resetReplyModeToDefault() {
		currentReplyMode = ReplyMode.FIELD;
		replyModeFlags = 0;
		// System.out.println("Reply Mode reset to FIELD (default).");
	}

	// =======================================================================
	// 6. FILE TRANSFER (IND$FILE) & DATA CHAIN
	// =======================================================================

	// Handle Data Chain (IND$FILE) operations
	private void handleDataChain(byte[] data, int offset, int length) {
		if (offset + 3 >= data.length)
			return;

		byte operation = data[offset + 3];
		// System.out.println("Data Chain operation: 0x" + String.format("%02X",
		// operation));
		System.out.println("Data Chain operation: 0x" + String.format("%02X", operation) + " at offset " + offset
				+ ", length " + length);

		// Debug: print the structured field
		System.out.print("SF data: ");
		for (int i = offset; i < Math.min(offset + length, data.length) && i < offset + 30; i++) {
			System.out.print(String.format("%02X ", data[i]));
		}
		System.out.println();

		switch (operation) {
		case DC_OPEN:
			handleDCOpen(data, offset, length);
			break;

		case DC_CLOSE:
			handleDCClose(data, offset, length);
			break;

		case DC_SET_CURSOR:
			handleDCSetCursor(data, offset, length);
			break;

		case DC_GET:
			handleDCGet(data, offset, length);
			break;

		case DC_INSERT:
			handleDCInsert(data, offset, length);
			break;

		default:
			System.out.println("Unknown Data Chain operation: 0x" + String.format("%02X", operation));
		}
	}

	public void initiateFileTransfer(String localFilePath, String command, boolean isDownload) {
		try {
			currentFile = new File(localFilePath);
			ftDirection = isDownload ? FileTransferDirection.DOWNLOAD : FileTransferDirection.UPLOAD;

			// Determine if text or binary based on command
			ftIsText = command.toUpperCase().contains("ASCII") || command.toUpperCase().contains("CRLF");

			// Reset message flag at start of transfer
			ftIsMessage = false;
			ftHadSuccessfulTransfer = false;

			System.out.println("Initiating file transfer:");
			System.out.println("  Local file: " + localFilePath);
			System.out.println("  Direction: " + (isDownload ? "Download (Host->PC)" : "Upload (PC->Host)"));
			System.out.println("  Mode: " + (ftIsText ? "TEXT" : "BINARY"));
			System.out.println("  Command: " + command);

			// Show progress dialog
			showProgressDialog(isDownload ? "Downloading from Host" : "Uploading to Host");
			updateProgressDialog("Sending command to host...", currentFile.getName());

			// --- FIX: Position Cursor at Command Line ---
			// 1. Move to "Home" (First Unprotected Field)
			// Start searching from 0 to find the first writable spot
			int homePos = -1;
			for (int i = 0; i < rows * cols; i++) {
				// If this is a Start Field attribute...
				if (isFieldStart(i)) {
					byte attr = attributes[i];
					// And it is NOT protected (Bit 2 is 0)
					if ((attr & 0x20) == 0) {
						homePos = i + 1; // Cursor goes to first char of field
						break;
					}
				}
			}

			// If we found a writable field, move cursor there
			if (homePos != -1) {
				cursorPos = homePos % (rows * cols);
			} else {
				// Fallback: Just try to tab from current position
				tabToNextField();
			}

			// 2. Clear any existing text in this field (Erase EOF logic)
			// We do this manually here to avoid triggering a repaint yet
			int fieldStart = findFieldStart(cursorPos);
			int fieldEnd = findNextField(fieldStart);
			for (int i = cursorPos; i < fieldEnd && !isFieldStart(i); i++) {
				buffer[i] = '\0'; // Clear char
				setModified(i); // Mark MDT so host sees the clearance
			}

			// 3. Type the command
			for (char c : command.toCharArray()) {
				if (!isProtected(cursorPos)) {
					buffer[cursorPos] = c;
					setModified(cursorPos);
					cursorPos = (cursorPos + 1) % (rows * cols);
				}
			}

			canvas.repaint();

			// Send the command with ENTER
			sendAID(AID_ENTER);

		} catch (Exception e) {
			e.printStackTrace();
			statusBar.setStatus("File transfer error: " + e.getMessage());
			closeProgressDialog(); // Ensure dialog closes on init error
		}
	}
/*
	// Build IND$FILE command with proper syntax for TSO or CMS
	public String buildIndFileCommand(boolean isDownload, boolean isTSO, String hostDataset, boolean isAscii,
			boolean useCrlf, boolean append, String recfm, String lrecl, String blksize, String space) {
		StringBuilder cmd = new StringBuilder();
		cmd.append("IND$FILE ");

		// Command verb
		if (isDownload) {
			cmd.append("GET ");
		} else {
			cmd.append("PUT ");
		}

		// Dataset/filename
		cmd.append(hostDataset);

		if (!isTSO) { // CMS
			// CMS format - parameters in parentheses
			StringBuilder params = new StringBuilder();

			if (isAscii) {
				params.append(" ASCII");
			}
			if (useCrlf && isAscii) {
				params.append(" CRLF");
			}
			if (append) {
				params.append(" APPEND");
			}

			// For PUT (upload), add RECFM and LRECL
			if (!isDownload && !recfm.isEmpty()) {
				params.append(" RECFM ").append(recfm);
				if (!lrecl.isEmpty()) {
					params.append(" LRECL ").append(lrecl);
				}
			}

			if (params.length() > 0) {
				cmd.append(" (").append(params.toString().trim()).append(")");
			}

		} else {
			// TSO format - parameters with parentheses around values
			if (isAscii) {
				cmd.append(" ASCII");
			}
			if (useCrlf && isAscii) {
				cmd.append(" CRLF");
			}
			if (append) {
				cmd.append(" APPEND");
			}

			// For PUT (upload), add RECFM, LRECL, BLKSIZE, SPACE
			if (!isDownload) {
				if (!recfm.isEmpty()) {
					cmd.append(" RECFM(").append(recfm).append(")");
				}
				if (!lrecl.isEmpty()) {
					cmd.append(" LRECL(").append(lrecl).append(")");
				}
				if (!blksize.isEmpty()) {
					cmd.append(" BLKSIZE(").append(blksize).append(")");
				}
				if (!space.isEmpty()) {
					cmd.append(" SPACE(").append(space).append(")");
				}
			} else {
				// For GET (download), only add format parameters if specified
				if (isAscii && !recfm.isEmpty()) {
					cmd.append(" RECFM(").append(recfm).append(")");
				}
				if (isAscii && !lrecl.isEmpty()) {
					cmd.append(" LRECL(").append(lrecl).append(")");
				}
				if (!blksize.isEmpty()) {
					cmd.append(" BLKSIZE(").append(blksize).append(")");
				}
			}
		}

		return cmd.toString();
	}
*/
	// Handle DC_OPEN
	private void handleDCOpen(byte[] data, int offset, int length) {
		System.out.println("=== DC_OPEN received ===");
		System.out.println("Offset: " + offset + ", Length: " + length);

		// Debug: dump the entire Open command
		System.out.print("Open data: ");
		for (int i = offset; i < offset + length && i < data.length; i++) {
			System.out.print(String.format("%02X ", data[i]));
		}
		System.out.println();

		// Parse filename from the Open command
		String filename = null;

		for (int i = offset; i < offset + length - 3; i++) {
			if (data[i] == 0x46 && data[i + 1] == 0x54 && data[i + 2] == 0x3A) {
				StringBuilder sb = new StringBuilder();
				for (int j = i; j < offset + length; j++) {
					byte b = data[j];
					if (b == 0x00 || b == (byte) 0xFF)
						break;
					char c = (char) (b & 0xFF);
					sb.append(c);
				}
				filename = sb.toString().trim();
				break;
			}
		}

		System.out.println("Open filename: " + filename);
		currentFilename = filename;

		// Check if this is data transfer or message
		boolean isData = filename != null && filename.contains("FT:DATA");
		boolean isMsg = filename != null && filename.contains("FT:MSG");

		System.out.println("isData: " + isData + ", isMsg: " + isMsg);

		if (isMsg) {
			// FT:MSG - reset state for message processing
			System.out.println("FT:MSG detected - preparing for completion message");

			ftState = FileTransferState.IDLE;
			ftIsMessage = true;
			blockSequence = 0;
			sendDCOpenResponse(true, 0);
			return;
		}

		if (!isData) {
			System.out.println("Unknown file type in Open");
			closeProgressDialog();
			showMessageDialog("Unknown file transfer type", "Transfer Error", true);
			sendDCOpenResponse(false, 0x5D00);
			return;
		}

		// *** Reset message flag when opening FT:DATA ***
		ftIsMessage = false;
		System.out.println("FT:DATA detected - reset ftIsMessage to false");

		// Determine direction from the Open header
		boolean hostWillGet = false;
		int directionByteOffset = offset + 14;

		if (directionByteOffset < data.length) {
			hostWillGet = (data[directionByteOffset] == 0x01);
			System.out.println("Direction byte at offset " + directionByteOffset + ": 0x"
					+ String.format("%02X", data[directionByteOffset]) + " -> hostWillGet=" + hostWillGet);
		}

		// Open the actual file for data transfer
		try {
			if (currentFile == null) {
				closeProgressDialog();
				showMessageDialog("No file specified", "Transfer Error", true);
				sendDCOpenResponse(false, 0x1B00);
				return;
			}

			if (hostWillGet) {
				// Host will GET data = Upload from PC to Host
				if (!currentFile.exists()) {
					closeProgressDialog();
					showMessageDialog("File not found: " + currentFile.getName(), "Transfer Error", true);
					sendDCOpenResponse(false, 0x1B00);
					return;
				}
				// uploadStream = new FileInputStream(currentFile);
				// Wrap in BufferedInputStream to support mark/reset for smart chunking
				uploadStream = new BufferedInputStream(new FileInputStream(currentFile));

				pendingCR = false; // Reset state

				long fileSize = currentFile.length();
				System.out.println("Opened file for READING (upload to host): " + currentFile.getAbsolutePath());
				updateProgressDialog("Sending data to host...", fileSize + " bytes total");
			} else {
				// Host will INSERT data = Download from Host to PC
				downloadStream = new FileOutputStream(currentFile);
				System.out.println("Opened file for WRITING (download from host): " + currentFile.getAbsolutePath());
				updateProgressDialog("Receiving data from host...", "Block 0");
			}

			ftState = FileTransferState.TRANSFER_IN_PROGRESS;
			blockSequence = 0;
			sendDCOpenResponse(true, 0);
			System.out.println("Sent positive DC_OPEN response");

		} catch (IOException e) {
			e.printStackTrace();
			closeProgressDialog();

			if (e instanceof FileNotFoundException) {
				showMessageDialog("File not found: " + currentFile.getName(), "Transfer Error", true);
				sendDCOpenResponse(false, 0x1B00);
			} else {
				showMessageDialog("File open error: " + e.getMessage(), "Transfer Error", true);
				sendDCOpenResponse(false, 0x2000);
			}
		}
	}

	// Handle DC_CLOSE
	private void handleDCClose(byte[] data, int offset, int length) {
		System.out.println("=== DC_CLOSE received ===");

		try {
			if (downloadStream != null) {
				downloadStream.flush();
				downloadStream.close();
				downloadStream = null;

				if (currentFile != null) {
					System.out.println("Download stream closed. File: " + currentFile.getAbsolutePath());
					System.out.println("File size: " + currentFile.length() + " bytes");

					// --- FIX: REMOVED POPUP DIALOG HERE ---
					// We do NOT show a dialog here anymore. We wait for the FT:MSG
					// which invariably follows DC_CLOSE to show the final status.
					// This prevents the "Double Dialog" issue.

					if (ftHadSuccessfulTransfer && currentFile.length() > 0) {
						statusBar.setStatus("Data received. Waiting for host confirmation...");
					}
				}
			}

			// Upload streams are usually closed in handleDCGet upon EOF,
			// but we ensure they are closed here just in case.
			if (uploadStream != null) {
				uploadStream.close();
				uploadStream = null;
			}

		} catch (IOException e) {
			e.printStackTrace();
			closeProgressDialog();
			// We DO keep the error dialog, as this is a stream crash, not a protocol
			// completion.
			showMessageDialog("File close error: " + e.getMessage(), "Transfer Error", true);
			sendDCCloseResponse(false, 0x7100);
			statusBar.setStatus("File close error");
			return;
		}

		// Do NOT reset ftState to IDLE yet if we are expecting an FT:MSG.
		// However, standard IND$FILE usually treats DC_CLOSE as the end of the Data
		// Chain.
		// We reset variables, but we leave the UI alone until FT:MSG cleans it up.

		// ftState = FileTransferState.IDLE; // Optional: Keep state active until MSG
		ftIsMessage = false;
		ftHadSuccessfulTransfer = false;
		// currentFile = null; // Keep this alive so FT:MSG can reference the filename
		// currentFilename = null;
		blockSequence = 0;

		sendDCCloseResponse(true, 0);
	}

	// Handle DC_SET_CURSOR (0x45)
	// Host sends this to position the cursor before a Read/Write operation.
	private void handleDCSetCursor(byte[] data, int offset, int length) {
		// Standard Format: [Length(2)] [D0] [45] [11 (SBA)] [Addr1] [Addr2] ...
		// Payload starts at offset + 4
		int payloadOffset = offset + 4;

		if (payloadOffset < data.length && data[payloadOffset] == ORDER_SBA) {
			if (payloadOffset + 2 < data.length) {
				int newPos = decode3270Address(data[payloadOffset + 1], data[payloadOffset + 2]);

				// Sanity check bounds
				if (newPos >= 0 && newPos < (rows * cols)) {
					cursorPos = newPos;
					System.out.println("DC_SET_CURSOR: Moved to " + cursorPos);
					canvas.repaint();
					statusBar.update();
				}
			}
		}
	}

	// Handle DC_GET (for upload from PC to Host)
	// Handle DC_GET (Upload PC -> Host)
	private void handleDCGet(byte[] data, int offset, int length) {
		// System.out.println("=== DC_GET received ===");

		if (uploadStream == null) {
			sendDCGetResponse(false, 0x2200, null, 0); // EOF
			return;
		}

		try {
			// Buffer to hold multiple lines (up to ~2KB to match PCOMM/MTU)
			ByteArrayOutputStream blockBuffer = new ByteArrayOutputStream(2048);

			// Temporary buffer for the current line being read
			ByteArrayOutputStream lineBuffer = new ByteArrayOutputStream();

			int ch;
			boolean eof = false;
			boolean addedAtLeastOneLine = false;

			// Loop until we fill the block or hit EOF
			while (blockBuffer.size() < 1900) {

				// Read one line
				lineBuffer.reset();
				boolean foundNewline = false;

				// Mark position in case we need to "unread" if the line is too long for
				// remaining space
				if (uploadStream.markSupported()) {
					uploadStream.mark(4096);
				}

				while ((ch = uploadStream.read()) != -1) {
					if (ch == '\n') {
						foundNewline = true;
						break;
					} else if (ch == '\r') {
						// Handle CRLF or bare CR
						int next = -1;
						// Peek next if possible
						if (uploadStream.markSupported()) {
							uploadStream.mark(1);
							next = uploadStream.read();
							if (next != '\n')
								uploadStream.reset(); // Not LF, unread
						}
						foundNewline = true;
						break;
					} else {
						lineBuffer.write(ch);
					}
				}

				if (ch == -1 && lineBuffer.size() == 0) {
					eof = true;
					break;
				}

				// Prepare the line (Add ASCII CRLF)
				if (ftIsText) {
					lineBuffer.write(0x0D); // CR
					lineBuffer.write(0x0A); // LF
				}

				// Check if this line fits in the remaining space of the block
				if (blockBuffer.size() + lineBuffer.size() > 2000) {
					// Line is too big to fit in this block!
					// If we support mark/reset, rewind so we pick this line up next time
					if (uploadStream.markSupported()) {
						try {
							uploadStream.reset();
						} catch (IOException e) {
							// If we can't reset, we must send what we have as a partial block?
							// Or just force this line into the current block (slightly oversize)
							// Ideally, BufferedInputStream supports mark.
							blockBuffer.write(lineBuffer.toByteArray());
						}
					} else {
						// Fallback: Just write it, hopefully it doesn't exceed 3270 limit (~4k) too
						// badly
						blockBuffer.write(lineBuffer.toByteArray());
					}
					addedAtLeastOneLine = true;
					break; // Block full
				} else {
					// It fits, append it
					blockBuffer.write(lineBuffer.toByteArray());
					addedAtLeastOneLine = true;
				}

				// If we hit EOF while reading this line, stop loop after adding it
				if (ch == -1) {
					eof = true;
					break;
				}
			}

			byte[] dataToSend = blockBuffer.toByteArray();

			if (dataToSend.length > 0) {
				blockSequence++;
				sendDCGetResponse(true, 0, dataToSend, dataToSend.length);

				// Update UI less frequently (every 10 blocks) to save CPU
				if (blockSequence % 10 == 0 || eof) {
					updateProgressDialog("Sending block " + blockSequence + "...", (blockSequence * 2) + " KB sent");
				}
			} else if (eof) {
				// True EOF
				System.out.println("Upload EOF reached.");
				uploadStream.close();
				uploadStream = null;
				sendDCGetResponse(false, 0x2200, null, 0); // 0x2200 = EOF Error Code
			}

		} catch (IOException e) {
			e.printStackTrace();
			sendDCGetResponse(false, 0x2000, null, 0);
			closeProgressDialog();
			showMessageDialog("Upload error: " + e.getMessage(), "Error", true);
		}
	}

	// Handle DC_INSERT (for download from Host to PC)
	private void handleDCInsert(byte[] data, int offset, int length) {
		System.out.println("=== DC_INSERT received ===");
		System.out.println("Offset: " + offset + ", Length: " + length);

		// Debug: dump the start of the packet to see headers
		System.out.print("DC_INSERT bytes: ");
		for (int i = offset; i < Math.min(offset + 20, data.length); i++) {
			System.out.print(String.format("%02X ", data[i]));
		}
		System.out.println();

		// ---------------------------------------------------------
		// 1. Handle FT:MSG (Transfer Completion Message)
		// ---------------------------------------------------------
		if (ftIsMessage) {
			System.out.println("Processing FT:MSG completion message");

			// Only process the first FT:MSG block containing the text
			if (blockSequence > 0) {
				System.out.println("Ignoring subsequent FT:MSG block " + (blockSequence + 1));
				blockSequence++;
				sendDCInsertResponse(true, 0);
				return;
			}

			// The 0x61 marker should be at offset + 7
			int markerOffset = offset + 7;

			if (markerOffset + 2 >= data.length) {
				System.out.println("FT:MSG: Packet too short for data marker");
				sendDCInsertResponse(true, 0);
				return;
			}

			// If we don't see the marker in a Message SF, it might be a header. Skip it.
			if (data[markerOffset] != 0x61) {
				System.out.println("FT:MSG: No 0x61 marker. Skipping header.");
				return;
			}

			// Calculate data length
			int dataLen = ((data[markerOffset + 1] & 0xFF) << 8) | (data[markerOffset + 2] & 0xFF);
			dataLen -= 5; // Subtract overhead

			if (dataLen > 0 && markerOffset + 3 + dataLen <= data.length) {
				// FT:MSG is already in ASCII - extract directly
				StringBuilder msgText = new StringBuilder();
				for (int j = 0; j < dataLen; j++) {
					char c = (char) (data[markerOffset + 3 + j] & 0xFF);
					if (c >= 32 && c < 127) {
						msgText.append(c);
					}
				}

				String message = msgText.toString().trim();
				System.out.println("Transfer completion message: " + message);

				// Acknowledge the message
				blockSequence++;
				sendDCInsertResponse(true, 0);

				// Close file streams
				try {
					if (downloadStream != null) {
						downloadStream.flush();
						downloadStream.close();
						downloadStream = null;
					}
					if (uploadStream != null) {
						uploadStream.close();
						uploadStream = null;
					}
				} catch (IOException e) {
					e.printStackTrace();
				}

				closeProgressDialog();

				// Analyze message for Success vs Failure
				boolean isSuccess = message.contains("complete") || message.contains("TRANS03");
				boolean isError = message.contains("Error") || message.contains("TRANS13")
						|| message.contains("TRANS14");

				if (isSuccess && !isError) {
					String successMsg = "Transfer complete!\n\nFile: "
							+ (currentFile != null ? currentFile.getName() : "Unknown") + "\n\nHost: " + message;
					showMessageDialog(successMsg, "Transfer Complete");
					statusBar.setStatus("Download complete");
				} else {
					showMessageDialog("Transfer status:\n\n" + message, isError ? "Transfer Error" : "Transfer Status");
					statusBar.setStatus("Transfer finished: " + message);
				}

				// Reset Transfer State
				ftState = FileTransferState.IDLE;
				ftIsMessage = false;
				ftHadSuccessfulTransfer = false;
				currentFile = null;
				currentFilename = null;
			}
			return;
		}

		// ---------------------------------------------------------
		// 2. Handle FT:DATA (File Content Download)
		// ---------------------------------------------------------
		if (downloadStream == null) {
			System.out.println("ERROR: DC_INSERT received but no download stream open.");
			sendDCInsertResponse(false, 0x4700); // Record not added
			return;
		}

		// Check for the Data Marker (0x61) at offset + 7
		// If it is missing, this is a Header SF (setup packet). We must skip it.
		int markerOffset = offset + 7;

		if (markerOffset >= offset + length) {
			System.out.println("DC_INSERT: Packet too short to contain valid data.");
			return; // Skip
		}

		if (data[markerOffset] != 0x61) {
			System.out.println("DC_INSERT: No 0x61 marker found at offset+7. Assuming Header SF. Skipping.");
			return; // Skip header, wait for data SF
		}

		// Process Actual Data
		try {
			int dataLen = ((data[markerOffset + 1] & 0xFF) << 8) | (data[markerOffset + 2] & 0xFF);
			dataLen -= 5; // Subtract overhead (C0 80 61 dd dd)

			System.out.println("DC_INSERT: Data payload length: " + dataLen);

			if (dataLen > 0 && markerOffset + 3 + dataLen <= data.length) {
				byte[] fileData = new byte[dataLen];
				System.arraycopy(data, markerOffset + 3, fileData, 0, dataLen);

				if (ftIsText) {
					// Text Mode: Handle CRLF and EOF conversion
					ByteArrayOutputStream cleanData = new ByteArrayOutputStream();

					for (int i = 0; i < dataLen; i++) {
						byte b = fileData[i];

						// 1. Handle "Split CRLF" from previous block
						if (pendingCR) {
							pendingCR = false;
							if (b == 0x0A) {
								// This is the LF partner to the previous block's CR.
								// We already wrote the newline for the CR, so SKIP this LF.
								continue;
							}
							// If it wasn't LF, the previous CR was a bare CR (mac style?),
							// which we already wrote as \n. Process this byte normally.
						}

						// 2. Standard Processing
						if (b == 0x0D) {
							// CR found.
							// Is it at the very end of this block?
							if (i == dataLen - 1) {
								pendingCR = true; // Mark for next block
								cleanData.write('\n'); // Write the line ending now
							}
							// Is the next char LF?
							else if (fileData[i + 1] == 0x0A) {
								cleanData.write('\n'); // Write normalized newline
								i++; // Skip the LF
							}
							// Bare CR?
							else {
								cleanData.write('\n');
							}
						} else if (b == 0x0A) {
							// Bare LF
							cleanData.write('\n');
						} else if (b == 0x1A) {
							// EOF Marker (Ctrl-Z) - Ind$File often sends this at the end
							// Do not write it to the file.
							continue;
						} else {
							cleanData.write(b);
						}
					}
					downloadStream.write(cleanData.toByteArray());
				} else {
					// Binary Mode
					downloadStream.write(fileData);
				}

				ftHadSuccessfulTransfer = true;
				blockSequence++;

				// Send Acknowledgement
				sendDCInsertResponse(true, 0);

				updateProgressDialog("Receiving block " + blockSequence + "...", dataLen + " bytes");
			} else {
				// Empty block? Just Ack it.
				System.out.println("DC_INSERT: Empty or malformed data length.");
				sendDCInsertResponse(true, 0);
			}

		} catch (IOException e) {
			e.printStackTrace();
			closeProgressDialog();
			showMessageDialog("Write error: " + e.getMessage(), "Transfer Error", true);
			sendDCInsertResponse(false, 0x4700);
		}
	}

	// Send DC_OPEN response
	private void sendDCOpenResponse(boolean success, int errorCode) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			if (success) {
				// Positive response
				baos.write(0x00); // Length MSB
				baos.write(0x05); // Length LSB
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_OPEN);
				baos.write(RESP_POSITIVE);
			} else {
				// Negative response
				baos.write(0x00); // Length MSB
				baos.write(0x09); // Length LSB
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_OPEN);
				baos.write(RESP_NEGATIVE);
				baos.write(0x69);
				baos.write(0x04);
				baos.write((byte) ((errorCode >> 8) & 0xFF));
				baos.write((byte) (errorCode & 0xFF));
			}

			byte[] response = baos.toByteArray();
			sendStructuredFieldResponse(response);

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// Send DC_CLOSE response
	private void sendDCCloseResponse(boolean success, int errorCode) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			if (success) {
				baos.write(0x00);
				baos.write(0x05);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_CLOSE);
				baos.write(RESP_POSITIVE);
			} else {
				baos.write(0x00);
				baos.write(0x09);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_CLOSE);
				baos.write(RESP_NEGATIVE);
				baos.write(0x69);
				baos.write(0x04);
				baos.write((byte) ((errorCode >> 8) & 0xFF));
				baos.write((byte) (errorCode & 0xFF));
			}

			sendStructuredFieldResponse(baos.toByteArray());

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// Send DC_GET response
	private void sendDCGetResponse(boolean success, int errorCode, byte[] data, int dataLen) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			if (success && data != null && dataLen > 0) {
				// Calculate lengths
				int dataLenField = dataLen + 5; // Data + overhead (C0 80 61 dd dd)
				int responseLen = 2 + 1 + 1 + 1 + 1 + 1 + 4 + 1 + 1 + 1 + 2 + dataLen;
				// That's: length(2) + SFID(1) + op(1) + header(3) + seq(4) + flags(3) +
				// datalen(2) + data

				baos.write((byte) ((responseLen >> 8) & 0xFF));
				baos.write((byte) (responseLen & 0xFF));
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_GET);
				baos.write(0x05);
				baos.write(0x63);
				baos.write(0x06);
				baos.write((byte) ((blockSequence >> 24) & 0xFF));
				baos.write((byte) ((blockSequence >> 16) & 0xFF));
				baos.write((byte) ((blockSequence >> 8) & 0xFF));
				baos.write((byte) (blockSequence & 0xFF));
				baos.write((byte) 0xC0);
				baos.write((byte) 0x80);
				baos.write((byte) 0x61);
				baos.write((byte) ((dataLenField >> 8) & 0xFF));
				baos.write((byte) (dataLenField & 0xFF));
				baos.write(data, 0, dataLen);
			} else {
				baos.write(0x00);
				baos.write(0x09);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_GET);
				baos.write(RESP_NEGATIVE);
				baos.write(0x69);
				baos.write(0x04);
				baos.write((byte) ((errorCode >> 8) & 0xFF));
				baos.write((byte) (errorCode & 0xFF));
			}

			sendStructuredFieldResponse(baos.toByteArray());

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// Send DC_INSERT response
	private void sendDCInsertResponse(boolean success, int errorCode) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			if (success) {
				baos.write(0x00);
				baos.write(0x0B);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_INSERT);
				baos.write(0x05);
				baos.write(0x63);
				baos.write(0x06);
				// Block sequence number (4 bytes)
				baos.write((byte) ((blockSequence >> 24) & 0xFF));
				baos.write((byte) ((blockSequence >> 16) & 0xFF));
				baos.write((byte) ((blockSequence >> 8) & 0xFF));
				baos.write((byte) (blockSequence & 0xFF));
			} else {
				baos.write(0x00);
				baos.write(0x09);
				baos.write(SFID_DATA_CHAIN);
				baos.write(DC_INSERT);
				baos.write(RESP_NEGATIVE);
				baos.write(0x69);
				baos.write(0x04);
				baos.write((byte) ((errorCode >> 8) & 0xFF));
				baos.write((byte) (errorCode & 0xFF));
			}

			sendStructuredFieldResponse(baos.toByteArray());

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// Send structured field response with AID 0x88
	private void sendStructuredFieldResponse(byte[] sfData) throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		baos.write(AID_STRUCTURED_FIELD);
		baos.write(sfData);

		byte[] response = baos.toByteArray();

		System.out.println("=== SENDING STRUCTURED FIELD RESPONSE ===");
		for (int j = 0; j < response.length && j < 100; j++) {
			System.out.print(String.format("%02X ", response[j]));
			if ((j + 1) % 16 == 0)
				System.out.println();
		}
		System.out.println();

		sendData(response);

		// CRITICAL: Ensure the response is actually sent
		output.flush(); // Add this if not already in sendData
	}

	private void sendQueryResponse() {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();

			// AID and cursor address
			// baos.write(AID_ENTER);
			// byte[] cursorAddr = encode3270Address(cursorPos);
			// baos.write(cursorAddr[0]);
			// baos.write(cursorAddr[1]);

			int reportRows = alternateRows; // 32 for 3279-3
			int reportCols = alternateCols; // 80
			int reportBufsize = reportRows * reportCols; // 2560

			System.out.println("Query Reply: reporting " + reportCols + "x" + reportRows + " (model: " + model + ")");

			if (tn3270eMode) {
				// TN3270E Header: [DataType] [Request] [Response] [Seq] [Seq]
				// DataType 0x00 = 3270 Data
				baos.write(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00 });
			}

			baos.write(0x88); // WSF Structured Field Response AID

			// ===== QUERY REPLY (SUMMARY) =====
			baos.write(0x00); // Length MSB
			baos.write(0x18); // Length LSB (24 bytes)
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x80); // Summary
			baos.write((byte) 0x81); // Usable Area
			baos.write((byte) 0x84); // Device Characteristics (Alphanumeric Partitions)
			baos.write((byte) 0x85); // Character Sets
			baos.write((byte) 0x86); // Color
			baos.write((byte) 0x87); // Highlight
			baos.write((byte) 0x88); // Reply Modes
			baos.write((byte) 0x8C); // Format Presentation (Field Outlining)
			baos.write((byte) 0x8F); // OEM Auxiliary Device (optional)
			baos.write((byte) 0x95); // Distributed Data Management (DDM)
			baos.write((byte) 0x99); // Storage Pools (Auxiliary device (AUXDA))
			baos.write((byte) 0x9D); // Segment (optional) (Anomally Implementation)
			baos.write((byte) 0xA6); // Implicit Partition
			baos.write((byte) 0xA8); // Distributed Data Management (Transparency)
			baos.write((byte) 0xAB); // Product Defined (optional) (Cooperative Processing Requestor (CPR))
			baos.write((byte) 0xB0); // Begin/End of File (Segment)
			baos.write((byte) 0xB1); // Data Chaining (Procedure)
			baos.write((byte) 0xB2); // Destination/Origin (Line Type)
			baos.write((byte) 0xB3); // Object Control (Port)
			baos.write((byte) 0xB4); // Object Picture (Graphic Color)
			baos.write((byte) 0xB6); // Save/Restore Format (Graphic Symbol Sets)

			// ===== QUERY REPLY (USABLE AREA) =====
			// PCOMM: Data='0017 8181 01000050002000000100600001006016220A00'x
			// 0017 8181 01 0000 5000 2000 00 0A 02 E5 00 02 00 6F 09 0C 0A 00
			// 88 00 0e 81 80 80 81 84 85 86 87 88 95 a1 a6
			// 00 17 81 81 01 00 00 50 00 2b 01 00 0a 02 e5 00 02 00 6f 09 0c 0d 70
			// 00 08 81 84 00 0d 70 00
			// 00 1b 81 85 82 00 09 0c 00 00 00 00 07 00 10 00 02 b9 00 25 01 00 f1 03 c3 01
			// 36
			// 00 26 81 86 00 10 00 f4 f1 f1 f2 f2 f3 f3 f4 f4 f5 f5 f6 f6 f7
			// f7 f8 f8 f9 f9 fa fa fb fb fc fc fd fd fe fe ff ff ff ff
			// 00 0f 81 87 05 00 f0 f1 f1 f2 f2 f4 f4 f8 f8
			// 00 07 81 88 00 01 02
			// 00 0c 81 95 00 00 40 00 40 00 01 01
			// 00 12 81 a1 00 00 00 00 00 00 00 00 06 a7 f3 f2 f7 f0
			// 00 11 81 a6 00 00 0b 01 00 00 50 00 18 00 50 00 2b
			//
			// For 3279-3: 80x32
			// ll ll 81 81 01 00 00 00 00 00 01 00 D3 03 20 00 9E 02 58 07 0C 0780
			// 00 17 81 81 01 00 0050 0020 00 00 02 00 89 00 02 00 85 09 10 0A00
			// ===== QUERY REPLY (USABLE AREA) =====
			// 00 17 81 81 01 00 0050 002b 00 00 02 00 89 00 02 00 85 09 10 0a00
			baos.write(0x00); // Length MSB
			baos.write(0x17); // Length LSB (23 bytes)
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x81); // Usable Area QRID
			baos.write(0x01); // 12/14-bit addressing
			// baos.write(0x00); // Flags1
			baos.write(0x00); // Flags2
			baos.write((byte) ((reportCols >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportCols & 0xFF)); // 0x50 (80)
			baos.write((byte) ((reportRows >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportRows & 0xFF)); // 0x20 (32)
			baos.write(0x00); // Units
			baos.write(0x00); // Xr MSB
			baos.write(0x02); // Xr LSB
			baos.write(0x00); // Yr MSB
			baos.write((byte) 0x89); // Yr LSB
			baos.write(0x00); // AW MSB
			baos.write(0x02); // AW LSB
			baos.write(0x00); // AH MSB
			baos.write(0x85); // AH LSB
			// baos.write((byte)((reportBufsize >> 8) & 0xFF)); // 0x0A (2560>>8=10)
			// baos.write((byte)(reportBufsize & 0xFF)); // 0x00 (2560&0xFF=0)
			baos.write(0x09); // Xm MSB
			baos.write(0x10); // Xm LSB
			baos.write(0x0A); // Ym MSB (CHANGED from 0x0D)
			baos.write(0x00); // Ym LSB (CHANGED from 0x70)

			/*
			 * // Device characteristics baos.write((byte) 0x00); baos.write((byte) 0x1B);
			 * baos.write((byte) 0x81); baos.write((byte) 0x40); baos.write((byte) 0x00);
			 * baos.write((byte) 0x00); baos.write((byte) 0x00); baos.write((byte) 0x00);
			 * baos.write((byte) 0x00); baos.write((byte) 0x00); baos.write((byte) 0x00);
			 * baos.write((byte) 0x00); baos.write((byte) 0x00); baos.write((byte) 0x18);
			 * baos.write((byte) 0x00); baos.write((byte)(reportCols & 0xFF)); // Width MSB
			 * (0x50 = 80) baos.write((byte)((reportCols >> 8) & 0xFF)); // Width LSB (0x00)
			 * baos.write((byte) 0x2B); baos.write((byte) 0x00); baos.write((byte) 0x84);
			 * baos.write((byte) 0x07); baos.write((byte) 0x80); baos.write((byte) 0x81);
			 * baos.write((byte) 0x00); baos.write((byte) 0x02); baos.write((byte) 0x00);
			 * baos.write((byte) 0x00);
			 */
			// Alphanumeric partitions
			// Data='0008 8184 001E0004'x
			// ===== QUERY REPLY (DEVICE CHARACTERISTICS 0x84) =====
			// PCOMM: Data='0008 8184 001E0004'x
			baos.write(0x00);
			baos.write(0x08); // Length = 8 bytes
			baos.write(0x81); // Query Reply
			baos.write(0x84); // Device Characteristics QRID

			// baos.write(0x00); // Byte 4: Device type/features
			// baos.write(0x0D); // Byte 5: Model (0x0D = Model 4, 0x70 for others)
			// baos.write(0x70); // Byte 6: Extended features
			// baos.write(0x00); // Byte 7: Reserved
			baos.write(0x01);
			baos.write(0xE0); // 2=0x02, 3=0x03, 4=0x0D, 5=0x05
			baos.write(0x00);
			baos.write(0x04);

			// Data='001B 8185 82001622000000000700000002B900250100F103C30136'x
			// 00 1b 81 85 82 00 09 0c 00 00 00 00 07 00 10 00 02 b9 00 25 01 00 f1 03 c3 01
			// 36
			// 00 13 81 85 B0 00 09 10 40 00 00 00 03 00 00 00 01 00 F1
			// ===== QUERY REPLY (CHARACTER SET) =====
			// PCOMM: Data='001B 8185 82 00 16 22 00 00 00 00 07 00 00 00 02 B9 00 25 01 00
			// F1 03 C3 01 36'x
			/*
			 * baos.write(0x00); baos.write(0x13); baos.write((byte) 0x81); // Query Reply
			 * baos.write((byte) 0x85); // Character Sets baos.write((byte) 0xB0); // Flags:
			 * CGCSGID, Multiple LCIDs baos.write(0x00); // SDW baos.write(0x09); // SDH
			 * baos.write(0x10); // Form: 0x10 = 40 characters baos.write(0x40); // DL
			 * baos.write(0x00); // DL MSB baos.write(0x00); // DL LSB baos.write(0x00); //
			 * Descriptor length baos.write(0x03); // Number of char sets baos.write(0x00);
			 * // Reserved baos.write(0x00); // Reserved baos.write(0x00); // Reserved
			 * baos.write(0x01); // Reserved baos.write(0x00); // Reserved baos.write((byte)
			 * 0xF1); // APL character set
			 */
			/*
			 * baos.write(0x00); baos.write(0x1B); baos.write((byte) 0x81); // Query Reply
			 * baos.write((byte) 0x85); // Character Sets baos.write((byte) 0x82); // Flags:
			 * CGCSGID, Multiple LCIDs baos.write(0x00); // SDW baos.write(0x16); // SDH
			 * baos.write(0x22); // Form: 0x10 = 40 characters baos.write(0x00); // DL
			 * baos.write(0x00); // DL MSB baos.write(0x00); // DL LSB baos.write(0x00); //
			 * Descriptor length baos.write(0x07); // Number of char sets baos.write(0x00);
			 * // Reserved baos.write(0x00); // Reserved baos.write(0x00); // Reserved
			 * baos.write(0x02); // Reserved baos.write(0xB9); // Reserved baos.write(0x00);
			 * baos.write(0x25); baos.write(0x01); baos.write(0x00); baos.write(0xF1);
			 * baos.write(0x03); baos.write(0xC3); baos.write(0x01); baos.write(0x36);
			 */

			// ===== QUERY REPLY (CHARACTER SET) =====
			// Matched to PCOMM dump: 00 1B 81 85 82 00 09 0C ... F1 ...
			/*
			 * baos.write(0x00); baos.write(0x1B); // Length 27 baos.write(0x81);
			 * baos.write(0x85); // ID baos.write(0x82); // Flags (PCOMM uses 0x82, we were
			 * using 0xB0) baos.write(0x00); // SDW baos.write(0x09); // SDH
			 * baos.write(0x0C); // Form (PCOMM uses 0x0C) baos.write(0x00); // DL MSB
			 * baos.write(0x00); // DL LSB
			 * 
			 * // Descriptor Data (Matches PCOMM exactly) baos.write(0x00);
			 * baos.write(0x00); baos.write(0x07); baos.write(0x00); baos.write(0x10);
			 * baos.write(0x00); baos.write(0x02); baos.write(0xB9); baos.write(0x00);
			 * baos.write(0x25); baos.write(0x01); baos.write(0x00); baos.write(0xF1); //
			 * APL/GE Set ID baos.write(0x03); baos.write(0xC3); baos.write(0x01);
			 * baos.write(0x36);
			 */

			// Data='0016 8186 000800F4F1F1F2F2F3F3F4F4F5F5F6F6F7F7'x
			// Data='0016 8186 001000F4F1F1F2F2F3F3F4F4F5F5F6F6F7F7'x
			// 00 26 81 86 00 10 00 f4 f1 f1 f2 f2 f3 f3 f4 f4 f5 f5 f6 f6 f7
			// f7 f8 f8 f9 f9 fa fa fb fb fc fc fd fd fe fe ff ff ff ff
			// ===== QUERY REPLY (COLOR) =====
			baos.write(0x00);
			baos.write(0x16); // 22 bytes
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x86); // Color
			baos.write(0x00); // Flags
			baos.write(0x08); // 8 colors
			baos.write(0x00); // Default color
			baos.write((byte) 0xF4); // Green
			baos.write((byte) 0xF1); // Blue
			baos.write((byte) 0xF1); // Blue
			baos.write((byte) 0xF2); // Red
			baos.write((byte) 0xF2); // Red
			baos.write((byte) 0xF3); // Pink
			baos.write((byte) 0xF3); // Pink
			baos.write((byte) 0xF4); // Green
			baos.write((byte) 0xF4); // Green
			baos.write((byte) 0xF5); // Turquoise
			baos.write((byte) 0xF5); // Turquoise
			baos.write((byte) 0xF6); // Yellow
			baos.write((byte) 0xF6); // Yellow
			baos.write((byte) 0xF7); // White
			baos.write((byte) 0xF7); // White
			/*
			 * baos.write((byte) 0xF8); // Black baos.write((byte) 0xF8); baos.write((byte)
			 * 0xF9); // Deep Blue baos.write((byte) 0xF9); baos.write((byte) 0xFA); //
			 * Orange baos.write((byte) 0xFA); baos.write((byte) 0xFB); // Purple
			 * baos.write((byte) 0xFB); baos.write((byte) 0xFC); // Pale Green
			 * baos.write((byte) 0xFC); baos.write((byte) 0xFD); // Pale Turquoise
			 * baos.write((byte) 0xFD); baos.write((byte) 0xFE); // Grey baos.write((byte)
			 * 0xFE); baos.write((byte) 0xFF); // White baos.write((byte) 0xFF);
			 * baos.write((byte) 0xFF); baos.write((byte) 0xFF);
			 */
			// Data='000D 8187 0400F0F1F1F2F2F4F4'x
			// 00 0f 81 87 05 00 f0 f1 f1 f2 f2 f4 f4 f8 f8
			// ===== QUERY REPLY (HIGHLIGHTING) =====
			baos.write(0x00);
			baos.write(0x0D); // 13 bytes
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x87); // Highlighting
			baos.write(0x04); // 4 pairs
			baos.write(0x00); // Default
			baos.write((byte) 0xF0); // Normal
			baos.write((byte) 0xF1); // Blink
			baos.write((byte) 0xF1); // ?
			baos.write((byte) 0xF2); // Reverse
			baos.write((byte) 0xF2); // ?
			baos.write((byte) 0xF4); // Underscore
			baos.write((byte) 0xF4); // ?

			// 00 07 81 88 00 01 02
			// ===== QUERY REPLY (REPLY MODES) =====
			baos.write(0x00);
			baos.write(0x07); // 7 bytes
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x88); // Reply Modes
			baos.write(0x00); // Field mode
			baos.write(0x01); // Extended field mode
			baos.write(0x02); // ?

			// ===== QUERY REPLY (FORMAT PRESENTATION 0x8C) =====
			baos.write(0x00);
			baos.write(0x07); // Length = 7 bytes
			baos.write(0x81); // Query Reply
			baos.write(0x8C); // Format Presentation QRID
			baos.write(0x00); // Reserved
			baos.write(0x00); // Supports Format Presentation (was 0x01)
			baos.write(0x00); // Reserved

			// 00 0c 81 95 00 00 40 00 40 00 01 01
			// ===== QUERY REPLY (DDM) =====
			// PCOMM: Data='000C 8195 0000 09C4 09C4 0101'x
			baos.write(0x00);
			baos.write(0x0C); // 12 bytes (your format)
			baos.write((byte) 0x81); // Query Reply
			baos.write((byte) 0x95); // DDM
			baos.write(0x00); // Flags
			baos.write(0x00); // ?
			baos.write(0x09); // LIMIN
			baos.write(0xC4); // ?
			baos.write(0x09); // LIMOUT
			baos.write(0xC4); // ?
			baos.write(0x01); // ?
			baos.write(0x01); // ?

			// ===== QUERY REPLY (STORAGE POOLS 0x99) =====
			baos.write(0x00);
			baos.write(0x06); // Length = 6 bytes
			baos.write(0x81); // Query Reply
			baos.write(0x99); // Storage Pools QRID
			baos.write(0x00); // Reserved
			baos.write(0x00); // Reserved

			// Data='0011 81A6 00000B01000050001800500020'x
			// 00 11 81 A6 00 00 0B 01 00 0050 0018 0050 0020'
			// ===== IMPLICIT PARTITION ======
			baos.write(0x00);
			baos.write(0x11);
			baos.write((byte) 0x81);
			baos.write((byte) 0xA6);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x0B);
			baos.write(0x01);
			baos.write(0x00);
			baos.write((byte) ((reportCols >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportCols & 0xFF)); // 0x50
			baos.write(0x00);
			baos.write(0x18); // 24 rows
			baos.write((byte) ((reportCols >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportCols & 0xFF)); // 0x50
			baos.write((byte) ((reportRows >> 8) & 0xFF)); // 0x00
			baos.write((byte) (reportRows & 0xFF)); // 0x20 (32 rows alternate)

			// OEM Auxiliary Device
			// 001A 81 8F 00 00 CL8'tn3270' CL8'ClaudeAI' 04 01 00 AE
			baos.write(0x00);
			baos.write(0x1A);
			baos.write(0x81);
			baos.write(0x8F);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0xA3); // 1
			baos.write(0x95); // 2
			baos.write(0xF3); // 3
			baos.write(0xF2); // 4
			baos.write(0xF7); // 5
			baos.write(0xF0); // 6
			baos.write(0x40); // 7
			baos.write(0x40); // 8
			baos.write(0xC3); // 1
			baos.write(0x93); // 2
			baos.write(0x81); // 3
			baos.write(0xA4); // 4
			baos.write(0x84); // 5
			baos.write(0x85); // 6
			baos.write(0xC1); // 7
			baos.write(0xC9); // 8
			baos.write(0x04);
			baos.write(0x01);
			baos.write(0x00);
			baos.write(0xAE);

			// Anomally Implementation
			// 0019 81 9D 00 01 0E 00 0E 00 0F 00 00 CL12'Claude/AI'
			baos.write(0x00);
			baos.write(0x19);
			baos.write(0x81);
			baos.write(0x9D);
			baos.write(0x00); // Reserved, must be 0
			baos.write(0x01); // Anomaly reference number
			baos.write(0x0E); // Max inbound
			baos.write(0x00);
			baos.write(0x0E); // Max outbound
			baos.write(0x00);
			baos.write(0x0F); // Length of data
			baos.write(0x00);
			baos.write(0xAE);
			baos.write(0xC3); // 1
			baos.write(0x93); // 2
			baos.write(0x81); // 3
			baos.write(0xA4); // 4
			baos.write(0x84); // 5
			baos.write(0x85); // 6
			baos.write(0x61); // 7
			baos.write(0xC1); // 8
			baos.write(0xC9); // 9
			baos.write(0x40); // 10
			baos.write(0x40); // 11
			baos.write(0x40); // 12
			// baos.write(0x40); // 13
			// baos.write(0x40); // 14

			// Transparency
			// Data='0009 81A8 0200F0FFFF'x
			// ===== QUERY REPLY (DDM 0xA8) =====
			baos.write(0x00);
			baos.write(0x09); // Length = 6 bytes
			baos.write(0x81); // Query Reply
			baos.write(0xA8); // DDM QRID
			// baos.write(0x00); // Flags
			// baos.write(0x01); // DDM subset identifier
			baos.write(0x02);
			baos.write(0x00);
			baos.write(0xF0);
			baos.write(0xFF);
			baos.write(0xFF);

			// Cooperative Processing Requestor
			// 0011 81 AB 00 00 00 00 00 00 02 00 00 04 01 00 01
			baos.write(0x00);
			baos.write(0x11);
			baos.write(0x81);
			baos.write(0xAB);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x02);
			baos.write(0x00);
			baos.write(0x00);
			baos.write(0x04);
			baos.write(0x01);
			baos.write(0x00);
			baos.write(0x01);
			/*
			 * // ===== QUERY REPLY (0xB0 - Begin/End of File) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB0); // Begin/End of File QRID
			 * 
			 * // ===== QUERY REPLY (0xB1 - Data Chaining) ===== baos.write(0x00);
			 * baos.write(0x06); // Length = 6 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB1); // Data Chaining QRID baos.write(0x00); // Maximum number
			 * of requests baos.write(0x00); // Reserved
			 * 
			 * // ===== QUERY REPLY (0xB2 - Destination/Origin) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB2); // Destination/Origin QRID
			 * 
			 * // ===== QUERY REPLY (0xB3 - Object Control) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB3); // Object Control QRID
			 * 
			 * // ===== QUERY REPLY (0xB4 - Object Picture) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB4); // Object Picture QRID
			 * 
			 * // ===== QUERY REPLY (0xB6 - Save/Restore Format) ===== baos.write(0x00);
			 * baos.write(0x04); // Length = 4 bytes baos.write(0x81); // Query Reply
			 * baos.write(0xB6); // Save/Restore Format QRID
			 */
			byte[] response = baos.toByteArray();

			// DEBUG OUTPUT
			System.out.println("=== COMPLETE QUERY RESPONSE ===");
			for (int i = 0; i < response.length; i++) {
				System.out.print(String.format("%02X", response[i]));
				if ((i + 1) % 16 == 0)
					System.out.println();
			}
			System.out.println();
			System.out.println("Total: " + response.length + " bytes");

			// output.write(response);
			// output.write(IAC);
			// output.write((byte) 0xEF);
			// output.flush();

			// here
			ByteArrayOutputStream escapedStream = new ByteArrayOutputStream();

			// 1. Write Header (If TN3270E mode, header is NOT escaped,
			// but it contains 0x00s so it's safe.
			// However, usually header is part of the payload logic.
			// Let's assume Header is already in 'response' or written before.)
			// Wait, your code writes Header to 'baos', so it IS in 'response'.
			// TN3270E Header (00 00 00 00 00) doesn't need escaping.

			// 2. Scan buffer for 0xFF and double it
			for (byte b : response) {
				escapedStream.write(b);
				if (b == (byte) 0xFF) {
					escapedStream.write((byte) 0xFF); // Double IAC
				}
			}

			// 3. Append IAC EOR (EndOfRecord) to mark packet end
			escapedStream.write(IAC);
			escapedStream.write((byte) 0xEF);

			// 4. Send
			output.write(escapedStream.toByteArray());
			output.flush();

			System.out.println("Query response sent");

		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	/*
	 * private void sendStructuredFieldResponse(byte[] sfData) throws IOException {
	 * ByteArrayOutputStream baos = new ByteArrayOutputStream();
	 * baos.write(AID_STRUCTURED_FIELD); baos.write(sfData);
	 * 
	 * byte[] response = baos.toByteArray();
	 * 
	 * System.out.println("=== SENDING STRUCTURED FIELD RESPONSE ==="); for (int j =
	 * 0; j < response.length && j < 100; j++) {
	 * System.out.print(String.format("%02X ", response[j])); if ((j + 1) % 16 == 0)
	 * System.out.println(); } System.out.println();
	 * 
	 * sendData(response);
	 * 
	 * // CRITICAL: Ensure the response is actually sent output.flush(); // Add this
	 * if not already in sendData }
	 */
	// =======================================================================
	// 7. ADDRESSING & DATA HELPERS
	// =======================================================================

	private int decode3270Address(byte b1, byte b2) {
		int addr;
		int b1val = b1 & 0xFF;
		int b2val = b2 & 0xFF;

		// Check for 14-bit addressing: if high byte >= 0x40, it's 12-bit
		// If high byte < 0x40, it's 14-bit
		if ((b1val & 0xC0) == 0) {
			// 14-bit addressing: straight binary
			addr = (b1val << 8) | b2val;
		} else {
			// 12-bit addressing: remove 0x40 offset and combine 6+6 bits
			addr = ((b1val & 0x3F) << 6) | (b2val & 0x3F);
		}

		// return addr % (rows * cols);
		return addr;
	}

	private byte[] encode3270Address(int addr) {
		byte[] result = new byte[2];

		// Ensure address is within 14-bit range
		addr = addr & 0x3FFF;

		// IBM standard: addresses >= 4096 require 14-bit addressing
		if (addr >= 0x1000) {
			// 14-bit addressing: straight binary
			result[0] = (byte) ((addr >> 8) & 0xFF);
			result[1] = (byte) (addr & 0xFF);
		} else {
			// 12-bit addressing: use EBCDIC address translation
			int high6 = (addr >> 6) & 0x3F;
			int low6 = addr & 0x3F;
			result[0] = ADDRESS_TABLE[high6];
			result[1] = ADDRESS_TABLE[low6];
		}

		return result;
	}

	// --- Helper: safeConsume ---
	private boolean safeConsume(byte[] data, int currentIndex, int bytesNeeded) {
		return (currentIndex + bytesNeeded) <= data.length;
	}

	// --- Helper: fetchDisplayChar ---
	private char fetchDisplayChar(byte[] data, int[] idxRef) {
		int i = idxRef[0];
		if (!safeConsume(data, i, 1)) {
			// truncated - return space and do not advance
			return ' ';
		}
		byte b = data[i];
		if (b == ORDER_GE) {
			System.out.println("GE order at offset " + i);
			// GE escape: require one more byte (the graphic operand)
			if (!safeConsume(data, i + 1, 1)) {
				// truncated GE -> treat as space, advance past GE byte to avoid loop
				idxRef[0] = i + 1;
				return ' ';
			}
			byte operand = data[i + 1];
			idxRef[0] = i + 2; // consumed GE + operand
			// Translate operand from EBCDIC->APL (table must exist in your code)
			return EBCDIC_TO_APL[operand & 0xFF];
		} else {
			// Normal single-byte display char (EBCDIC -> ASCII)
			idxRef[0] = i + 1; // consumed one byte
			return EBCDIC_TO_ASCII[b & 0xFF];
		}
	}

	// =======================================================================
	// 8. SEND LOGIC
	// =======================================================================

	private void sendReadBuffer() {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			// baos.write(AID_ENTER);
			baos.write(lastAID); // Changed from AID_ENTER
			baos.write(encode3270Address(cursorPos)[0]);
			baos.write(encode3270Address(cursorPos)[1]);

			for (int i = 0; i < buffer.length; i++) {
				if (isFieldStart(i)) {
					baos.write(ORDER_SF);
					baos.write(attributes[i]);
				} else {
					char c = buffer[i];
					if (c == '\0') {
						baos.write(0x00);
					} else if (c < 256 && ASCII_TO_EBCDIC[c] != 0) {
						baos.write(ASCII_TO_EBCDIC[c]);
					} else {
						baos.write(0x40);
					}
				}
			}

			sendData(baos.toByteArray());
			keyboardLocked = true;
			statusBar.update();

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void sendAID(byte aid) {
		lastAID = aid;
		System.out.println("Sending AID: 0x" + String.format("%02X", aid));
		System.out.println("Cursor position (decimal): " + cursorPos);
		System.out.println("Cursor row: " + (cursorPos / cols) + ", col: " + (cursorPos % cols));
		byte[] encodedCursor = encode3270Address(cursorPos);
		System.out.println("Encoded cursor: " + String.format("%02X %02X", encodedCursor[0], encodedCursor[1]));
		keyboardLocked = true;
		statusBar.update();
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			baos.write(aid);
			baos.write(encode3270Address(cursorPos)[0]);
			baos.write(encode3270Address(cursorPos)[1]);

			// Reset Reply Mode if CLEAR key is pressed
			if (aid == AID_CLEAR)
				resetReplyModeToDefault();

			// For read-modified operations, include modified fields
			if (aid == AID_ENTER || (aid >= AID_PF1 && aid <= AID_PF9) || aid == AID_PF10 || aid == AID_PF11
					|| aid == AID_PF12 || (aid >= AID_PF13 && aid <= AID_PF24)) { // Expanded range check to match full
																					// implementation

				int screenSize = rows * cols;
				for (int i = 0; i < screenSize; i++) {
					if (isFieldStart(i) && (attributes[i] & 0x01) != 0) {
						// Found a modified field
						int fieldStart = i;
						int end = findNextField(i);

						// Find first non-null character in field
						int dataStart = fieldStart + 1;
						while (dataStart < end && buffer[dataStart] == '\0') {
							dataStart++;
						}

						// Find last non-null character in field
						int dataEnd = end - 1;
						while (dataEnd > fieldStart && (buffer[dataEnd] == '\0' || buffer[dataEnd] == ' ')) {
							dataEnd--;
						}

						// Only send if there's actual data
						if (dataStart <= dataEnd) {
							baos.write(ORDER_SBA);
							byte[] addr = encode3270Address(dataStart);
							baos.write(addr[0]);
							baos.write(addr[1]);

							System.out.println("Sending modified field: start=" + dataStart + " end=" + dataEnd
									+ " fieldAttr=" + fieldStart);

							for (int j = dataStart; j <= dataEnd; j++) {
								if (!isFieldStart(j)) {
									char c = buffer[j];
									if (c != '\0') {
										if (c < 256 && ASCII_TO_EBCDIC[c] != 0) {
											baos.write(ASCII_TO_EBCDIC[c]);
										} else {
											baos.write(0x40);
										}
									}
								}
							}
						}
					}
				}
			}

			sendData(baos.toByteArray());

		} catch (IOException e) {
			e.printStackTrace();
		}
		canvas.repaint();
	}

	private void sendData(byte[] data) throws IOException {
		ByteArrayOutputStream fullPacket = new ByteArrayOutputStream();

		if (tn3270eMode) {
			fullPacket.write(TN3270E_DT_3270_DATA);
			fullPacket.write(0);
			fullPacket.write(0);
			fullPacket.write(0);
			fullPacket.write(0);
		}

		fullPacket.write(data);

		// Add EOR marker to the SAME packet
		fullPacket.write(IAC);
		fullPacket.write((byte) 0xEF);

		byte[] completePacket = fullPacket.toByteArray();

		System.out.println("=== ALL BYTES SENT ===");
		int n = completePacket.length;
		for (int j = 0; j < n && j < 100; j++) {
			System.out.print(String.format("%02X ", completePacket[j]));
			if ((j + 1) % 16 == 0)
				System.out.println();
		}
		System.out.println();

		// Write everything in ONE operation
		output.write(completePacket);
		output.flush();
	}

	// =======================================================================
	// 9. SCREEN STATE HELPERS
	// =======================================================================

	private boolean isFieldStart(int pos) {
		// return attributes[pos] != 0;
		if (pos < 0 || pos >= attributes.length)
			return false;
		return attributes[pos] != 0;
	}

	private boolean isProtected(int pos) {
		// int fieldStart = findFieldStart(pos);
		// return (attributes[fieldStart] & 0x20) != 0;
		int fieldStart = findFieldStart(pos);
		if (fieldStart < 0) {
			return false; // Unformatted screen defaults to Unprotected
		}
		return (attributes[fieldStart] & 0x20) != 0;
	}

	private void clearUnprotectedModifiedFlags() {
		for (int i = 0; i < rows * cols; i++) {
			if (isFieldStart(i) && !isProtected(i)) {
				// clearModified(i);
				attributes[i] &= 0xFE;
			}
		}
	}

	private boolean isNonDisplay(int pos) {
		// int fieldStart = findFieldStart(pos);
		// return (attributes[fieldStart] & 0x0C) == 0x0C;
		int fieldStart = findFieldStart(pos);
		if (fieldStart < 0) {
			return false; // Unformatted screen defaults to visible
		}
		// Standard 3270: Bits 4 and 5 (0x0C) both set = Non-Display
		return (attributes[fieldStart] & 0x0C) == 0x0C;
	}

	private boolean isModified(int pos) {
		int fieldStart = findFieldStart(pos);
		return (attributes[fieldStart] & 0x01) != 0;
		// return (attributes[pos] & 0x01) != 0;
	}

	private void clearModified(int pos) {
		int fieldStart = findFieldStart(pos);
		attributes[fieldStart] &= 0xFE; // clear MDT
	}

	private int findFieldStart(int pos) {
		// Standard search loop
		for (int i = 0; i < buffer.length; i++) {
			// Check current position FIRST
			int checkPos = (pos - i + buffer.length) % buffer.length;

			if (attributes[checkPos] != 0) {
				return checkPos;
			}
		}
		return -1; // No fields found (unformatted screen)
	}

	private int findNextField(int pos) {
		int next = (pos + 1) % buffer.length;
		int count = 0;
		int maxSize = rows * cols;
		while (!isFieldStart(next) && next != pos && count < maxSize) {
			next = (next + 1) % buffer.length;
			count++;
		}
		return next;
	}

	private void resetMDT() {
		for (int i = 0; i < attributes.length; i++) {
			attributes[i] &= ~0x01;
		}
	}

	private void clearScreen() {
		int size = rows * cols; // Keep the loop-based version
		for (int i = 0; i < size; i++) {
			buffer[i] = ' ';
			attributes[i] = 0;
			extendedColors[i] = 0;
			highlighting[i] = 0;
		}
		cursorPos = 0;
		currentColor = 0;
		currentHighlight = 0;
	}

	// =======================================================================
	// 10. INPUT HANDLING (KEYBOARD & MOUSE)
	// =======================================================================

	public void keyPressed(KeyEvent e) {
		int keyCode = e.getKeyCode();

		// --- Ignore Modifier Keys ---
		// If we don't return here, pressing Command/Ctrl (to start a shortcut)
		// will be treated as "any key press" and trigger clearSelection() immediately.
		if (keyCode == KeyEvent.VK_CONTROL || keyCode == KeyEvent.VK_META || keyCode == KeyEvent.VK_ALT
				|| keyCode == KeyEvent.VK_SHIFT) {
			return;
		}

		// Check for Control (Windows/Linux) or Meta (Command on macOS)
		boolean isModifier = e.isControlDown() || e.isMetaDown();

		// Handle Font Resizing
		if (isModifier) {
			// Increase Font: Ctrl+= or Ctrl+Add (Numpad +)
			if (e.getKeyCode() == KeyEvent.VK_EQUALS || e.getKeyCode() == KeyEvent.VK_ADD) {
				changeFontSize(2); // Increase by 2 points
				return;
			}
			// Decrease Font: Ctrl+- or Ctrl+Subtract (Numpad -)
			if (e.getKeyCode() == KeyEvent.VK_MINUS || e.getKeyCode() == KeyEvent.VK_SUBTRACT) {
				changeFontSize(-2); // Decrease by 2 points
				return;
			}
		}

		// Handle copy/paste shortcuts (Enhanced to support Mac Cmd key as well)
		if (isModifier) {
			if (e.getKeyCode() == KeyEvent.VK_C) {
				copySelection();
				return;
			} else if (e.getKeyCode() == KeyEvent.VK_V) {
				pasteFromClipboard();
				return;
			} else if (e.getKeyCode() == KeyEvent.VK_A) {
				selectAll();
				return;
			}
		}

		// Clear selection on any key press (except copy/paste)
		if (selectionStart >= 0 || selectionEnd >= 0) {
			clearSelection();
		}

		// int keyCode = e.getKeyCode();

		// Handle navigation keys BEFORE the keyboard lock check
		switch (keyCode) {
		case KeyEvent.VK_LEFT:
			clearSelection();
			cursorPos = (cursorPos - 1 + buffer.length) % buffer.length;
			canvas.repaint();
			statusBar.update();
			return;

		case KeyEvent.VK_RIGHT:
			clearSelection();
			cursorPos = (cursorPos + 1) % buffer.length;
			canvas.repaint();
			statusBar.update();
			return;

		case KeyEvent.VK_UP:
			clearSelection();
			cursorPos = (cursorPos - cols + buffer.length) % buffer.length;
			canvas.repaint();
			statusBar.update();
			return;

		case KeyEvent.VK_DOWN:
			clearSelection();
			cursorPos = (cursorPos + cols) % buffer.length;
			canvas.repaint();
			statusBar.update();
			return;

		case KeyEvent.VK_HOME:
			clearSelection();
			cursorPos = 0;
			canvas.repaint();
			statusBar.update();
			return;
		}

		if (keyboardLocked || !connected) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		// Check for custom key mapping first
		KeyMapping mapping = keyMap.get(keyCode);
		if (mapping != null) {
			if (mapping.aid != null) {
				if ("EraseEOF".equals(mapping.description)) {
					eraseToEndOfField();
					return;
				}

				// Mapped to AID function
				sendAID(mapping.aid);
				return;
			} else {
				// Mapped to character - handle in keyTyped
				// (let it fall through)
			}
		}

		// Handle function keys with explicit mapping
		if (keyCode >= KeyEvent.VK_F1 && keyCode <= KeyEvent.VK_F12) {
			byte aid;
			switch (keyCode) {
			case KeyEvent.VK_F1:
				aid = AID_PF1;
				break;
			case KeyEvent.VK_F2:
				aid = AID_PF2;
				break;
			case KeyEvent.VK_F3:
				aid = AID_PF3;
				break;
			case KeyEvent.VK_F4:
				aid = AID_PF4;
				break;
			case KeyEvent.VK_F5:
				aid = AID_PF5;
				break;
			case KeyEvent.VK_F6:
				aid = AID_PF6;
				break;
			case KeyEvent.VK_F7:
				aid = AID_PF7;
				break;
			case KeyEvent.VK_F8:
				aid = AID_PF8;
				break;
			case KeyEvent.VK_F9:
				aid = AID_PF9;
				break;
			case KeyEvent.VK_F10:
				aid = AID_PF10;
				break;
			case KeyEvent.VK_F11:
				aid = AID_PF11;
				break;
			case KeyEvent.VK_F12:
				aid = AID_PF12;
				break;
			default:
				return;
			}

			sendAID(aid);
			return;
		}

		switch (keyCode) {
		case KeyEvent.VK_ESCAPE:
			clearScreen();
			sendAID(AID_CLEAR);
			canvas.repaint();
			return;
		/*
		 * case KeyEvent.VK_ENTER: sendAID(AID_ENTER); return;
		 */
		case KeyEvent.VK_ENTER:
			// Feature: If text is selected, ENTER sends it to AI immediately
			if (selectionStart >= 0 && selectionEnd >= 0 && selectionStart != selectionEnd) {
				String selectedText = getSelectedText();
				if (selectedText != null && !selectedText.trim().isEmpty()) {
					e.consume();
					// Pass 'true' for autoSend
					AIManager.getInstance().showChatDialog(getParentFrame(), selectedText, true);
					clearSelection(); // Clear selection after sending
					return;
				}
			}
			// Otherwise, standard behavior (Send AID to Host)
			sendAID(AID_ENTER);
			return;

		case KeyEvent.VK_INSERT:
			insertMode = !insertMode;
			statusBar.update();
			canvas.repaint();
			return;

		case KeyEvent.VK_TAB:
			if (e.isShiftDown()) {
				tabToPreviousField();
			} else {
				tabToNextField();
			}
			return;

		case KeyEvent.VK_BACK_SPACE:
			if (!isProtected(cursorPos)) {
				moveCursor(-1);
				if (!isProtected(cursorPos)) {
					buffer[cursorPos] = ' ';
					setModified(cursorPos);
					canvas.repaint();
				}
			}
			return;
		}
	}

	public void keyTyped(KeyEvent e) {
		// System.out.println("keyTyped: locked=" + keyboardLocked +
		// " connected=" + connected +
		// " cursorPos=" + cursorPos +
		// " isProtected=" + isProtected(cursorPos) +
		// " isFieldStart=" + isFieldStart(cursorPos) +
		// " char='" + e.getKeyChar() + "' (" + (int)e.getKeyChar() + ")" +
		// " insertMode=" + insertMode);

		if (keyboardLocked || !connected)
			return;

		char c = e.getKeyChar();

		// 1. Check for Physical Key Override
		KeyMapping mapping = keyMap.get(e.getKeyCode());
		if (mapping != null && mapping.aid == null) {
			c = mapping.character;
		}

		// 2. Apply Character Translation
		// If the character exists in our map (e.g. '¦'), replace it. Otherwise keep
		// 'c'.
		c = inputCharMap.getOrDefault(c, c);

		if (c < 32 || c > 126)
			return;

		if (!isProtected(cursorPos)) {
			if (insertMode) {
				int fieldStart = findFieldStart(cursorPos);
				int fieldEnd = findNextField(fieldStart);

				int lastPos = fieldEnd - 1;
				if (isFieldStart(lastPos))
					lastPos--;

				char lastChar = buffer[lastPos];
				if (lastChar != '\0' && lastChar != ' ') {
					if (enableSound)
						Toolkit.getDefaultToolkit().beep();
					return;
				}

				// Shift characters right
				for (int i = lastPos; i > cursorPos; i--) {
					if (!isFieldStart(i) && !isFieldStart(i - 1)) {
						buffer[i] = buffer[i - 1];
					}
				}
			}

			// Common code for both insert and replace modes
			buffer[cursorPos] = c;
			setModified(cursorPos);

			// Check if we need to auto-advance BEFORE moving cursor
			int nextPos = (cursorPos + 1) % (rows * cols);
			moveCursor(1);

			// Only auto-advance if the NEXT position is a field boundary
			if (autoAdvance && isFieldStart(nextPos)) {
				tabToNextField();
			}

			canvas.repaint();
		} else {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
		}
	}

	public void keyReleased(KeyEvent e) {
	}

	private void moveCursor(int delta) {
		cursorPos = (cursorPos + delta + buffer.length) % buffer.length;
		canvas.repaint();
		statusBar.update();
	}

	public void tabToNextField() {
		int start = cursorPos;
		int count = 0;
		int maxSize = rows * cols;

		do {
			cursorPos = (cursorPos + 1) % (rows * cols);
			count++;

			if (isFieldStart(cursorPos)) {
				// We're on a field attribute, check if the field itself is protected
				boolean fieldIsProtected = (attributes[cursorPos] & 0x20) != 0;

				if (!fieldIsProtected) {
					// Move to first position after the field attribute
					cursorPos = (cursorPos + 1) % (rows * cols);
					canvas.repaint();
					statusBar.update();
					return;
				}
			}
		} while (cursorPos != start && count < maxSize);

		// No unprotected field found, stay where we are
		cursorPos = start;
		canvas.repaint();
		statusBar.update();
	}

	private void tabToPreviousField() {
		int start = cursorPos;
		int count = 0;
		int maxSize = rows * cols;

		do {
			cursorPos = (cursorPos - 1 + rows * cols) % (rows * cols);
			count++;

			if (isFieldStart(cursorPos)) {
				// We're on a field attribute, check if the field itself is protected
				boolean fieldIsProtected = (attributes[cursorPos] & 0x20) != 0;

				if (!fieldIsProtected) {
					// Move to first position after the field attribute
					cursorPos = (cursorPos + 1) % (rows * cols);
					canvas.repaint();
					statusBar.update();
					return;
				}
			}
		} while (cursorPos != start && count < maxSize);

		// No unprotected field found, stay where we are
		cursorPos = start;
		canvas.repaint();
		statusBar.update();
	}

	private void setModified(int pos) {
		int fieldStart = findFieldStart(pos);
		attributes[fieldStart] |= 0x01;
	}

	public void eraseToEndOfField() {
		if (isProtected(cursorPos)) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		int fieldStart = findFieldStart(cursorPos);
		int fieldEnd = findNextField(fieldStart);

		for (int i = cursorPos; i < fieldEnd && !isFieldStart(i); i++) {
			buffer[i] = '\0';
		}

		setModified(cursorPos);
		canvas.repaint();
		statusBar.update();
		// Don't lock keyboard - this is a local editing operation
	}

	public void eraseToEndOfLine() {
		if (isProtected(cursorPos)) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		int row = cursorPos / cols;
		int endOfLine = (row + 1) * cols;
		int fieldStart = findFieldStart(cursorPos);
		int fieldEnd = findNextField(fieldStart);

		for (int i = cursorPos; i < endOfLine && i < fieldEnd && !isFieldStart(i); i++) {
			buffer[i] = '\0';
		}

		setModified(cursorPos);
		canvas.repaint();
		statusBar.update();
		// Don't lock keyboard - this is a local editing operation
	}

	public void copySelection() {
		if (selectionStart < 0 || selectionEnd < 0) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		int start = Math.min(selectionStart, selectionEnd);
		int end = Math.max(selectionStart, selectionEnd);

		StringBuilder sb = new StringBuilder();
		int startRow = start / cols;
		int endRow = end / cols;

		for (int row = startRow; row <= endRow; row++) {
			int rowStart = (row == startRow) ? start : row * cols;
			int rowEnd = (row == endRow) ? end : (row + 1) * cols - 1;

			for (int pos = rowStart; pos <= rowEnd && pos < buffer.length; pos++) {
				char c = buffer[pos];
				if (c == '\0')
					c = ' ';
				if (!isFieldStart(pos)) {
					sb.append(c);
				}
			}

			if (row < endRow) {
				sb.append('\n');
			}
		}

		String text = sb.toString();
		String[] lines = text.split("\n");
		StringBuilder cleaned = new StringBuilder();
		for (int i = 0; i < lines.length; i++) {
			cleaned.append(lines[i].replaceAll("\\s+$", ""));
			if (i < lines.length - 1) {
				cleaned.append('\n');
			}
		}

		try {
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			Clipboard clipboard = toolkit.getSystemClipboard();
			StringSelection selection = new StringSelection(cleaned.toString());
			clipboard.setContents(selection, null);

			statusBar.setStatus("Copied " + (end - start + 1) + " characters");
			clearSelection();

		} catch (Exception ex) {
			statusBar.setStatus("Copy failed: " + ex.getMessage());
			ex.printStackTrace();
		}
	}

	public void pasteFromClipboard() {
		if (keyboardLocked || !connected) {
			if (enableSound)
				Toolkit.getDefaultToolkit().beep();
			return;
		}

		try {
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			Clipboard clipboard = toolkit.getSystemClipboard();
			String text = (String) clipboard.getData(java.awt.datatransfer.DataFlavor.stringFlavor);

			if (text == null || text.isEmpty()) {
				return;
			}

			for (char c : text.toCharArray()) {
				if (c == '\n' || c == '\r') {
					tabToNextField();
					continue;
				}

				if (c < 32 || c > 126) {
					continue;
				}

				if (!isProtected(cursorPos)) {
					buffer[cursorPos] = c;
					setModified(cursorPos);

					int nextPos = (cursorPos + 1) % (rows * cols);
					moveCursor(1);

					if (isFieldStart(nextPos)) {
						tabToNextField();
					}
				} else {
					tabToNextField();

					if (!isProtected(cursorPos)) {
						buffer[cursorPos] = c;
						setModified(cursorPos);
						moveCursor(1);
					}
				}
			}

			canvas.repaint();
			statusBar.setStatus("Pasted " + text.length() + " characters");

		} catch (Exception ex) {
			statusBar.setStatus("Paste failed: " + ex.getMessage());
			ex.printStackTrace();
		}
	}

	public void selectAll() {
		selectionStart = 0;
		selectionEnd = buffer.length - 1;
		canvas.repaint();
	}

	private void handleMousePress(MouseEvent e) {
		int pos = screenPositionFromMouse(e.getX(), e.getY());
		if (pos >= 0 && pos < buffer.length) {
			selecting = true;
			selectionStart = pos;
			selectionEnd = pos;
			dragStart = e.getPoint();
			canvas.repaint();
		}
	}

	private void handleMouseDrag(MouseEvent e) {
		if (selecting) {
			int pos = screenPositionFromMouse(e.getX(), e.getY());
			if (pos >= 0 && pos < buffer.length) {
				selectionEnd = pos;
				canvas.repaint();
			}
		}
	}

	private void handleMouseRelease(MouseEvent e) {
		if (selecting) {
			selecting = false;
			// Normalize selection so start < end
			if (selectionStart > selectionEnd) {
				int temp = selectionStart;
				selectionStart = selectionEnd;
				selectionEnd = temp;
			}
		}
	}

	private void selectWord(MouseEvent e) {
		int pos = screenPositionFromMouse(e.getX(), e.getY());
		if (pos >= 0 && pos < buffer.length) {
			// Find word boundaries
			int start = pos;
			int end = pos;

			// Expand left
			while (start > 0 && isWordChar(buffer[start - 1])) {
				start--;
			}

			// Expand right
			while (end < buffer.length - 1 && isWordChar(buffer[end + 1])) {
				end++;
			}

			selectionStart = start;
			selectionEnd = end;
			canvas.repaint();
		}
	}

	private void selectLine(MouseEvent e) {
		int pos = screenPositionFromMouse(e.getX(), e.getY());
		if (pos >= 0 && pos < buffer.length) {
			int row = pos / cols;
			selectionStart = row * cols;
			selectionEnd = (row + 1) * cols - 1;
			canvas.repaint();
		}
	}

	private boolean isWordChar(char c) {
		return Character.isLetterOrDigit(c) || c == '_' || c == '-' || c == '.';
	}

	private int screenPositionFromMouse(int x, int y) {
		// 1. Calculate the same margins used in paintComponent
		int gridWidth = cols * canvas.charWidth;
		int gridHeight = rows * canvas.charHeight;

		// Calculate centering offsets based on current canvas size
		int marginLeft = Math.max(5, (canvas.getWidth() - gridWidth) / 2);
		int marginTop = Math.max(5, (canvas.getHeight() - gridHeight) / 2);

		// 2. Calculate Row/Col relative to those margins
		int col = (x - marginLeft) / canvas.charWidth;
		int row = (y - marginTop) / canvas.charHeight;

		// 3. Clamp values to screen bounds
		if (col < 0)
			col = 0;
		if (col >= cols)
			col = cols - 1;
		if (row < 0)
			row = 0;
		if (row >= rows)
			row = rows - 1;

		return row * cols + col;
	}

	private void clearSelection() {
		selectionStart = -1;
		selectionEnd = -1;
		canvas.repaint();
	}

	public String getSelectedText() {
		// If no selection or invalid selection, return empty
		if (selectionStart < 0 || selectionEnd < 0) {
			return "";
		}

		int start = Math.min(selectionStart, selectionEnd);
		int end = Math.max(selectionStart, selectionEnd);

		StringBuilder sb = new StringBuilder();

		// Iterate through the linear buffer
		for (int i = start; i <= end; i++) {
			char c = buffer[i];
			// Replace nulls with spaces
			if (c == '\0')
				c = ' ';

			sb.append(c);

			// If we hit the right edge of the screen, append a newline
			// (unless it's the very last character of the selection)
			if ((i + 1) % cols == 0 && i != end) {
				sb.append('\n');
			}
		}

		// Cleanup: formatting the text to look better for the AI
		// This removes trailing spaces from lines to make it cleaner
		String raw = sb.toString();
		StringBuilder clean = new StringBuilder();
		for (String line : raw.split("\n")) {
			clean.append(line.replaceAll("\\s+$", "")).append("\n");
		}

		return clean.toString().trim();
	}

	// =======================================================================
	// 11. VISUAL HELPERS
	// =======================================================================

	// Helper: Logic to change font size
	private void changeFontSize(int delta) {
		if (canvas == null)
			return;

		int currentSize = canvas.terminalFont.getSize();
		int newSize = currentSize + delta;

		if (newSize < 6)
			newSize = 6;
		if (newSize > 72)
			newSize = 72;

		if (newSize != currentSize) {
			canvas.terminalFont = new Font("Monospaced", Font.PLAIN, newSize);
			canvas.setFont(canvas.terminalFont);
			FontMetrics fm = canvas.getFontMetrics(canvas.terminalFont);
			canvas.charWidth = fm.charWidth('M');
			canvas.charHeight = fm.getHeight();

			canvas.updateSize();
			canvas.repaint();

			statusBar.setStatus("Font size set to " + newSize + "pt");
		}
	}

	public void applyColorScheme(String schemeName) {
		ColorScheme scheme = COLOR_SCHEMES.get(schemeName);

		if (scheme == null) {
			// Custom scheme handling not strictly in monolith static block,
			// but this method was present in monolith instance logic.
			// If scheme is null, we do nothing or handle custom dialog elsewhere.
			return;
		}

		// Apply the color scheme
		screenBackground = scheme.background;
		defaultForeground = scheme.defaultFg;
		cursorColor = scheme.cursor;

		// Copy colors to the instance colors array
		System.arraycopy(scheme.colors, 0, colors, 0, Math.min(scheme.colors.length, colors.length));

		// Update canvas
		canvas.setBackground(screenBackground);
		canvas.repaint();

		statusBar.setStatus("Color scheme: " + schemeName);
	}

	// Accessor for external UI (Shell)
	public int getFontSize() {
		if (canvas != null && canvas.terminalFont != null)
			return canvas.terminalFont.getSize();
		return 14;
	}

	public void setFontSize(int size) {
		if (canvas != null) {
			canvas.terminalFont = new Font("Monospaced", Font.PLAIN, size);
			canvas.setFont(canvas.terminalFont);
			canvas.updateSize();
			canvas.repaint();
		}
	}

	public void setCursorStyle(CursorStyle style) {
		this.cursorStyle = style;
		canvas.repaint();
	}
	
	// =======================================================================
    // RESTORED UI METHODS & HELPERS
    // =======================================================================

    public void toggleInsertMode() {
        insertMode = !insertMode;
        if (statusBar != null) statusBar.update();
    }

    public void showFontSizeDialog() {
        JDialog dialog = new JDialog(getParentFrame(), "Terminal Font Size", true);
        dialog.setLayout(new BorderLayout(10, 10));

        JPanel mainPanel = new JPanel(new BorderLayout(10, 10));
        mainPanel.setBorder(new EmptyBorder(15, 15, 15, 15));

        JPanel controls = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel lbl = new JLabel("Size (pt):");

        int currentSize = getFontSize();
        JSpinner spinner = new JSpinner(new SpinnerNumberModel(currentSize, 6, 72, 1));
        JSlider slider = new JSlider(6, 48, currentSize);

        spinner.addChangeListener(e -> slider.setValue((Integer) spinner.getValue()));
        slider.addChangeListener(e -> spinner.setValue(slider.getValue()));

        controls.add(lbl);
        controls.add(spinner);
        controls.add(slider);

        JTextArea preview = new JTextArea("  Local VM  \n  READY...  ");
        preview.setFont(canvas.getTerminalFont());
        preview.setBackground(screenBackground);
        preview.setForeground(defaultForeground);
        preview.setEditable(false);
        preview.setBorder(new javax.swing.border.LineBorder(Color.GRAY));

        slider.addChangeListener(e -> {
            int s = slider.getValue();
            preview.setFont(new Font("Monospaced", Font.PLAIN, s));
        });

        mainPanel.add(controls, BorderLayout.NORTH);
        mainPanel.add(new JScrollPane(preview), BorderLayout.CENTER);

        JPanel btnPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton ok = new JButton("Apply");
        JButton cancel = new JButton("Cancel");

        ok.addActionListener(e -> {
            int newSize = (Integer) spinner.getValue();
            int delta = newSize - getFontSize();
            changeFontSize(delta);
            dialog.dispose();
        });
        cancel.addActionListener(e -> dialog.dispose());

        btnPanel.add(cancel);
        btnPanel.add(ok);

        dialog.add(mainPanel, BorderLayout.CENTER);
        dialog.add(btnPanel, BorderLayout.SOUTH);

        dialog.pack();
        dialog.setSize(400, 300);
        dialog.setLocationRelativeTo(getParentFrame());
        dialog.setVisible(true);
    }

    public void showColorSchemeDialog() {
        JDialog dialog = new JDialog(getParentFrame(), "Color Settings", true);
        dialog.setLayout(new BorderLayout());

        JPanel mainPanel = new JPanel(new GridBagLayout());
        mainPanel.setBorder(new EmptyBorder(20, 20, 20, 20));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);

        gbc.gridx = 0; gbc.gridy = 0; gbc.gridwidth = 2;
        mainPanel.add(new JLabel("Load Preset Scheme:"), gbc);

        gbc.gridy = 1;
        JComboBox<String> schemeBox = new JComboBox<>();
        schemeBox.addItem("Green on Black (Classic)");
        schemeBox.addItem("White on Black");
        schemeBox.addItem("Amber on Black");
        schemeBox.addItem("Green on Dark Green");
        schemeBox.addItem("IBM 3270 Blue");
        schemeBox.addItem("Solarized Dark");

        JButton applyPreset = new JButton("Apply");
        applyPreset.addActionListener(e -> {
            applyColorScheme((String) schemeBox.getSelectedItem());
            dialog.dispose();
        });

        JPanel presetPanel = new JPanel(new BorderLayout(5, 0));
        presetPanel.add(schemeBox, BorderLayout.CENTER);
        presetPanel.add(applyPreset, BorderLayout.EAST);
        mainPanel.add(presetPanel, gbc);

        gbc.gridy = 2;
        mainPanel.add(new JSeparator(), gbc);

        gbc.gridy = 3;
        mainPanel.add(new JLabel("Customize Current Colors:"), gbc);

        gbc.gridy = 4; gbc.gridwidth = 1;
        JButton btnBg = new JButton("Background...");
        btnBg.addActionListener(e -> {
            Color newC = JColorChooser.showDialog(dialog, "Screen Background", screenBackground);
            if (newC != null) {
                screenBackground = newC;
                canvas.setBackground(screenBackground);
                canvas.repaint();
            }
        });
        mainPanel.add(btnBg, gbc);

        gbc.gridx = 1;
        JButton btnFg = new JButton("Default Text...");
        btnFg.addActionListener(e -> {
            Color newC = JColorChooser.showDialog(dialog, "Default Text", defaultForeground);
            if (newC != null) {
                defaultForeground = newC;
                canvas.repaint();
            }
        });
        mainPanel.add(btnFg, gbc);

        gbc.gridx = 0; gbc.gridy = 5;
        JButton btnCur = new JButton("Cursor Color...");
        btnCur.addActionListener(e -> {
            Color newC = JColorChooser.showDialog(dialog, "Cursor Color", cursorColor);
            if (newC != null) {
                cursorColor = newC;
                canvas.repaint();
            }
        });
        mainPanel.add(btnCur, gbc);

        dialog.add(mainPanel, BorderLayout.CENTER);

        JPanel footer = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton close = new JButton("Close");
        close.addActionListener(e -> dialog.dispose());
        footer.add(close);
        dialog.add(footer, BorderLayout.SOUTH);

        dialog.pack();
        dialog.setLocationRelativeTo(getParentFrame());
        dialog.setVisible(true);
    }

    public void showKeyboardMappingDialog() {
        // Instantiate the inner class defined in TN3270Emulator (shared UI)
        new TN3270Emulator.KeyboardSettingsDialog(getParentFrame(), this).setVisible(true);
    }

    public void showTerminalSettingsDialog() {
        JDialog dialog = new JDialog(getParentFrame(), "Terminal Settings", true);
        dialog.setLayout(new BorderLayout());

        JPanel mainPanel = new JPanel(new GridBagLayout());
        mainPanel.setBorder(new EmptyBorder(20, 20, 20, 20));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.anchor = GridBagConstraints.WEST;

        gbc.gridx = 0; gbc.gridy = 0;
        mainPanel.add(new JLabel("Terminal Model:"), gbc);

        gbc.gridx = 1;
        String[] models = { "3278-2 (24x80)", "3279-2 (24x80 Color)", "3278-3 (32x80)", "3279-3 (32x80 Color)",
                "3278-4 (43x80)", "3278-5 (27x132)" };
        JComboBox<String> modelBox = new JComboBox<>(models);
        // Basic selection logic...
        for(int i=0; i<models.length; i++) if(models[i].startsWith(this.model)) modelBox.setSelectedIndex(i);
        mainPanel.add(modelBox, gbc);

        gbc.gridx = 0; gbc.gridy = 1;
        mainPanel.add(new JLabel("Cursor Shape:"), gbc);

        gbc.gridx = 1;
        JComboBox<CursorStyle> cursorBox = new JComboBox<>(CursorStyle.values());
        cursorBox.setSelectedItem(cursorStyle);
        mainPanel.add(cursorBox, gbc);

        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 2;
        mainPanel.add(new JSeparator(), gbc);

        gbc.gridy = 3;
        JCheckBox checkBlink = new JCheckBox("Cursor Blink", blinkTimer.isRunning());
        mainPanel.add(checkBlink, gbc);

        gbc.gridy = 4;
        JCheckBox checkSound = new JCheckBox("Enable Sound", enableSound);
        mainPanel.add(checkSound, gbc);

        gbc.gridy = 5;
        JCheckBox checkAuto = new JCheckBox("Auto-advance to next field", autoAdvance);
        mainPanel.add(checkAuto, gbc);

        dialog.add(mainPanel, BorderLayout.CENTER);

        JPanel btnPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton okBtn = new JButton("OK");
        JButton cancelBtn = new JButton("Cancel");

        okBtn.addActionListener(e -> {
            String sel = (String) modelBox.getSelectedItem();
            String newModel = sel.split(" ")[0];
            if (!newModel.equals(this.model)) {
                JOptionPane.showMessageDialog(dialog, "Model change will take effect on the next connection.",
                        "Settings Saved", JOptionPane.INFORMATION_MESSAGE);
                this.model = newModel;
            }
            this.cursorStyle = (CursorStyle) cursorBox.getSelectedItem();
            
            if (checkBlink.isSelected() && !blinkTimer.isRunning()) blinkTimer.start();
            else if (!checkBlink.isSelected() && blinkTimer.isRunning()) blinkTimer.stop();

            this.enableSound = checkSound.isSelected();
            this.autoAdvance = checkAuto.isSelected();

            canvas.repaint();
            dialog.dispose();
        });

        cancelBtn.addActionListener(e -> dialog.dispose());

        btnPanel.add(cancelBtn);
        btnPanel.add(okBtn);
        dialog.add(btnPanel, BorderLayout.SOUTH);

        dialog.pack();
        dialog.setLocationRelativeTo(getParentFrame());
        dialog.setVisible(true);
    }

	// =======================================================================
	// 12. INNER CLASS: TerminalCanvas
	// =======================================================================

	class TerminalCanvas extends JPanel {
		// Class-level fields allow us to sync Sizing and Painting
		private Font terminalFont;
		private int charWidth;
		private int charHeight;
		private int charAscent;

		// Flag to prevent infinite layout loops
		private boolean isUpdatingSize = false;

		public TerminalCanvas() {
			// Default setup
			terminalFont = new Font("Monospaced", Font.PLAIN, 14);

			// --- CRITICAL SWING SETTINGS ---
			setFocusable(true);
			setFocusTraversalKeysEnabled(false); // Keeps TAB key for the emulator
			setDoubleBuffered(true);
			setBackground(Color.BLACK);
			// -------------------------------

			// Forward Scroll Wheel events to the parent ScrollPane
			addMouseWheelListener(e -> {
				Container parent = getParent();
				while (parent != null) {
					if (parent instanceof JScrollPane) {
						JScrollPane sp = (JScrollPane) parent;
						sp.dispatchEvent(SwingUtilities.convertMouseEvent(this, e, sp));
						break;
					}
					parent = parent.getParent();
				}
			});

			// Calculate initial metrics
			updateSize();

			// Mouse Listeners
			addMouseListener(new MouseAdapter() {
				public void mousePressed(MouseEvent e) {
					requestFocusInWindow(); // Grab focus on click
					if (e.isPopupTrigger() || SwingUtilities.isRightMouseButton(e)) {
						String text = TN3270Session.this.getSelectedText();
						AIManager.getInstance().showChatDialog(getParentFrame(), text);
						return;
					}
					handleMousePress(e);
				}

				public void mouseReleased(MouseEvent e) {
					if (e.isPopupTrigger() || SwingUtilities.isRightMouseButton(e)) {
						String text = TN3270Session.this.getSelectedText();
						AIManager.getInstance().showChatDialog(getParentFrame(), text);
						return;
					}
					handleMouseRelease(e);
				}

				public void mouseClicked(MouseEvent e) {
					if (e.getClickCount() == 2)
						selectWord(e);
					else if (e.getClickCount() == 3)
						selectLine(e);
				}
			});

			addMouseMotionListener(new MouseMotionAdapter() {
				public void mouseDragged(MouseEvent e) {
					handleMouseDrag(e);
				}
			});
		}

		/**
		 * Calculates the font size and sets the PreferredSize of the panel. This
		 * controls when ScrollBars appear.
		 */
		public void updateSize() {
			if (isUpdatingSize)
				return; // Prevent recursion
			isUpdatingSize = true;

			try {
				// 1. Get robust metrics
				// We try to get metrics from the screen graphics if available,
				// otherwise fallback to the Toolkit default.
				FontMetrics fm;
				Graphics g = getGraphics();
				if (g != null) {
					fm = g.getFontMetrics(terminalFont);
					g.dispose();
				} else {
					// fm = Toolkit.getDefaultToolkit().getFontMetrics(terminalFont);
					fm = this.getFontMetrics(terminalFont);
				}

				// 2. Update Class-Level fields
				// This ensures paintComponent uses THESE EXACT VALUES
				this.charWidth = fm.charWidth('M');
				this.charHeight = fm.getHeight();
				this.charAscent = fm.getAscent();

				// 3. Calculate Dimensions with Safety Padding
				// +24 gives room for window borders and scrollbars
				int w = (cols * this.charWidth) + 24;
				int h = (rows * this.charHeight) + 24;

				setPreferredSize(new Dimension(w, h));

				// 4. Update Scroll Speeds (User Experience)
				Container parent = getParent();
				if (parent instanceof JViewport && parent.getParent() instanceof JScrollPane) {
					JScrollPane sp = (JScrollPane) parent.getParent();
					sp.getVerticalScrollBar().setUnitIncrement(this.charHeight);
					sp.getHorizontalScrollBar().setUnitIncrement(this.charWidth);
				}

				// 5. Apply
				revalidate();
				repaint();

				// 6. Resize Window (Only if not maximized)
				// NOTE: In tabbed version, resizing the parent frame based on one tab's content
				// is generally discouraged, but we keep the logic to match functionality.
				Window win = SwingUtilities.getWindowAncestor(this);
				if (win != null && (win instanceof Frame)) {
					Frame f = (Frame) win;
					if ((f.getExtendedState() & Frame.MAXIMIZED_BOTH) == 0) {
						f.pack();
					}
				}
			} finally {
				isUpdatingSize = false;
			}
		}

		@Override
		public void setFont(Font f) {
			super.setFont(f);
			this.terminalFont = f;
			// Recalculate size whenever font changes
			updateSize();
		}

		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g); // Clears background to Black

			// Apply the font
			g.setFont(terminalFont);

			// Do NOT calculate font metrics here.
			// Use 'this.charWidth' and 'this.charHeight' calculated in updateSize().
			// This guarantees the text grid matches the scrollable area exactly.

			boolean blinkVisible = (System.currentTimeMillis() / 500) % 2 == 0;

			// Calculate Centering Offsets ---
			// Determine the total size of the text grid in pixels
			int gridWidth = cols * this.charWidth;
			int gridHeight = rows * this.charHeight;

			// Calculate margins to center the grid
			// Math.max(5, ...) ensures we never draw off the top-left edge
			// if the window is shrunk too small.
			int marginLeft = Math.max(5, (getWidth() - gridWidth) / 2);
			int marginTop = Math.max(5, (getHeight() - gridHeight) / 2);

			for (int row = 0; row < rows; row++) {
				for (int col = 0; col < cols; col++) {
					int pos = row * cols + col;
					char c = buffer[pos];

					// Standard 3270 Hidden Field logic
					if (isNonDisplay(pos) && !isFieldStart(pos))
						continue;
					if (attributes[pos] != 0)
						c = ' ';
					else if (c == '\0')
						c = ' ';

					// Colors
					Color fg = defaultForeground;
					Color bg = screenBackground;
					boolean reverseVideo = false;
					boolean blink = false;
					boolean underscore = false;

					// Selection
					boolean isSelected = false;
					if (selectionStart >= 0 && selectionEnd >= 0) {
						int start = Math.min(selectionStart, selectionEnd);
						int end = Math.max(selectionStart, selectionEnd);
						isSelected = (pos >= start && pos <= end);
					}

					// Attributes
					byte highlight = highlighting[pos];
					if (highlight == 0 && attributes[pos] == 0) {
						int fieldStart = findFieldStart(pos);
						if (fieldStart >= 0)
							highlight = highlighting[fieldStart];
					}

					if (attributes[pos] == 0) {
						if (highlight == (byte) 0xF2)
							reverseVideo = true;
						else if (highlight == (byte) 0xF1)
							blink = true;
						else if (highlight == (byte) 0xF4)
							underscore = true;
					}

					// Extended Colors
					if (extendedColors[pos] > 0 && extendedColors[pos] < colors.length) {
						fg = colors[extendedColors[pos]];
					} else {
						int fieldStart = findFieldStart(pos);
						if (fieldStart >= 0) {
							if (extendedColors[fieldStart] > 0 && extendedColors[fieldStart] < colors.length) {
								fg = colors[extendedColors[fieldStart]];
							} else {
								byte attr = attributes[fieldStart];
								boolean isProtected = (attr & 0x20) != 0;
								boolean isIntensified = (attr & 0x08) != 0;
								if ((attr & 0x0C) == 0x0C)
									fg = bg;
								else if (isProtected)
									fg = isIntensified ? Color.WHITE : Color.CYAN;
								else
									fg = isIntensified ? Color.WHITE : Color.GREEN;
							}
						}
					}

					// --- DRAWING COORDINATES ---

					// Use calculated margins
					int cellTop = marginTop + (row * this.charHeight);
					int x = marginLeft + (col * this.charWidth);

					// Use Ascent to position text baseline perfectly within the cell
					int y = cellTop + this.charAscent;

					if (isSelected) {
						Color temp = fg;
						fg = Color.WHITE;
						bg = new Color(0, 120, 215);
					} else if (reverseVideo) {
						Color temp = fg;
						fg = bg;
						bg = temp;
					}

					if (!bg.equals(screenBackground)) {
						g.setColor(bg);
						g.fillRect(x, cellTop, this.charWidth, this.charHeight);
					}

					if (blink && !blinkVisible)
						continue;

					g.setColor(fg);
					g.drawString(String.valueOf(c), x, y);

					if (underscore) {
						// Draw underscore at the baseline + 2 pixels (for a little separation between
						// characters and underline)
						g.drawLine(x, y + 2, x + this.charWidth, y + 2);
					}
				}
			}

			// Draw Cursor
			if (!keyboardLocked) {
				int row = cursorPos / cols;
				int col = cursorPos % cols;
				// int x = 5 + col * this.charWidth;
				// int y = 5 + row * this.charHeight;
				int x = marginLeft + col * this.charWidth;
				int y = marginTop + row * this.charHeight;

				g.setColor(cursorColor);

				switch (cursorStyle) {
				case BLOCK:
					g.fillRect(x, y, this.charWidth, this.charHeight);
					g.setXORMode(screenBackground);
					break;
				case UNDERSCORE:
					g.fillRect(x, y + this.charHeight - 2, this.charWidth, 2);
					break;
				case I_BEAM:
					g.fillRect(x, y, 2, this.charHeight);
					break;
				}
				g.setPaintMode();
			}
		}

		public Font getTerminalFont() {
			return terminalFont;
		}
	}

	// =======================================================================
	// 13. INNER CLASS: StatusBar
	// =======================================================================

	// Use JPanel (Swing) instead of Panel (AWT) to enable ToolTips
	class StatusBar extends javax.swing.JPanel {
		private javax.swing.JLabel statusLabel;
		private javax.swing.JLabel ipLabel;
		private javax.swing.JLabel positionLabel;

		public StatusBar() {
			setLayout(new BorderLayout());
			setBackground(Color.DARK_GRAY);
			setBorder(new javax.swing.border.EmptyBorder(2, 5, 2, 5)); // Add internal padding

			// LEFT: Connection Status / Messages
			statusLabel = new javax.swing.JLabel("Not connected");
			statusLabel.setForeground(Color.WHITE);
			statusLabel.setFont(new Font("SansSerif", Font.PLAIN, 12));
			add(statusLabel, BorderLayout.WEST);

			// RIGHT: Container for IP and Position
			javax.swing.JPanel rightPanel = new javax.swing.JPanel(new FlowLayout(FlowLayout.RIGHT, 15, 0));
			rightPanel.setOpaque(false); // Transparent background to match parent

			// 1. IP Address Label
			ipLabel = new javax.swing.JLabel("");
			ipLabel.setForeground(new Color(200, 200, 200)); // Slightly dimmer than white
			ipLabel.setFont(new Font("SansSerif", Font.PLAIN, 11));
			rightPanel.add(ipLabel);

			// 2. Cursor Position Label
			positionLabel = new javax.swing.JLabel("Row: 01 Col: 01");
			positionLabel.setForeground(Color.WHITE);
			// Monospaced ensures the label doesn't jitter when numbers change width
			positionLabel.setFont(new Font("Monospaced", Font.BOLD, 12));
			rightPanel.add(positionLabel);

			add(rightPanel, BorderLayout.EAST);
		}

		public void setStatus(String status) {
			statusLabel.setText(status);
		}

		/**
		 * Smartly sets the IP. Truncates long IPv6 addresses visually but keeps full
		 * address in tooltip.
		 */
		public void setIP(String ip) {
			if (ip == null || ip.isEmpty()) {
				ipLabel.setText("");
				ipLabel.setToolTipText(null);
				return;
			}

			String displayIP = ip;

			// If IPv6 (contains ':') and is long, truncate visually
			if (ip.contains(":") && ip.length() > 20) {
				// Show start...end
				displayIP = ip.substring(0, 8) + "..." + ip.substring(ip.length() - 4);
				// Set the tool tip to the FULL address
				ipLabel.setToolTipText("Remote IP: " + ip);
			} else {
				ipLabel.setToolTipText(null);
			}

			// Add brackets for clarity
			ipLabel.setText("[" + displayIP + "]");
		}

		public void update() {
			// Calculate 1-based coordinates
			int row = (cursorPos / cols) + 1;
			int col = (cursorPos % cols) + 1;
			positionLabel.setText(String.format("Row: %02d Col: %02d", row, col));
		}
	}

	// =======================================================================
	// 14. AI INFRASTRUCTURE & UI COMPONENTS
	// =======================================================================

	/* ---------------------- AIModelProvider ---------------------- */
	public interface AIModelProvider {
		String[] listModels();

		String send(String model, String prompt, String context) throws Exception;

		// default streaming fallback: call send() and deliver as single chunk
		default void sendStream(String model, String prompt, String context, Consumer<String> onChunk,
				Consumer<Exception> onError, Runnable onComplete) throws Exception {
			try {
				String r = send(model, prompt, context);
				onChunk.accept(r);
				onComplete.run();
			} catch (Exception ex) {
				onError.accept(ex);
				onComplete.run();
			}
		}
	}
	/* -------------------- end AIModelProvider -------------------- */

	/* ---------------------- OpenAIProvider ---------------------- */
	public static class OpenAIProvider implements AIModelProvider {

		private final String apiKey;
		private final String[] models;
		private final String endpoint;

		public OpenAIProvider(String apiKey, String[] models) {
			this(apiKey, models, "https://api.openai.com/v1/chat/completions");
		}

		public OpenAIProvider(String apiKey, String[] models, String endpoint) {
			this.apiKey = apiKey;
			this.models = models == null ? new String[0] : models;
			this.endpoint = endpoint != null ? endpoint : "https://api.openai.com/v1/chat/completions";
		}

		@Override
		public String[] listModels() {
			return models;
		}

		@Override
		public String send(String model, String prompt, String context) throws Exception {
			// Non-streaming fallback
			return doRequest(model, prompt, context, false, null);
		}

		@Override
		public void sendStream(String model, String prompt, String context, Consumer<String> onChunk,
				Consumer<Exception> onError, Runnable onComplete) throws Exception {
			try {
				doRequest(model, prompt, context, true, onChunk);
				onComplete.run();
			} catch (Exception e) {
				onError.accept(e);
				onComplete.run();
			}
		}

		private String doRequest(String model, String prompt, String context, boolean stream, Consumer<String> onChunk)
				throws Exception {
			String fullContext = (context == null ? "" : context + "\n\n");
			String fullContent = fullContext + (prompt == null ? "" : prompt);

			byte[] payloadBytes = buildPayloadBytes(model, fullContent, stream);

			// FIX: new URL(String) is deprecated. Use URI.create().toURL() instead.
			URL url = new URI(endpoint).toURL();

			HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
			conn.setRequestMethod("POST");
			conn.setDoOutput(true);
			conn.setConnectTimeout(15000);

			// If streaming, we read indefinitely; otherwise 60s timeout
			conn.setReadTimeout(stream ? 0 : 60000);

			conn.setRequestProperty("Content-Type", "application/json");
			conn.setRequestProperty("Authorization", "Bearer " + apiKey);

			try (OutputStream os = conn.getOutputStream()) {
				os.write(payloadBytes);
				os.flush();
			}

			int code = conn.getResponseCode();
			InputStream in = (code < 300) ? conn.getInputStream() : conn.getErrorStream();

			if (code >= 300) {
				StringBuilder sb = new StringBuilder();
				try (BufferedReader r = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = r.readLine()) != null)
						sb.append(line);
				}
				String json = sb.toString();
				String errorMsg = extractJsonField(json, "message");
				if (errorMsg.isEmpty())
					errorMsg = "API Error " + code + ": " + json;
				throw new IOException(errorMsg);
			}

			if (stream && onChunk != null) {
				try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = reader.readLine()) != null) {
						if (line.startsWith("data: ")) {
							String data = line.substring(6).trim();
							if ("[DONE]".equals(data))
								break;
							String chunk = extractJsonField(data, "content");
							if (!chunk.isEmpty()) {
								onChunk.accept(chunk);
							}
						}
					}
				}
				return "";
			} else {
				StringBuilder sb = new StringBuilder();
				try (BufferedReader r = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = r.readLine()) != null)
						sb.append(line).append('\n');
				}
				String json = sb.toString();
				return extractJsonField(json, "content");
			}
		}

		private byte[] buildPayloadBytes(String model, String content, boolean stream) {
			StringBuilder sb = new StringBuilder();
			sb.append("{");
			sb.append("\"model\":").append(jsonEscape(model)).append(",");
			sb.append("\"stream\":").append(stream).append(","); // IMPORTANT: Enable streaming
			sb.append("\"messages\":[");
			sb.append("{\"role\":\"system\",\"content\":")
					.append(jsonEscape("You are assisting a TN3270 mainframe user.")).append("},");
			sb.append("{\"role\":\"user\",\"content\":").append(jsonEscape(content)).append("}");
			sb.append("]}");
			return sb.toString().getBytes(StandardCharsets.UTF_8);
		}

		// Improved JSON value extractor that handles escaped quotes
		private String extractJsonField(String json, String key) {
			String search = "\"" + key + "\"";
			int startIdx = json.lastIndexOf(search); // Use lastIndexOf to find deeply nested content/message
			if (startIdx < 0)
				return "";

			// Find the colon after the key
			int colonIdx = json.indexOf(':', startIdx + search.length());
			if (colonIdx < 0)
				return "";

			// Find the opening quote of the value
			int valueStart = json.indexOf('"', colonIdx + 1);
			if (valueStart < 0)
				return "";

			// Find closing quote, skipping escaped quotes \"
			int valueEnd = valueStart + 1;
			while (valueEnd < json.length()) {
				char c = json.charAt(valueEnd);
				if (c == '\\') {
					valueEnd += 2; // Skip escaped char
					continue;
				}
				if (c == '"') {
					break; // Found end
				}
				valueEnd++;
			}

			if (valueEnd >= json.length())
				return "";

			String content = json.substring(valueStart + 1, valueEnd);

			// Unescape common JSON sequences
			return content.replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t").replace("\\\"", "\"")
					.replace("\\\\", "\\");
		}

		private String jsonEscape(String s) {
			if (s == null)
				return "\"\"";
			StringBuilder sb = new StringBuilder("\"");
			for (char c : s.toCharArray()) {
				switch (c) {
				case '\\':
					sb.append("\\\\");
					break;
				case '"':
					sb.append("\\\"");
					break;
				case '\b':
					sb.append("\\b");
					break;
				case '\f':
					sb.append("\\f");
					break;
				case '\n':
					sb.append("\\n");
					break;
				case '\r':
					sb.append("\\r");
					break;
				case '\t':
					sb.append("\\t");
					break;
				default:
					if (c < 0x20 || c > 0x7f)
						sb.append(String.format("\\u%04x", (int) c));
					else
						sb.append(c);
				}
			}
			sb.append('"');
			return sb.toString();
		}
	}
	/* -------------------- end OpenAIProvider -------------------- */

	/* ---------------------- AIConfig ---------------------- */
	public static class AIConfig {
		private final Properties props = new Properties();
		private final File file;

		public AIConfig(String path) {
			this.file = new File(path);
			load();
		}

		public void load() {
			try {
				props.clear();
				if (file.exists())
					try (FileInputStream fis = new FileInputStream(file)) {
						props.load(fis);
					}
			} catch (Exception e) {
				System.err.println("AIConfig.load: " + e.getMessage());
			}
		}

		public String get(String key, String def) {
			return props.getProperty(key, def);
		}

		public boolean getBoolean(String key, boolean def) {
			String v = props.getProperty(key);
			if (v == null)
				return def;
			return "true".equalsIgnoreCase(v) || "1".equals(v);
		}

		public String[] getModels() {
			String m = props.getProperty("ai.models");
			if (m == null)
				return new String[] { "gpt-4o-mini", "gpt-4o" };
			return Arrays.stream(m.split(",")).map(String::trim).filter(s -> !s.isEmpty()).toArray(String[]::new);
		}

		public String getProvider() {
			return props.getProperty("ai.provider", "openai");
		}

		public String getApiKey() {
			return props.getProperty("ai.apiKey", "");
		}

		public String getEndpoint() {
			return props.getProperty("ai.endpoint", "http://localhost:11434");
		}

		public void put(String k, String v) {
			props.setProperty(k, v);
		}

		public void save() throws IOException {
			try (FileOutputStream fos = new FileOutputStream(file)) {
				props.store(fos, "ai.conf");
			}
		}

		public File file() {
			return file;
		}

		public Properties props() {
			return props;
		}
	}
	/* -------------------- end AIConfig -------------------- */

	/* -------------------- AIHistoryStore -------------------- */
	public static class AIHistoryStore {
		private final File dir;

		public AIHistoryStore(String dirPath) {
			this.dir = new File(dirPath);
			if (!this.dir.exists())
				this.dir.mkdirs();
		}

		public File save(String json, String baseName) {
			try {
				long ts = System.currentTimeMillis();
				String name = baseName.replaceAll("[^A-Za-z0-9_.-]", "_") + "_" + ts + ".json";
				File out = new File(dir, name);
				try (FileWriter fw = new FileWriter(out)) {
					fw.write(json);
					fw.flush();
				}
				return out;
			} catch (Exception e) {
				System.err.println("AIHistoryStore.save: " + e.getMessage());
				return null;
			}
		}

		public File[] listFiles() {
			File[] files = dir.listFiles((d, n) -> n.endsWith(".json"));
			if (files == null)
				return new File[0];
			Arrays.sort(files, (a, b) -> Long.compare(b.lastModified(), a.lastModified()));
			return files;
		}

		public String read(File f) {
			if (f == null || !f.exists())
				return null;
			try (BufferedReader r = new BufferedReader(new FileReader(f))) {
				StringBuilder sb = new StringBuilder();
				String line;
				while ((line = r.readLine()) != null)
					sb.append(line).append('\n');
				return sb.toString();
			} catch (Exception e) {
				System.err.println("AIHistoryStore.read: " + e.getMessage());
				return null;
			}
		}
	}
	/* ------------------ end AIHistoryStore ------------------ */

	/* -------------------- AIStreamingClient -------------------- */
	public static class AIStreamingClient {
		private final AIModelProvider provider;

		public AIStreamingClient(AIModelProvider provider) {
			this.provider = provider;
		}

		public void sendStream(String model, String prompt, String context, Consumer<String> onChunk,
				Consumer<Exception> onError, Runnable onComplete) {
			new Thread(() -> {
				try {
					provider.sendStream(model, prompt, context, onChunk, onError, onComplete);
				} catch (Exception ex) {
					try {
						String r = provider.send(model, prompt, context);
						onChunk.accept(r);
						onComplete.run();
					} catch (Exception ex2) {
						onError.accept(ex2);
						onComplete.run();
					}
				}
			}, "AIStream-" + model).start();
		}
	}
	/* ---------------- end AIStreamingClient ---------------- */

	/* -------------------- AIMessageBubble (Swing) -------------------- */
	public static class AIMessageBubble extends javax.swing.JPanel {
		public final String who;
		private final javax.swing.JTextArea textArea;
		private final javax.swing.JScrollPane scrollPane;
		private final Color bubbleColor;
		// private final Color borderColor = new Color(180, 180, 180);
		private final Color borderColor;

		public AIMessageBubble(String who, String text, Font font, Color fg, Color bg) {
			this.who = who;
			this.setLayout(new BorderLayout());
			this.setOpaque(false);

			this.bubbleColor = bg; // Use passed background
			// Make border slightly darker than background
			this.borderColor = new Color(Math.max(0, bg.getRed() - 30), Math.max(0, bg.getGreen() - 30),
					Math.max(0, bg.getBlue() - 30));

			// this.bubbleColor = "user".equals(who) ? new Color(220, 240, 255) : new
			// Color(245, 245, 245);

			// Text Area Configuration
			textArea = new javax.swing.JTextArea(text);
			textArea.setFont(font);
			textArea.setForeground(fg);
			textArea.setBackground(bubbleColor);
			textArea.setEditable(false);

			// Default to Wrapped
			textArea.setLineWrap(true);
			textArea.setWrapStyleWord(true);
			textArea.setBorder(new EmptyBorder(5, 5, 5, 5));

			// Selection Colors
			textArea.setSelectionColor(new Color(50, 100, 255));
			textArea.setSelectedTextColor(Color.WHITE);

			// Wrap in ScrollPane
			scrollPane = new javax.swing.JScrollPane(textArea);
			scrollPane.setBorder(null);
			scrollPane.setOpaque(false);
			scrollPane.getViewport().setOpaque(false);
			scrollPane.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
			scrollPane.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);

			// Custom Rounded Panel Container
			javax.swing.JPanel bubblePanel = new javax.swing.JPanel(new BorderLayout()) {
				@Override
				protected void paintComponent(Graphics g) {
					Graphics2D g2 = (Graphics2D) g.create();
					g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
					g2.setColor(bubbleColor);
					g2.fillRoundRect(0, 0, getWidth() - 1, getHeight() - 1, 12, 12);
					g2.setColor(borderColor);
					g2.drawRoundRect(0, 0, getWidth() - 1, getHeight() - 1, 12, 12);
					g2.dispose();
				}

				@Override
				public Dimension getPreferredSize() {
					Dimension d = textArea.getPreferredSize();
					Container parent = getParent();
					if (parent != null && parent.getParent() != null) {
						int scrollWidth = parent.getParent().getWidth();
						if (scrollWidth > 0) {
							int maxW = (int) (scrollWidth * 0.90);
							if (textArea.getLineWrap()) {
								textArea.setSize(new Dimension(maxW, Short.MAX_VALUE));
								Dimension pref = textArea.getPreferredSize();
								int targetW = Math.min(pref.width + 25, maxW);
								return new Dimension(targetW, pref.height + 25);
							} else {
								int targetW = Math.min(d.width + 25, maxW);
								int scrollBarHeight = (d.width > maxW) ? 20 : 0;
								return new Dimension(targetW, d.height + 25 + scrollBarHeight);
							}
						}
					}
					return new Dimension(d.width + 25, d.height + 25);
				}
			};

			bubblePanel.setOpaque(false);
			bubblePanel.setBorder(new EmptyBorder(4, 4, 4, 4));
			bubblePanel.add(scrollPane, BorderLayout.CENTER);

			// Context Menu
			javax.swing.JPopupMenu popup = new javax.swing.JPopupMenu();

			javax.swing.JMenuItem copyItem = new javax.swing.JMenuItem("Copy Message");
			copyItem.addActionListener(e -> {
				textArea.selectAll();
				textArea.copy();
				textArea.setCaretPosition(0);
			});

			javax.swing.JCheckBoxMenuItem wrapItem = new javax.swing.JCheckBoxMenuItem("Word Wrap", true);
			wrapItem.addActionListener(e -> {
				boolean wrap = wrapItem.isSelected();
				textArea.setLineWrap(wrap);
				textArea.setWrapStyleWord(wrap);
				bubblePanel.revalidate();
				if (getParent() != null)
					getParent().revalidate();
				repaint();
			});

			popup.add(copyItem);
			popup.addSeparator();
			popup.add(wrapItem);

			textArea.setComponentPopupMenu(popup);

			// Alignment Container
			javax.swing.JPanel alignPanel = new javax.swing.JPanel(
					new FlowLayout("user".equals(who) ? FlowLayout.RIGHT : FlowLayout.LEFT));
			alignPanel.setOpaque(false);
			alignPanel.add(bubblePanel);

			add(alignPanel, BorderLayout.CENTER);

			// --- FIX: Forward Trackpad/MouseWheel events to Main ScrollBar ---
			// Since this bubble expands to fit height, the inner vertical scrollbar is
			// usually invisible.
			// We explicitly forward the event to the parent ScrollPane so trackpad
			// scrolling works.
			MouseWheelListener forwarder = e -> {
				// Only forward if inner vertical bar is NOT visible (meaning we are displaying
				// full height)
				if (!scrollPane.getVerticalScrollBar().isVisible()) {
					javax.swing.JScrollPane parentScroll = (javax.swing.JScrollPane) javax.swing.SwingUtilities
							.getAncestorOfClass(javax.swing.JScrollPane.class, getParent());
					if (parentScroll != null) {
						parentScroll.dispatchEvent(
								javax.swing.SwingUtilities.convertMouseEvent(e.getComponent(), e, parentScroll));
					}
				}
			};
			textArea.addMouseWheelListener(forwarder);
			scrollPane.addMouseWheelListener(forwarder);
		}

		public void appendText(String s) {
			textArea.append(s);
			textArea.setCaretPosition(textArea.getDocument().getLength());
			revalidate();
			repaint();
		}
	}
	/* ---------------- end AIMessageBubble ---------------- */

	/* -------------------- AIChatScrollView (Swing) -------------------- */
	public static class AIChatScrollView extends javax.swing.JPanel {
		public final javax.swing.JPanel listPanel;
		private final javax.swing.JScrollPane scrollPane;

		public AIChatScrollView(Font uiFont, Color fg, Color bg) {
			super(new BorderLayout());

			listPanel = new javax.swing.JPanel();
			listPanel.setLayout(new javax.swing.BoxLayout(listPanel, javax.swing.BoxLayout.Y_AXIS));
			listPanel.setBackground(Color.WHITE);

			scrollPane = new javax.swing.JScrollPane(listPanel);
			scrollPane.setBorder(null);
			scrollPane.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
			scrollPane.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);

			// Auto-scroll behavior
			DefaultCaret caret = new DefaultCaret();
			caret.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);

			add(scrollPane, BorderLayout.CENTER);
		}

		public AIMessageBubble addMessage(String who, String text, Font uiFont, Color fg, Color bg) {
			AIMessageBubble bubble = new AIMessageBubble(who, text, uiFont, fg, bg);

			// Limit width to 80% of view
			bubble.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));

			listPanel.add(bubble);
			listPanel.add(javax.swing.Box.createRigidArea(new Dimension(0, 5))); // Spacing

			listPanel.revalidate();
			listPanel.repaint();

			// Scroll to bottom
			EventQueue.invokeLater(() -> {
				javax.swing.JScrollBar vertical = scrollPane.getVerticalScrollBar();
				vertical.setValue(vertical.getMaximum());
			});

			return bubble;
		}

		public void clear() {
			listPanel.removeAll();
			listPanel.revalidate();
			listPanel.repaint();
		}

		public String exportConversationJson() {
			// (JSON export logic remains the same, just iterating Swing components)
			StringBuilder sb = new StringBuilder();
			sb.append("{\"conversation\":[");
			Component[] comps = listPanel.getComponents();
			boolean first = true;
			for (Component c : comps) {
				// Swing adds intermediate containers, so we check recursivley or simplified
				if (c instanceof AIMessageBubble) {
					if (!first)
						sb.append(",");
					first = false;
					AIMessageBubble b = (AIMessageBubble) c;
					// Note: accessing private text via accessor or reflection in previous code
					// Here we access the JTextArea directly if we made it public, or parsing:
					// For simplicity, assuming text passed in constructor is source of truth
					// Ideally, create a getter in AIMessageBubble.
				}
			}
			sb.append("]}");
			return sb.toString();
		}
	}
	/* ---------------- end AIChatScrollView ---------------- */

	// =======================================================================
	// 15. AI CHAT WINDOW (Continued) & REMAINING INNER CLASSES
	// =======================================================================

	/* -------------------- AIChatWindow -------------------- */
	public static class AIChatWindow extends JDialog {
		private final Frame owner;
		public final AIChatScrollView chatView;
		private final JTextArea inputArea;
		private final Choice modelChoice;
		private final JButton sendBtn, tryNextBtn, saveBtn, loadBtn, prefsBtn;
		private final JLabel spinner;
		private final AIStreamingClient streamingClient;
		private final AIHistoryStore historyStore;
		private final AIConfig config;
		private String lastPrompt = null;

		// --- Theme Palette ---
		private final Color BG_MAIN = new Color(245, 247, 250); // Very light blue-gray
		private final Color BG_INPUT = Color.WHITE;
		private final Color TEXT_COLOR = new Color(30, 30, 30);

		public AIChatWindow(Frame owner, AIModelProvider prov, AIConfig cfg) {
			super((Frame) null, "AI Assistant", false);

			this.owner = owner;
			this.config = cfg;
			this.streamingClient = new AIStreamingClient(prov);
			this.historyStore = new AIHistoryStore(cfg.get("ai.autosave.dir", "ai_history"));

			setLayout(new BorderLayout());
			setSize(950, 750);
			getContentPane().setBackground(BG_MAIN);

			// --- TOP TOOLBAR ---
			JPanel top = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 12));
			top.setBackground(Color.WHITE);
			top.setBorder(new javax.swing.border.MatteBorder(0, 0, 1, 0, new Color(230, 230, 230)));

			JLabel lblModel = new JLabel("Model:");
			lblModel.setFont(new Font("SansSerif", Font.BOLD, 12));

			modelChoice = new Choice();
			for (String m : cfg.getModels())
				modelChoice.add(m);

			// Color-Coded Buttons
			sendBtn = createColorButton("Send", new Color(0, 120, 215), Color.WHITE); // Windows Blue
			tryNextBtn = createColorButton("Retry", new Color(255, 140, 0), Color.WHITE); // Orange
			saveBtn = createColorButton("Save", new Color(40, 167, 69), Color.WHITE); // Green
			loadBtn = createColorButton("Load", new Color(108, 117, 125), Color.WHITE); // Grey
			prefsBtn = createColorButton("Config", new Color(23, 162, 184), Color.WHITE); // Cyan/Teal

			spinner = new JLabel("Idle");
			spinner.setForeground(Color.GRAY);
			spinner.setFont(new Font("SansSerif", Font.ITALIC, 11));

			top.add(lblModel);
			top.add(modelChoice);
			top.add(Box.createHorizontalStrut(15));
			top.add(sendBtn);
			top.add(tryNextBtn);
			top.add(Box.createHorizontalStrut(15));
			top.add(saveBtn);
			top.add(loadBtn);
			top.add(Box.createHorizontalStrut(15));
			top.add(prefsBtn);
			top.add(Box.createHorizontalStrut(15));
			top.add(spinner);

			add(top, BorderLayout.NORTH);

			// --- CHAT AREA ---
			Font chatFont = new Font("Monospaced", Font.PLAIN, 13);
			chatView = new AIChatScrollView(chatFont, TEXT_COLOR, Color.WHITE);

			// Wrapper for padding
			JPanel chatWrapper = new JPanel(new BorderLayout());
			chatWrapper.setBackground(Color.WHITE);
			chatWrapper.setBorder(new EmptyBorder(0, 0, 0, 0));
			chatWrapper.add(chatView, BorderLayout.CENTER);
			add(chatWrapper, BorderLayout.CENTER);

			// --- BOTTOM INPUT AREA ---
			JPanel bottom = new JPanel(new BorderLayout(0, 8)); // Vertical gap 8
			bottom.setBackground(BG_MAIN);
			bottom.setBorder(new EmptyBorder(15, 20, 15, 20));

			// 1. Greeting Label
			JLabel greeting = new JLabel("Hi, what can I help you with?");
			greeting.setFont(new Font("SansSerif", Font.BOLD, 14));
			greeting.setForeground(new Color(80, 80, 90));
			bottom.add(greeting, BorderLayout.NORTH);

			// 2. Input Box with Rounded Corners
			inputArea = new JTextArea(3, 80);
			inputArea.setFont(chatFont);
			inputArea.setBackground(BG_INPUT);
			inputArea.setForeground(TEXT_COLOR);
			inputArea.setCaretColor(TEXT_COLOR);
			inputArea.setLineWrap(true);
			inputArea.setWrapStyleWord(true);
			// Margin inside the text area
			inputArea.setBorder(new EmptyBorder(8, 8, 8, 8));

			JScrollPane inputScroll = new JScrollPane(inputArea);
			// Use our custom RoundedBorder
			inputScroll.setBorder(new RoundedBorder(12, new Color(200, 200, 200)));
			inputScroll.setBackground(BG_MAIN); // Match container so corners look clean
			inputScroll.getViewport().setBackground(BG_INPUT);

			bottom.add(inputScroll, BorderLayout.CENTER);

			// 3. Hint Label
			JLabel hint = new JLabel("Enter to send, Shift+Enter for newline");
			hint.setForeground(Color.GRAY);
			hint.setFont(new Font("SansSerif", Font.PLAIN, 10));
			hint.setHorizontalAlignment(SwingConstants.RIGHT);
			bottom.add(hint, BorderLayout.SOUTH);

			add(bottom, BorderLayout.SOUTH);

			// --- HANDLERS ---
			sendBtn.addActionListener(e -> doSend());
			tryNextBtn.addActionListener(e -> doTryNext());
			prefsBtn.addActionListener(e -> new AIPreferencesPanel(owner, config).showDialog());

			inputArea.addKeyListener(new KeyAdapter() {
				public void keyPressed(KeyEvent e) {
					if (e.getKeyCode() == KeyEvent.VK_ENTER && !e.isShiftDown()) {
						e.consume();
						doSend();
					}
				}
			});

			// Context Menu for Input
			JPopupMenu popup = new JPopupMenu();
			JMenuItem cut = new JMenuItem("Cut");
			cut.addActionListener(e -> inputArea.cut());
			JMenuItem copy = new JMenuItem("Copy");
			copy.addActionListener(e -> inputArea.copy());
			JMenuItem paste = new JMenuItem("Paste");
			paste.addActionListener(e -> inputArea.paste());
			popup.add(cut);
			popup.add(copy);
			popup.add(paste);
			inputArea.setComponentPopupMenu(popup);
		}

		private JButton createColorButton(String text, Color baseColor, Color textColor) {
			JButton btn = new JButton(text);
			btn.setBackground(baseColor);
			btn.setForeground(textColor);
			btn.setFocusPainted(false);
			btn.setFont(new Font("SansSerif", Font.BOLD, 11));

			// Rounded empty border for the button shape
			btn.setBorder(new javax.swing.border.CompoundBorder(new RoundedBorder(10, baseColor.darker()),
					new javax.swing.border.EmptyBorder(4, 12, 4, 12)));

			btn.setCursor(new Cursor(Cursor.HAND_CURSOR));
			btn.setContentAreaFilled(false); // We will paint background manually for hover effect
			btn.setOpaque(false);

			// Custom painting for hover effect
			btn.setUI(new javax.swing.plaf.basic.BasicButtonUI() {
				@Override
				public void paint(Graphics g, JComponent c) {
					AbstractButton b = (AbstractButton) c;
					ButtonModel model = b.getModel();
					Graphics2D g2 = (Graphics2D) g.create();
					g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

					Color fill = baseColor;
					if (model.isPressed())
						fill = baseColor.darker();
					else if (model.isRollover())
						fill = baseColor.brighter();

					g2.setColor(fill);
					g2.fillRoundRect(0, 0, c.getWidth(), c.getHeight(), 10, 10);

					super.paint(g2, c);
					g2.dispose();
				}
			});

			return btn;
		}

		public void showWithPrefill(String selectedText, String sysPrompt, boolean autoSend) {
			if (selectedText != null && !selectedText.isEmpty()) {
				inputArea.setText(selectedText);
				inputArea.setCaretPosition(0);
				inputArea.requestFocusInWindow();
			}

			if (sysPrompt != null && !sysPrompt.isEmpty() && !sysPrompt.startsWith("You are")) {
				chatView.addMessage("assistant", "[System Context]\n" + sysPrompt, inputArea.getFont(),
						new Color(100, 100, 100), new Color(255, 255, 220));
			}

			setLocationRelativeTo(owner);
			setVisible(true);

			if (autoSend && selectedText != null && !selectedText.trim().isEmpty()) {
				SwingUtilities.invokeLater(this::doSend);
			}
		}

		private void doSend() {
			String prompt = inputArea.getText().trim();
			if (prompt.isEmpty())
				return;

			String model = modelChoice.getSelectedItem();
			lastPrompt = prompt;

			// User Bubble: Blue background, White text
			chatView.addMessage("user", prompt, inputArea.getFont(), Color.WHITE, new Color(0, 120, 215));

			inputArea.setText("");
			spinner.setText("Sending to " + model + "...");

			String sys = config.get("ai.prompt.default", "You are assisting a TN3270 mainframe user.");

			streamingClient.sendStream(model, prompt, sys, chunk -> {
				EventQueue.invokeLater(() -> {
					Component[] comps = chatView.listPanel.getComponents();
					AIMessageBubble lastBubble = null;

					for (int i = comps.length - 1; i >= 0; i--) {
						if (comps[i] instanceof AIMessageBubble) {
							lastBubble = (AIMessageBubble) comps[i];
							break;
						}
					}

					if (lastBubble != null && "assistant".equals(lastBubble.who)) {
						lastBubble.appendText(chunk);
					} else {
						// Assistant Bubble: Light Grey background, Black text
						chatView.addMessage("assistant", chunk, inputArea.getFont(), Color.BLACK,
								new Color(240, 242, 245));
					}
				});
			}, ex -> EventQueue.invokeLater(() -> {
				chatView.addMessage("assistant", "[Error] " + ex.getMessage(), inputArea.getFont(),
						new Color(180, 0, 0), new Color(255, 235, 235));
				spinner.setText("Error");
			}), () -> EventQueue.invokeLater(() -> spinner.setText("Idle")));
		}

		private void doTryNext() {
			if (lastPrompt == null)
				return;
			int idx = modelChoice.getSelectedIndex();
			if (idx < 0)
				return;
			int next = (idx + 1) % modelChoice.getItemCount();
			modelChoice.select(next);
			inputArea.setText(lastPrompt);
			doSend();
		}
	}

	/* -------------------- AIPreferencesPanel -------------------- */
	public static class AIPreferencesPanel {
		private final Frame owner;
		private final AIConfig config;
		private final javax.swing.JDialog dialog;
		private final javax.swing.JTextArea ta;

		public AIPreferencesPanel(Frame owner, AIConfig cfg) {
			this.owner = owner;
			this.config = cfg;

			// Convert to JDialog
			dialog = new javax.swing.JDialog(owner, "AI Preferences", true);
			dialog.setLayout(new BorderLayout());

			// Use JTextArea (Supports native Copy/Paste)
			ta = new javax.swing.JTextArea(20, 80);
			ta.setFont(new Font("Monospaced", Font.PLAIN, 12));

			try {
				StringBuilder sb = new StringBuilder();
				File f = cfg.file();
				if (f.exists())
					try (BufferedReader r = new BufferedReader(new FileReader(f))) {
						String line;
						while ((line = r.readLine()) != null)
							sb.append(line).append('\n');
					}
				ta.setText(sb.toString());
			} catch (Exception e) {
				ta.setText("# error reading ai.conf: " + e.getMessage());
			}

			// Wrap in ScrollPane
			javax.swing.JScrollPane scroll = new javax.swing.JScrollPane(ta);

			// Bottom Panel
			javax.swing.JPanel p = new javax.swing.JPanel(new FlowLayout(FlowLayout.RIGHT));
			javax.swing.JButton save = new javax.swing.JButton("Save");
			javax.swing.JButton cancel = new javax.swing.JButton("Cancel");

			p.add(save);
			p.add(cancel);

			save.addActionListener(e -> {
				try (FileWriter fw = new FileWriter(config.file())) {
					fw.write(ta.getText());
					fw.flush();
				} catch (Exception se) {
					System.out.println("Exception saving config: " + se.getMessage());
				}
				config.load();
				// If AIManager exists, reload it to pick up new key
				AIManager.getInstance().reloadConfig();
				dialog.dispose();
			});

			cancel.addActionListener(e -> dialog.dispose());

			// Add native context menu for Cut/Copy/Paste to the config text area
			javax.swing.JPopupMenu popup = new javax.swing.JPopupMenu();
			javax.swing.JMenuItem cut = new javax.swing.JMenuItem("Cut");
			cut.addActionListener(e -> ta.cut());
			javax.swing.JMenuItem copy = new javax.swing.JMenuItem("Copy");
			copy.addActionListener(e -> ta.copy());
			javax.swing.JMenuItem paste = new javax.swing.JMenuItem("Paste");
			paste.addActionListener(e -> ta.paste());
			popup.add(cut);
			popup.add(copy);
			popup.add(paste);
			ta.setComponentPopupMenu(popup);

			dialog.add(scroll, BorderLayout.CENTER);
			dialog.add(p, BorderLayout.SOUTH);
			dialog.setSize(700, 500);
			dialog.setLocationRelativeTo(owner);
		}

		public void showDialog() {
			dialog.setVisible(true);
		}
	}

	/* ---------------------- OllamaProvider ---------------------- */
	public static class OllamaProvider implements AIModelProvider {

		private final String endpoint;
		private final String[] models;

		public OllamaProvider(String endpoint, String[] models) {
			// Ensure endpoint doesn't end with a slash, and default to standard Ollama port
			// if not specified
			this.endpoint = (endpoint != null && !endpoint.isEmpty()) ? endpoint.replaceAll("/+$", "")
					: "http://localhost:11434";

			// Default to generic llama3 if no models specified
			this.models = (models == null || models.length == 0) ? new String[] { "llama3", "mistral" } : models;
		}

		@Override
		public String[] listModels() {
			return models;
		}

		@Override
		public String send(String model, String prompt, String context) throws Exception {
			// Non-streaming request
			return doRequest(model, prompt, context, false, null);
		}

		@Override
		public void sendStream(String model, String prompt, String context, Consumer<String> onChunk,
				Consumer<Exception> onError, Runnable onComplete) throws Exception {
			try {
				doRequest(model, prompt, context, true, onChunk);
				onComplete.run();
			} catch (Exception e) {
				onError.accept(e);
				onComplete.run();
			}
		}

		private String doRequest(String model, String prompt, String context, boolean stream, Consumer<String> onChunk)
				throws Exception {

			// Combine context and prompt
			String fullPrompt = (context != null && !context.isEmpty()) ? context + "\n\n" + prompt : prompt;

			// Build JSON Payload for Ollama /api/chat
			StringBuilder json = new StringBuilder();
			json.append("{");
			json.append("\"model\": \"").append(jsonEscape(model)).append("\",");
			json.append("\"stream\": ").append(stream).append(",");
			json.append("\"messages\": [");
			json.append("{ \"role\": \"user\", \"content\": \"").append(jsonEscape(fullPrompt)).append("\" }");
			json.append("]");
			json.append("}");

			// Construct URL (Ollama Chat Endpoint)
			URL url = new URI(endpoint + "/api/chat").toURL();

			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod("POST");
			conn.setDoOutput(true);
			conn.setConnectTimeout(5000); // 5s connection timeout (local network is fast)
			conn.setReadTimeout(stream ? 0 : 120000); // Infinite read for stream, 2m for block

			conn.setRequestProperty("Content-Type", "application/json");

			try (OutputStream os = conn.getOutputStream()) {
				os.write(json.toString().getBytes(StandardCharsets.UTF_8));
				os.flush();
			}

			int code = conn.getResponseCode();
			InputStream in = (code < 300) ? conn.getInputStream() : conn.getErrorStream();

			if (code >= 300) {
				try (BufferedReader r = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					StringBuilder err = new StringBuilder();
					String line;
					while ((line = r.readLine()) != null)
						err.append(line);
					throw new IOException("Ollama Error " + code + ": " + err.toString());
				}
			}

			// Handle Response
			if (stream && onChunk != null) {
				try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = reader.readLine()) != null) {
						// Ollama sends distinct JSON objects per line
						String content = extractOllamaContent(line);
						if (content != null && !content.isEmpty()) {
							onChunk.accept(content);
						}
					}
				}
				return "";
			} else {
				StringBuilder fullResponse = new StringBuilder();
				try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
					String line;
					while ((line = reader.readLine()) != null) {
						String content = extractOllamaContent(line);
						if (content != null)
							fullResponse.append(content);
					}
				}
				return fullResponse.toString();
			}
		}

		// Helper to extract content from Ollama's JSON response
		private String extractOllamaContent(String json) {
			String marker = "\"content\":\"";
			int start = json.indexOf(marker);
			if (start < 0)
				return null;
			start += marker.length();

			// Simple parser to find the closing quote, handling escaped quotes
			StringBuilder sb = new StringBuilder();
			boolean escaped = false;
			for (int i = start; i < json.length(); i++) {
				char c = json.charAt(i);
				if (escaped) {
					if (c == 'n')
						sb.append('\n');
					else if (c == 'r')
						sb.append('\r');
					else if (c == 't')
						sb.append('\t');
					else
						sb.append(c);
					escaped = false;
				} else {
					if (c == '\\') {
						escaped = true;
					} else if (c == '"') {
						break; // End of string
					} else {
						sb.append(c);
					}
				}
			}
			return sb.toString();
		}

		private String jsonEscape(String s) {
			if (s == null)
				return "";
			StringBuilder sb = new StringBuilder();
			for (char c : s.toCharArray()) {
				switch (c) {
				case '\\':
					sb.append("\\\\");
					break;
				case '"':
					sb.append("\\\"");
					break;
				case '\b':
					sb.append("\\b");
					break;
				case '\f':
					sb.append("\\f");
					break;
				case '\n':
					sb.append("\\n");
					break;
				case '\r':
					sb.append("\\r");
					break;
				case '\t':
					sb.append("\\t");
					break;
				default:
					if (c < 0x20)
						sb.append(String.format("\\u%04x", (int) c));
					else
						sb.append(c);
				}
			}
			return sb.toString();
		}
	}

	// --- UI HELPER: ROUNDED BORDER ---
	// Used by the AI Chat Window for the input text area
	static class RoundedBorder extends AbstractBorder {
		private final int radius;
		private final Color color;

		public RoundedBorder(int radius, Color color) {
			this.radius = radius;
			this.color = color;
		}

		@Override
		public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
			Graphics2D g2 = (Graphics2D) g.create();
			g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			g2.setColor(color);
			g2.drawRoundRect(x, y, width - 1, height - 1, radius, radius);
			g2.dispose();
		}

		@Override
		public Insets getBorderInsets(Component c) {
			return new Insets(this.radius / 2, this.radius / 2, this.radius / 2, this.radius / 2);
		}

		@Override
		public Insets getBorderInsets(Component c, Insets insets) {
			insets.left = insets.top = insets.right = insets.bottom = this.radius / 2;
			return insets;
		}
	}

	/* -------------------- AIManager -------------------- */
	public static class AIManager {
		private static AIManager instance;
		private AIConfig config;
		private AIModelProvider provider;
		private AIChatWindow activeWindow;

		private AIManager() {
			config = new AIConfig("ai.conf");
		}

		public static synchronized AIManager getInstance() {
			if (instance == null)
				instance = new AIManager();
			return instance;
		}

		public void reloadConfig() {
			config.load();
			provider = null;
		}

		public AIModelProvider resolveProvider() {
			if (provider != null)
				return provider;

			String prov = config.getProvider();

			if ("ollama".equalsIgnoreCase(prov)) {
				String endpoint = config.get("ai.endpoint", "http://localhost:11434");
				provider = new OllamaProvider(endpoint, config.getModels());
			} else if ("google".equalsIgnoreCase(prov)) {
				String googleEndpoint = "https://generativelanguage.googleapis.com/v1beta/openai/chat/completions";
				provider = new OpenAIProvider(config.getApiKey(), config.getModels(), googleEndpoint);
			} else {
				provider = new OpenAIProvider(config.getApiKey(), config.getModels());
			}
			return provider;
		}

		public void showChatDialog(Frame owner, String selectedText, boolean autoSend) {
			if (activeWindow != null && activeWindow.isVisible()) {
				activeWindow.toFront();
				activeWindow.showWithPrefill(selectedText, config.get("ai.prompt.default", ""), autoSend);
				return;
			}
			AIModelProvider prov = resolveProvider();
			AIChatWindow w = new AIChatWindow(owner, prov, config);
			this.activeWindow = w;
			w.showWithPrefill(selectedText, config.get("ai.prompt.default", ""), autoSend);
		}

		public void showChatDialog(Frame owner, String text) {
			showChatDialog(owner, text, false);
		}
	}

	// Bridge method for session
	public void showAIChatDialog(Frame owner, String text) {
		AIManager.getInstance().showChatDialog(owner, text);
	}

} // End of TN3270Session